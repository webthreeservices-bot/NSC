{
  "assign_unique_referral_code_after_bot_purchase": "CREATE OR REPLACE FUNCTION public.assign_unique_referral_code_after_bot_purchase()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$ BEGIN IF NEW.\"status\" = 'ACTIVE' AND (OLD IS NULL OR OLD.\"status\" != 'ACTIVE') THEN UPDATE \"User\" SET \"hasPurchasedBot\" = true WHERE \"id\" = NEW.\"userId\"; INSERT INTO \"Notification\" (\"id\", \"userId\", \"title\", \"message\", \"type\", \"referenceType\") VALUES (gen_random_uuid()::text, NEW.\"userId\", 'Referral Code Activated', 'Congratulations! You can now earn referral and direct income from your referrals!', 'SUCCESS', 'REFERRAL'); END IF; RETURN NEW; END; $function$\n",
  "check_login_blocking": "CREATE OR REPLACE FUNCTION public.check_login_blocking(p_email text, p_ip_address text, p_max_attempts integer DEFAULT 5, p_window_minutes integer DEFAULT 15)\n RETURNS TABLE(\"isBlocked\" boolean, \"blockReason\" text, \"failedAttempts\" integer, \"lastAttemptAt\" timestamp without time zone, \"blockUntil\" timestamp without time zone)\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n  failed_count INTEGER;\n  last_attempt TIMESTAMP;\n  block_until TIMESTAMP;\n  account_locked_until TIMESTAMP;\nBEGIN\n  -- Check if account is already locked\n  SELECT \"accountLockedUntil\" INTO account_locked_until\n  FROM \"User\" WHERE \"email\" = p_email;\n  \n  IF account_locked_until IS NOT NULL AND account_locked_until > NOW() THEN\n    RETURN QUERY SELECT \n      true,\n      'Account temporarily locked',\n      0::INTEGER,\n      NULL::TIMESTAMP,\n      account_locked_until;\n    RETURN;\n  END IF;\n  \n  -- Count failed attempts in the time window (by email OR IP address)\n  SELECT COUNT(*), MAX(\"createdAt\")\n  INTO failed_count, last_attempt\n  FROM \"LoginAttempt\"\n  WHERE (\"email\" = p_email OR \"ipAddress\" = p_ip_address)\n    AND \"success\" = false\n    AND \"createdAt\" >= NOW() - (p_window_minutes || ' minutes')::INTERVAL;\n  \n  -- Check if blocked\n  IF failed_count >= p_max_attempts THEN\n    block_until := last_attempt + (p_window_minutes || ' minutes')::INTERVAL;\n    \n    -- Update user account lock\n    UPDATE \"User\"\n    SET \"accountLockedUntil\" = block_until\n    WHERE \"email\" = p_email;\n    \n    RETURN QUERY SELECT \n      true,\n      'Too many failed login attempts',\n      failed_count,\n      last_attempt,\n      block_until;\n  ELSE\n    RETURN QUERY SELECT \n      false,\n      NULL::TEXT,\n      failed_count,\n      last_attempt,\n      NULL::TIMESTAMP;\n  END IF;\nEND;\n$function$\n",
  "create_event_notification": "CREATE OR REPLACE FUNCTION public.create_event_notification()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  -- Package activated (only for Package table)\n  IF TG_TABLE_NAME = 'Package' THEN\n    IF NEW.\"status\" = 'ACTIVE' AND OLD.\"status\" = 'PENDING' THEN\n      INSERT INTO \"Notification\" (\"id\", \"userId\", \"title\", \"message\", \"type\", \"referenceId\", \"referenceType\")\n      VALUES (\n        gen_random_uuid()::text,\n        NEW.\"userId\",\n        'Package Activated',\n        'Your ' || NEW.\"packageType\" || ' package has been activated successfully!',\n        'SUCCESS',\n        NEW.\"id\",\n        'PACKAGE'\n      );\n    END IF;\n  END IF;\n  \n  -- Withdrawal notifications (only for Withdrawal table)\n  IF TG_TABLE_NAME = 'Withdrawal' THEN\n    -- Withdrawal approved\n    IF NEW.\"status\" = 'APPROVED' AND OLD.\"status\" = 'PENDING' THEN\n      INSERT INTO \"Notification\" (\"id\", \"userId\", \"title\", \"message\", \"type\", \"referenceId\", \"referenceType\")\n      VALUES (\n        gen_random_uuid()::text,\n        NEW.\"userId\",\n        'Withdrawal Approved',\n        'Your withdrawal request of ' || NEW.\"amount\" || ' USDT has been approved!',\n        'SUCCESS',\n        NEW.\"id\",\n        'WITHDRAWAL'\n      );\n    END IF;\n    \n    -- Withdrawal rejected\n    IF NEW.\"status\" = 'REJECTED' AND OLD.\"status\" = 'PENDING' THEN\n      INSERT INTO \"Notification\" (\"id\", \"userId\", \"title\", \"message\", \"type\", \"referenceId\", \"referenceType\")\n      VALUES (\n        gen_random_uuid()::text,\n        NEW.\"userId\",\n        'Withdrawal Rejected',\n        'Your withdrawal request has been rejected. Reason: ' || COALESCE(NEW.\"rejectionReason\", 'Not specified'),\n        'ERROR',\n        NEW.\"id\",\n        'WITHDRAWAL'\n      );\n    END IF;\n  END IF;\n  \n  -- KYC approved (only for User table)\n  IF TG_TABLE_NAME = 'User' THEN\n    IF NEW.\"kycStatus\" = 'APPROVED' AND OLD.\"kycStatus\" != 'APPROVED' THEN\n      INSERT INTO \"Notification\" (\"id\", \"userId\", \"title\", \"message\", \"type\", \"referenceType\")\n      VALUES (\n        gen_random_uuid()::text,\n        NEW.\"id\",\n        'KYC Approved',\n        'Your KYC verification has been approved!',\n        'SUCCESS',\n        'KYC'\n      );\n    END IF;\n  END IF;\n  \n  RETURN NEW;\nEND;\n$function$\n",
  "create_session": "CREATE OR REPLACE FUNCTION public.create_session(p_user_id text, p_token_hash text, p_refresh_token_hash text, p_ip_address text, p_user_agent text, p_expires_at timestamp without time zone)\n RETURNS text\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n  v_session_id TEXT;\nBEGIN\n  v_session_id := gen_random_uuid()::text;\n  \n  INSERT INTO \"Session\" (\n    \"id\", \"userId\", \"token\", \"refreshToken\", \"ipAddress\", \"userAgent\",\n    \"expiresAt\", \"isActive\", \"status\", \"createdAt\", \"lastUsedAt\"\n  ) VALUES (\n    v_session_id, p_user_id, p_token_hash, p_refresh_token_hash, p_ip_address, p_user_agent,\n    p_expires_at, true, 'ACTIVE', NOW(), NOW()\n  );\n  \n  RETURN v_session_id;\nEND;\n$function$\n",
  "create_withdrawal_transaction": "CREATE OR REPLACE FUNCTION public.create_withdrawal_transaction()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\n      DECLARE\n        v_transaction_id TEXT;\n      BEGIN\n        IF NEW.\"status\" = 'COMPLETED' AND (OLD.\"status\" IS NULL OR OLD.\"status\" != 'COMPLETED') THEN\n          v_transaction_id := gen_random_uuid()::text;\n\n          INSERT INTO \"Transaction\" (\n            \"id\", \"userId\", \"type\", \"amount\", \"fee\", \"netAmount\",\n            \"status\", \"description\", \"txHash\", \"network\",\n            \"referenceId\", \"referenceType\"\n          ) VALUES (\n            v_transaction_id,\n            NEW.\"userId\",\n            'WITHDRAWAL'::\"TransactionType\",\n            NEW.\"amount\",\n            NEW.\"fee\",\n            NEW.\"netAmount\",\n            'COMPLETED'::\"TransactionStatus\",\n            'Withdrawal to ' || NEW.\"walletAddress\",\n            NEW.\"txHash\",\n            NEW.\"network\",\n            NEW.\"id\",\n            'WITHDRAWAL'\n          );\n\n          -- Link transaction to withdrawal\n          UPDATE \"Withdrawal\" SET \"transactionId\" = v_transaction_id WHERE \"id\" = NEW.\"id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n      $function$\n",
  "get_next_referral_code": "CREATE OR REPLACE FUNCTION public.get_next_referral_code()\n RETURNS text\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n  next_value INTEGER;\n  new_code TEXT;\nBEGIN\n  UPDATE \"ReferralCounter\"\n  SET \"currentValue\" = \"currentValue\" + 1,\n      \"updatedAt\" = NOW()\n  WHERE \"counterType\" = 'NSCREF'\n  RETURNING \"currentValue\" INTO next_value;\n  \n  new_code := 'NSCREF' || next_value::TEXT;\n  RETURN new_code;\nEND;\n$function$\n",
  "log_admin_action": "CREATE OR REPLACE FUNCTION public.log_admin_action()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  -- Log withdrawal approvals (only for Withdrawal table)\n  IF TG_TABLE_NAME = 'Withdrawal' THEN\n    IF NEW.\"approvedBy\" IS NOT NULL AND (OLD.\"approvedBy\" IS NULL OR OLD.\"approvedBy\" IS DISTINCT FROM NEW.\"approvedBy\") THEN\n      INSERT INTO \"AdminLog\" (\n        \"id\", \"adminId\", \"action\", \"targetType\", \"targetId\", \"description\"\n      ) VALUES (\n        gen_random_uuid()::text,\n        NEW.\"approvedBy\",\n        'APPROVE_WITHDRAWAL',\n        'WITHDRAWAL',\n        NEW.\"id\",\n        'Approved withdrawal of ' || NEW.\"amount\" || ' USDT for user ' || NEW.\"userId\"\n      );\n    END IF;\n    \n    -- Log withdrawal rejections\n    IF NEW.\"status\" = 'REJECTED' AND OLD.\"status\" != 'REJECTED' THEN\n      INSERT INTO \"AdminLog\" (\n        \"id\", \"adminId\", \"action\", \"targetType\", \"targetId\", \"description\"\n      ) VALUES (\n        gen_random_uuid()::text,\n        NEW.\"rejectedBy\",\n        'REJECT_WITHDRAWAL',\n        'WITHDRAWAL',\n        NEW.\"id\",\n        'Rejected withdrawal: ' || COALESCE(NEW.\"rejectionReason\", 'No reason provided')\n      );\n    END IF;\n  END IF;\n  \n  -- Log user blocking (only for User table)\n  IF TG_TABLE_NAME = 'User' THEN\n    IF NEW.\"isBlocked\" = true AND OLD.\"isBlocked\" = false THEN\n      INSERT INTO \"AdminLog\" (\n        \"id\", \"adminId\", \"action\", \"targetType\", \"targetId\", \"description\"\n      ) VALUES (\n        gen_random_uuid()::text,\n        NEW.\"blockedBy\",\n        'BLOCK_USER',\n        'USER',\n        NEW.\"id\",\n        'Blocked user: ' || COALESCE(NEW.\"blockReason\", 'No reason provided')\n      );\n    END IF;\n    \n    -- Log KYC approvals\n    IF NEW.\"kycStatus\" = 'APPROVED' AND OLD.\"kycStatus\" != 'APPROVED' THEN\n      INSERT INTO \"AdminLog\" (\n        \"id\", \"adminId\", \"action\", \"targetType\", \"targetId\", \"description\"\n      ) VALUES (\n        gen_random_uuid()::text,\n        'SYSTEM',\n        'APPROVE_KYC',\n        'USER',\n        NEW.\"id\",\n        'Approved KYC verification'\n      );\n    END IF;\n  END IF;\n  \n  RETURN NEW;\nEND;\n$function$\n",
  "process_referral_earnings": "CREATE OR REPLACE FUNCTION public.process_referral_earnings()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\n      DECLARE\n        earning_record RECORD;\n        transaction_id TEXT;\n      BEGIN\n        -- Only process when package becomes ACTIVE\n        IF NEW.\"status\" = 'ACTIVE' AND (OLD.\"status\" IS NULL OR OLD.\"status\" != 'ACTIVE') THEN\n\n          -- Calculate and create earnings for referral chain\n          FOR earning_record IN\n            SELECT * FROM calculate_referral_earnings(NEW.\"id\", NEW.\"userId\", NEW.\"amount\")\n          LOOP\n            -- Create transaction record\n            transaction_id := gen_random_uuid()::text;\n\n            INSERT INTO \"Transaction\" (\n              \"id\", \"userId\", \"type\", \"amount\", \"status\", \"description\",\n              \"referenceId\", \"referenceType\"\n            ) VALUES (\n              transaction_id,\n              earning_record.\"referrerId\",\n              (CASE WHEN earning_record.\"level\" = 1 THEN 'REFERRAL_BONUS' ELSE 'LEVEL_INCOME' END)::\"TransactionType\",\n              earning_record.\"amount\",\n              'COMPLETED'::\"TransactionStatus\",\n              'Level ' || earning_record.\"level\" || ' income from package purchase',\n              NEW.\"id\",\n              'PACKAGE'\n            );\n\n            -- Create earning record\n            INSERT INTO \"Earning\" (\n              \"id\", \"userId\", \"fromUserId\", \"packageId\", \"transactionId\",\n              \"earningType\", \"amount\", \"level\", \"percentage\", \"status\"\n            ) VALUES (\n              gen_random_uuid()::text,\n              earning_record.\"referrerId\",\n              NEW.\"userId\",\n              NEW.\"id\",\n              transaction_id,\n              CASE WHEN earning_record.\"level\" = 1 THEN 'DIRECT_REFERRAL' ELSE 'LEVEL_INCOME' END,\n              earning_record.\"amount\",\n              earning_record.\"level\",\n              earning_record.\"percentage\",\n              'PAID'\n            );\n\n            -- Create notification\n            INSERT INTO \"Notification\" (\n              \"id\", \"userId\", \"title\", \"message\", \"type\", \"referenceId\", \"referenceType\"\n            ) VALUES (\n              gen_random_uuid()::text,\n              earning_record.\"referrerId\",\n              'Referral Earnings',\n              'You earned ' || earning_record.\"amount\" || ' USDT from Level ' || earning_record.\"level\" || ' referral income!',\n              'REFERRAL',\n              NEW.\"id\",\n              'PACKAGE'\n            );\n          END LOOP;\n        END IF;\n\n        RETURN NEW;\n      END;\n      $function$\n",
  "record_login_attempt": "CREATE OR REPLACE FUNCTION public.record_login_attempt(p_email text, p_ip_address text, p_user_agent text, p_success boolean, p_failure_reason text DEFAULT NULL::text)\n RETURNS text\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n  attempt_id TEXT;\n  v_user_id TEXT;\nBEGIN\n  -- Get user ID if exists\n  SELECT \"id\" INTO v_user_id FROM \"User\" WHERE \"email\" = p_email;\n  \n  attempt_id := gen_random_uuid()::text;\n  \n  INSERT INTO \"LoginAttempt\" (\n    \"id\", \"email\", \"userId\", \"ipAddress\", \"userAgent\", \n    \"success\", \"failureReason\", \"createdAt\"\n  ) VALUES (\n    attempt_id, p_email, v_user_id, p_ip_address, p_user_agent, \n    p_success, p_failure_reason, NOW()\n  );\n  \n  -- Update user record if login was successful\n  IF p_success AND v_user_id IS NOT NULL THEN\n    UPDATE \"User\"\n    SET \"lastLogin\" = NOW(),\n        \"lastLoginIp\" = p_ip_address,\n        \"failedLoginAttempts\" = 0,\n        \"lastActiveAt\" = NOW()\n    WHERE \"id\" = v_user_id;\n  ELSIF NOT p_success AND v_user_id IS NOT NULL THEN\n    UPDATE \"User\"\n    SET \"failedLoginAttempts\" = COALESCE(\"failedLoginAttempts\", 0) + 1,\n        \"lastFailedLoginAt\" = NOW()\n    WHERE \"id\" = v_user_id;\n  END IF;\n  \n  RETURN attempt_id;\nEND;\n$function$\n",
  "revoke_all_user_sessions": "CREATE OR REPLACE FUNCTION public.revoke_all_user_sessions(p_user_id text)\n RETURNS integer\n LANGUAGE plpgsql\nAS $function$\n      DECLARE\n        v_updated INTEGER;\n      BEGIN\n        UPDATE \"Session\"\n        SET \"isActive\" = false\n        WHERE \"userId\" = p_user_id\n        AND \"isActive\" = true;\n\n        GET DIAGNOSTICS v_updated = ROW_COUNT;\n        RETURN v_updated;\n      END;\n      $function$\n",
  "revoke_other_sessions": "CREATE OR REPLACE FUNCTION public.revoke_other_sessions(p_user_id text, p_current_session_id text)\n RETURNS integer\n LANGUAGE plpgsql\nAS $function$\n      DECLARE\n        v_updated INTEGER;\n      BEGIN\n        UPDATE \"Session\"\n        SET \"isActive\" = false\n        WHERE \"userId\" = p_user_id\n        AND id != p_current_session_id\n        AND \"isActive\" = true;\n\n        GET DIAGNOSTICS v_updated = ROW_COUNT;\n        RETURN v_updated;\n      END;\n      $function$\n",
  "revoke_session": "CREATE OR REPLACE FUNCTION public.revoke_session(p_session_id text)\n RETURNS boolean\n LANGUAGE plpgsql\nAS $function$\n      DECLARE\n        v_updated INTEGER;\n      BEGIN\n        UPDATE \"Session\"\n        SET \"isActive\" = false\n        WHERE id = p_session_id;\n\n        GET DIAGNOSTICS v_updated = ROW_COUNT;\n        RETURN v_updated > 0;\n      END;\n      $function$\n",
  "update_last_activity": "CREATE OR REPLACE FUNCTION public.update_last_activity()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  UPDATE \"User\" SET \"lastActiveAt\" = NOW() WHERE \"id\" = NEW.\"userId\";\n  RETURN NEW;\nEND;\n$function$\n",
  "update_package_roi_stats": "CREATE OR REPLACE FUNCTION public.update_package_roi_stats()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  IF TG_OP = 'INSERT' AND NEW.\"status\" = 'COMPLETED' THEN\n    UPDATE \"Package\"\n    SET \n      \"totalRoiPaid\" = \"totalRoiPaid\" + NEW.\"amount\",\n      \"roiPaidCount\" = \"roiPaidCount\" + 1,\n      \"lastRoiDate\" = NEW.\"paymentDate\",\n      \"nextRoiDate\" = NEW.\"paymentDate\" + INTERVAL '1 month'\n    WHERE \"id\" = NEW.\"packageId\";\n  END IF;\n  \n  RETURN NEW;\nEND;\n$function$\n",
  "update_user_bot_purchase_status": "CREATE OR REPLACE FUNCTION public.update_user_bot_purchase_status()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  -- Only check for ACTIVE status (PENDING is not valid for BotStatus enum)\n  IF NEW.\"status\" = 'ACTIVE' THEN\n    UPDATE \"User\"\n    SET \"hasPurchasedBot\" = true\n    WHERE \"id\" = NEW.\"userId\"\n    AND \"hasPurchasedBot\" = false;\n  END IF;\n  RETURN NEW;\nEND;\n$function$\n",
  "validate_session": "CREATE OR REPLACE FUNCTION public.validate_session(p_token_hash text)\n RETURNS TABLE(\"sessionId\" text, \"userId\" text, \"ipAddress\" text, \"userAgent\" text, \"isValid\" boolean, \"createdAt\" timestamp without time zone, \"lastUsedAt\" timestamp without time zone, \"expiresAt\" timestamp without time zone)\n LANGUAGE plpgsql\nAS $function$\n      DECLARE\n        v_session RECORD;\n      BEGIN\n        SELECT\n          s.id,\n          s.\"userId\",\n          s.\"ipAddress\",\n          s.\"userAgent\",\n          s.\"createdAt\",\n          s.\"lastActivityAt\",\n          s.\"expiresAt\",\n          s.\"isActive\"\n        INTO v_session\n        FROM \"Session\" s\n        WHERE s.\"tokenHash\" = p_token_hash\n        AND s.\"isActive\" = true\n        AND s.\"expiresAt\" > NOW()\n        LIMIT 1;\n\n        IF NOT FOUND THEN\n          RETURN QUERY SELECT\n            NULL::TEXT, NULL::TEXT, NULL::TEXT, NULL::TEXT,\n            false, NULL::TIMESTAMP, NULL::TIMESTAMP, NULL::TIMESTAMP;\n          RETURN;\n        END IF;\n\n        UPDATE \"Session\"\n        SET \"lastActivityAt\" = NOW()\n        WHERE id = v_session.id;\n\n        RETURN QUERY SELECT\n          v_session.id,\n          v_session.\"userId\",\n          v_session.\"ipAddress\",\n          v_session.\"userAgent\",\n          true,\n          v_session.\"createdAt\",\n          v_session.\"lastActivityAt\",\n          v_session.\"expiresAt\";\n      END;\n      $function$\n"
}