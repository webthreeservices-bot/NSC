"use strict";exports.id=1053,exports.ids=[1053],exports.modules={61053:(a,b,c)=>{c.a(a,async(a,d)=>{try{c.d(b,{R0:()=>l,o3:()=>m,xh:()=>k});var e=c(42703),f=c.n(e),g=c(79566),h=c(68278),i=a([g,h]);[g,h]=i.then?(await i)():i;let n=!1,o=null,p=0;async function j(){if(n)return void console.log("Scan already in progress, skipping...");try{n=!0,console.log(`[Payment Scanner] Starting scan #${p+1}...`),(await Promise.allSettled([(0,g.WG)(),(0,g.Q$)(),(0,h.xm)()])).forEach((a,b)=>{let c=["scanAllNetworks","checkPendingConfirmations","expireOldPaymentRequests"][b];"fulfilled"===a.status?console.log(`[Payment Scanner] ${c} completed successfully`):console.error(`[Payment Scanner] ${c} failed:`,a.reason)}),o=new Date,p++,console.log(`[Payment Scanner] Scan #${p} completed at ${o.toISOString()}`)}catch(a){console.error("[Payment Scanner] Error during scan:",a)}finally{n=!1}}function k(){console.log("[Payment Scanner] Initializing payment scanner cron job...");let a=f().schedule("*/2 * * * *",async()=>{await j()});return a.start(),console.log("[Payment Scanner] Cron job started - scanning every 2 minutes"),setTimeout(async()=>{console.log("[Payment Scanner] Performing initial scan..."),await j()},1e4),a}function l(){return{isScanning:n,lastScanTime:o,scanCount:p,uptime:process.uptime()}}async function m(){return console.log("[Payment Scanner] Manual scan triggered"),await j(),l()}d()}catch(a){d(a)}})},79566:(a,b,c)=>{c.a(a,async(a,d)=>{try{c.d(b,{Q$:()=>m,WG:()=>l});var e=c(8216),f=c(74771),g=a([e]);e=(g.then?(await g)():g)[0];let n="true"===process.env.WEB3_DISABLED||"true"===process.env.NEXT_PUBLIC_WEB3_DISABLED,o={BEP20:3,TRC20:19};async function h(){try{if(n)return void console.warn("WEB3_DISABLED: skip BEP20 blockchain scan");console.warn("BEP20 scanner is not implemented in this build");return}catch(b){console.error("Error scanning BEP20:",b);let a=await (0,e.Zy)('SELECT * FROM "BlockchainScanState" WHERE network = $1',["BEP20"]);throw a&&await (0,e.g7)(`UPDATE "BlockchainScanState"
         SET "isScanning" = $1, "errorCount" = $2, "lastError" = $3, "updatedAt" = $4
         WHERE network = $5`,[!1,(a.errorCount||0)+1,b instanceof Error?b.message:"Unknown error",new Date,"BEP20"]),b}}async function i(){try{if(n)return void console.warn("WEB3_DISABLED: skip TRC20 blockchain scan");console.warn("TRC20 scanner is not implemented in this build");return}catch(b){console.error("Error scanning TRC20:",b);let a=await (0,e.Zy)('SELECT * FROM "BlockchainScanState" WHERE network = $1',["TRC20"]);throw a&&await (0,e.g7)(`UPDATE "BlockchainScanState"
         SET "isScanning" = $1, "errorCount" = $2, "lastError" = $3, "updatedAt" = $4
         WHERE network = $5`,[!1,(a.errorCount||0)+1,b instanceof Error?b.message:"Unknown error",new Date,"TRC20"]),b}}async function j(a){try{let b=a.metadata||{},{sendPaymentConfirmedEmail:d}=await Promise.all([c.e(5924),c.e(2909)]).then(c.bind(c,92909));switch(await d(a.userId,a.id,a.txHash),a.purpose){case"PACKAGE_PURCHASE":b.packageId&&(await (0,e.g7)('UPDATE "Package" SET status = $1, "depositTxHash" = $2, "updatedAt" = $3 WHERE id = $4',["ACTIVE",a.txHash,new Date,b.packageId]),await (0,e.g7)(`INSERT INTO "Transaction" (id, "userId", type, amount, status, description, "txHash", network, "createdAt", "updatedAt")
             VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)`,[(0,f.A)(),a.userId,"PACKAGE_PURCHASE",a.amount,"COMPLETED","Package purchase confirmed",a.txHash,a.network,new Date,new Date]),await k(a.userId,b.packageId,a.amount),console.log(`Package ${b.packageId} activated`));break;case"BOT_ACTIVATION":b.botId&&(await (0,e.g7)('UPDATE "BotActivation" SET status = $1::"BotStatus", "paymentTxHash" = $2, "updatedAt" = $3 WHERE id = $4',["ACTIVE",a.txHash,new Date,b.botId]),await (0,e.g7)(`INSERT INTO "Transaction" (id, "userId", type, amount, status, description, "txHash", network, "createdAt", "updatedAt")
             VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)`,[(0,f.A)(),a.userId,"BOT_ACTIVATION",a.amount,"COMPLETED","Bot activation confirmed",a.txHash,a.network,new Date,new Date]),console.log(`Bot ${b.botId} activated`));break;case"MANUAL_DEPOSIT":await (0,e.g7)(`INSERT INTO "Transaction" (id, "userId", type, amount, status, description, "txHash", network, "createdAt", "updatedAt")
           VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)`,[(0,f.A)(),a.userId,"PACKAGE_PURCHASE",a.amount,"COMPLETED","Manual deposit confirmed",a.txHash,a.network,new Date,new Date])}}catch(a){throw console.error("Error processing payment completion:",a),a}}async function k(a,b,d){try{let f=await (0,e.Zy)('SELECT * FROM "User" WHERE id = $1',[a]);if(!f||!f.referredBy||!await (0,e.Zy)('SELECT * FROM "User" WHERE "referralCode" = $1',[f.referredBy]))return;let{calculateReferralEarnings:g}=await c.e(1833).then(c.bind(c,31833));await g(b,a,Number(d));try{let{distributeReferralEarningsOnChain:a}=await c.e(1833).then(c.bind(c,31833)),d=await a(b,paymentRequest.network);console.log(`[Referral] Distributed referral earnings - success: ${d.success}, failed: ${d.failed}`)}catch(a){console.error("[Referral] Error distributing referral earnings on-chain:",a)}console.log(`✅ Referral bonuses processed for package ${b}`)}catch(a){console.error("❌ Error triggering referral bonuses:",a)}}async function l(){console.log("Starting blockchain scan for all networks...");try{await Promise.allSettled([h(),i()]),console.log("Blockchain scan completed for all networks")}catch(a){throw console.error("Error scanning blockchains:",a),a}}async function m(){try{if(n)return void console.warn("WEB3_DISABLED: skip confirmation checks");let a=await (0,e.P)('SELECT * FROM "PaymentConfirmation" WHERE "isConfirmed" = $1',[!1]);for(let b of(console.log(`Checking ${a.length} pending confirmations`),a))try{let a=0,c=(a=0)>=o[b.network];if(await (0,e.g7)(`UPDATE "PaymentConfirmation"
           SET confirmations = $1, "isConfirmed" = $2, "lastCheckedAt" = $3, "updatedAt" = $4
           WHERE id = $5`,[a,c,new Date,new Date,b.id]),c){let c=await (0,e.Zy)('SELECT * FROM "PaymentRequest" WHERE id = $1',[b.paymentRequestId]);c&&"COMPLETED"!==c.status&&(await (0,e.g7)(`UPDATE "PaymentRequest"
               SET status = $1, confirmations = $2, "completedAt" = $3, "updatedAt" = $4
               WHERE id = $5`,["COMPLETED",a,new Date,new Date,c.id]),await j(c))}}catch(a){console.error(`Error checking confirmation for payment ${b.paymentRequestId}:`,a)}}catch(a){throw console.error("Error checking pending confirmations:",a),a}}d()}catch(a){d(a)}})}};