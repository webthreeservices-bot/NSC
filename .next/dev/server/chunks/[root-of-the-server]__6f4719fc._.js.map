{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 82, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/LENOVO/Desktop/nsc-test/vercel-download/src/lib/db-connection.ts"],"sourcesContent":["import { Pool } from 'pg'\n\n// Load environment variables only in development\nif (process.env.NODE_ENV !== 'production') {\n  try {\n    const dotenv = require('dotenv')\n    dotenv.config()\n  } catch (error) {\n    // dotenv is optional, might not be installed in production\n    console.log('dotenv not available, using system environment variables')\n  }\n}\n\n// Parse DATABASE_URL to handle Neon and other providers\nconst getDatabaseConfig = () => {\n  const connectionString = process.env.DATABASE_URL\n\n  if (!connectionString) {\n    console.error('‚ùå DATABASE_URL is not defined in environment variables')\n    console.error('Please ensure your .env file contains a valid DATABASE_URL')\n    throw new Error('DATABASE_URL is not defined in environment variables')\n  }\n\n  // For Neon and other cloud providers, always use SSL\n  const isCloudProvider = connectionString.includes('neon.tech') ||\n                         connectionString.includes('supabase.co') ||\n                         connectionString.includes('amazonaws.com') ||\n                         connectionString.includes('azure.com')\n\n  // For Neon, we need specific SSL settings\n  const isNeon = connectionString.includes('neon.tech')\n\n  // SSL configuration based on provider\n  const sslConfig = isNeon\n    ? {\n        rejectUnauthorized: false,\n        ca: null,\n        checkServerIdentity: () => undefined\n      }\n    : { rejectUnauthorized: process.env.DB_SSL_REJECT_UNAUTHORIZED !== 'false' }\n\n  // Optimized configuration for NeonDB\n  return {\n    connectionString,\n    ssl: isCloudProvider ? sslConfig : false,\n    max: 20, // ‚úÖ Increased pool size for better concurrent request handling\n    min: 5, // ‚úÖ Keep more connections warm to avoid timeouts\n    idleTimeoutMillis: 60000, // 60 seconds idle timeout (increased)\n    connectionTimeoutMillis: 20000, // 20 seconds connection timeout (increased)\n    allowExitOnIdle: false, // ‚úÖ Don't exit on idle to maintain connections\n    statement_timeout: 60000, // 60 seconds (increased)\n    query_timeout: 60000, // 60 seconds (increased)\n    keepAlive: true, // ‚úÖ Keep connections alive\n    keepAliveInitialDelayMillis: 5000, // 5 seconds\n    // Additional Neon-specific optimizations\n    application_name: 'nsc-bot-platform',\n    idle_in_transaction_session_timeout: 120000 // 2 minutes (increased)\n  }\n}\n\n// Single pool instance - NO resets, NO lazy initialization\nlet pool: Pool | null = null;\nlet isInitializing = false;\n\nconst getPool = () => {\n  // Create pool only once\n  if (!pool && !isInitializing) {\n    isInitializing = true;\n    try {\n      pool = new Pool(getDatabaseConfig());\n\n      // Add error handling for the pool - DO NOT reset pool or exit process\n      pool.on('error', (err) => {\n        console.error('‚ùå Unexpected error on idle client:', err);\n        console.error('Connection will be removed from pool and recreated automatically');\n        // ‚úÖ Let pg handle reconnection automatically - don't reset pool\n      });\n\n      // Only log connection events when VERBOSE_DB_LOGS is set (not during build)\n      const isBuilding = process.env.NEXT_PHASE === 'phase-production-build';\n      const shouldLog = !isBuilding && (process.env.NODE_ENV !== 'production' || process.env.VERBOSE_DB_LOGS === 'true');\n\n      if (shouldLog) {\n        pool.on('connect', (client) => {\n          console.log('‚úÖ New client connected to NeonDB');\n        });\n\n        pool.on('remove', (client) => {\n          console.log('üîå Client removed from pool');\n        });\n      }\n\n      if (!isBuilding) {\n        console.log('üöÄ Database pool initialized for NeonDB');\n      }\n    } catch (error) {\n      isInitializing = false;\n      console.error('‚ùå Failed to initialize database pool:', error);\n      throw error;\n    } finally {\n      isInitializing = false;\n    }\n  }\n\n  // Wait for initialization if it's in progress\n  while (isInitializing && !pool) {\n    // Busy wait - this is acceptable because initialization is fast\n  }\n\n  return pool!;\n};\n\n// Test database connection\nexport async function testConnection() {\n  let client\n  try {\n    const poolInstance = getPool();\n    client = await poolInstance.connect()\n    const result = await client.query('SELECT NOW()')\n    console.log('Database connection successful:', result.rows[0])\n    return true\n  } catch (err) {\n    console.error('Database connection error:', err)\n    return false\n  } finally {\n    if (client) client.release()\n  }\n}\n\n// Warmup database connection - call this on server start (NOT during build)\nexport async function warmupConnection() {\n  // Skip warmup during build phase\n  const isBuilding = process.env.NEXT_PHASE === 'phase-production-build';\n  if (isBuilding) {\n    return;\n  }\n\n  console.log('üî• Warming up database connection...')\n\n  try {\n    // Try to establish a connection and run a simple query\n    const success = await testConnection()\n\n    if (success) {\n      console.log('‚úÖ Database connection warmed up successfully')\n\n      // Pre-establish a connection in the pool\n      const poolInstance = getPool();\n      const client = await poolInstance.connect()\n\n      // Keep the connection alive briefly then release\n      setTimeout(() => {\n        client.release()\n        console.log('üîå Warmup connection released')\n      }, 1000)\n\n    } else {\n      console.warn('‚ö†Ô∏è Database warmup failed, but continuing...')\n    }\n  } catch (error: any) {\n    console.warn('‚ö†Ô∏è Database warmup error:', error?.message || 'Unknown error')\n  }\n}\n\n// Export a proxy that lazily initializes the pool\nconst poolProxy = new Proxy({} as Pool, {\n  get(target, prop) {\n    const poolInstance = getPool();\n    return poolInstance[prop as keyof Pool];\n  }\n});\n\n/**\n * Get a database client with timeout protection\n * @param timeoutMs Timeout in milliseconds (default: 20000ms)\n * @returns Database client\n * @throws Error if connection times out or fails\n */\nexport async function getClientWithTimeout(timeoutMs: number = 20000) {\n  const poolInstance = getPool();\n  \n  return Promise.race([\n    poolInstance.connect(),\n    new Promise<never>((_, reject) => \n      setTimeout(() => reject(new Error(`Database connection timeout after ${timeoutMs}ms`)), timeoutMs)\n    )\n  ]);\n}\n\n/**\n * Execute a query with timeout protection\n * @param query SQL query string\n * @param params Query parameters\n * @param timeoutMs Query timeout in milliseconds (default: 20000ms)\n * @returns Query result\n */\nexport async function queryWithTimeout(query: string, params: any[] = [], timeoutMs: number = 20000) {\n  let client;\n  try {\n    client = await getClientWithTimeout(timeoutMs);\n    \n    const queryPromise = client.query(query, params);\n    const timeoutPromise = new Promise<never>((_, reject) => \n      setTimeout(() => reject(new Error(`Query timeout after ${timeoutMs}ms`)), timeoutMs)\n    );\n    \n    return await Promise.race([queryPromise, timeoutPromise]);\n  } finally {\n    if (client) {\n      client.release();\n    }\n  }\n}\n\n// Export the pool for use in other modules\nexport default poolProxy\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 271, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/LENOVO/Desktop/nsc-test/vercel-download/src/lib/db.ts"],"sourcesContent":["/**\n * Pure PostgreSQL Database Layer\n * NO PRISMA. NO ORM. Just direct SQL via pg driver.\n * Neon DB (Serverless PostgreSQL)\n */\n\nimport pool from './db-connection'\n\n// Helper to convert snake_case to camelCase\nfunction toCamelCase(obj: any): any {\n  if (Array.isArray(obj)) {\n    return obj.map(toCamelCase)\n  }\n  if (obj !== null && typeof obj === 'object') {\n    return Object.keys(obj).reduce((acc, key) => {\n      const camelKey = key.replace(/_([a-z])/g, (g) => g[1].toUpperCase())\n      acc[camelKey] = toCamelCase(obj[key])\n      return acc\n    }, {} as any)\n  }\n  return obj\n}\n\n// Helper to convert camelCase to snake_case\nfunction toSnakeCase(obj: any): any {\n  if (obj instanceof Date) return obj.toISOString()\n  if (Array.isArray(obj)) return obj.map(toSnakeCase)\n  if (obj !== null && typeof obj === 'object') {\n    const result: any = {}\n    for (const key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        result[key] = toSnakeCase(obj[key])\n      }\n    }\n    return result\n  }\n  return obj\n}\n\n/**\n * Execute any PostgreSQL query and return rows\n * @example\n * const users = await query<User>('SELECT * FROM \"User\" WHERE \"isActive\" = $1', [true])\n */\nexport async function query<T = any>(sql: string, params: any[] = []): Promise<T[]> {\n  // Validate that sql is actually a string\n  if (typeof sql !== 'string' || sql.trim().length === 0) {\n    const error = new Error('A query must have either text or a name. Supplying neither is unsupported.')\n    console.error('PostgreSQL Error:', {\n      message: error.message,\n      sql: sql,\n      code: undefined,\n    })\n    throw error\n  }\n\n  try {\n    const result = await pool.query(sql, params)\n    return result.rows as T[]\n  } catch (error: any) {\n    console.error('PostgreSQL Error:', {\n      message: error.message,\n      sql: typeof sql === 'string' ? sql.substring(0, 200) : sql,\n      code: error.code,\n    })\n    throw error\n  }\n}\n\n/**\n * Get a single row from query (or null)\n * @example\n * const user = await queryOne<User>('SELECT * FROM \"User\" WHERE \"id\" = $1', [userId])\n */\nexport async function queryOne<T = any>(sql: string, params: any[] = []): Promise<T | null> {\n  const rows = await query<T>(sql, params)\n  return rows.length > 0 ? rows[0] : null\n}\n\n/**\n * Get a single scalar value (for COUNT, SUM, MAX, AVG, etc.)\n * @example\n * const count = await queryScalar<number>('SELECT COUNT(*) as count FROM \"User\"')\n */\nexport async function queryScalar<T = any>(sql: string, params: any[] = []): Promise<T | null> {\n  const rows = await query<any>(sql, params)\n  if (rows.length === 0) return null\n  const firstValue = Object.values(rows[0])[0]\n  return firstValue as T\n}\n\n/**\n * Execute INSERT/UPDATE/DELETE query\n * Returns number of affected rows\n * @example\n * const count = await execute('UPDATE \"User\" SET \"isActive\" = $1 WHERE \"id\" = $2', [true, userId])\n */\nexport async function execute(sql: string, params: any[] = []): Promise<number> {\n  // Validate that sql is actually a string\n  if (typeof sql !== 'string' || sql.trim().length === 0) {\n    const error = new Error('A query must have either text or a name. Supplying neither is unsupported.')\n    console.error('PostgreSQL Error:', {\n      message: error.message,\n      sql: sql,\n      code: undefined,\n    })\n    throw error\n  }\n\n  try {\n    const result = await pool.query(sql, params)\n    return result.rowCount || 0\n  } catch (error: any) {\n    console.error('PostgreSQL Error:', {\n      message: error.message,\n      sql: typeof sql === 'string' ? sql.substring(0, 200) : sql,\n      code: error.code,\n    })\n    throw error\n  }\n}\n\n/**\n * Run multiple queries atomically in a transaction\n * Automatically COMMIT on success or ROLLBACK on error\n * @example\n * await transaction(async (client) => {\n *   await client.query('INSERT INTO \"User\" VALUES (...)')\n *   await client.query('UPDATE \"Package\" SET ...')\n * })\n */\nexport async function transaction<T>(\n  callback: (client: any) => Promise<T>\n): Promise<T> {\n  const client = await pool.connect()\n  try {\n    await client.query('BEGIN')\n    const result = await callback(client)\n    await client.query('COMMIT')\n    return result\n  } catch (error) {\n    await client.query('ROLLBACK')\n    throw error\n  } finally {\n    client.release()\n  }\n}\n\n/**\n * Disconnect from database (graceful shutdown)\n */\nexport async function disconnect(): Promise<void> {\n  await pool.end()\n}\n\n// Re-export pool for advanced use cases\nexport { pool }\n\n// Export helpers for use in refactored code\nexport { toCamelCase, toSnakeCase }\n\n/**\n * SQL translator - Converts SQL-style calls to pure queries\n * Translates ALL SQL calls to direct database queries underneath\n * This allows 60+ existing files to work while transitioning to pure SQL\n */\nexport const prisma: any = new Proxy({}, {\n  get: (target, table: string | symbol) => {\n    if (typeof table !== 'string') return undefined\n    \n    return {\n      async findUnique({ where, select }: any) {\n        const [key, value] = Object.entries(where)[0] as [string, any]\n        const fields = select ? Object.keys(select).map(k => `\"${k}\"`).join(', ') : '*'\n        const row = await queryOne(\n          `SELECT ${fields} FROM \"${table}\" WHERE \"${key}\" = $1 LIMIT 1`,\n          [value]\n        )\n        return row ? toCamelCase(row) : null\n      },\n      \n      async findMany({ where, select, orderBy, take, skip }: any = {}) {\n        const params: any[] = []\n        const fields = select ? Object.keys(select).map(k => `\"${k}\"`).join(', ') : '*'\n        let sql = `SELECT ${fields} FROM \"${table}\"`\n\n        if (where) {\n          const conditions: string[] = []\n          for (const [key, value] of Object.entries(where)) {\n            if (value === null) {\n              conditions.push(`\"${key}\" IS NULL`)\n            } else if (typeof value === 'object' && value !== null) {\n              // Handle various operators\n              if ('in' in value) {\n                const placeholders = (value as any).in.map((_: any, i: number) => `$${params.length + i + 1}`).join(', ')\n                params.push(...(value as any).in)\n                conditions.push(`\"${key}\" IN (${placeholders})`)\n              } else if ('notIn' in value) {\n                const placeholders = (value as any).notIn.map((_: any, i: number) => `$${params.length + i + 1}`).join(', ')\n                params.push(...(value as any).notIn)\n                conditions.push(`\"${key}\" NOT IN (${placeholders})`)\n              } else if ('lt' in value) {\n                params.push((value as any).lt)\n                conditions.push(`\"${key}\" < $${params.length}`)\n              } else if ('lte' in value) {\n                params.push((value as any).lte)\n                conditions.push(`\"${key}\" <= $${params.length}`)\n              } else if ('gt' in value) {\n                params.push((value as any).gt)\n                conditions.push(`\"${key}\" > $${params.length}`)\n              } else if ('gte' in value) {\n                params.push((value as any).gte)\n                conditions.push(`\"${key}\" >= $${params.length}`)\n              } else if ('contains' in value) {\n                params.push(`%${(value as any).contains}%`)\n                conditions.push(`\"${key}\" ILIKE $${params.length}`)\n              } else if ('startsWith' in value) {\n                params.push(`${(value as any).startsWith}%`)\n                conditions.push(`\"${key}\" ILIKE $${params.length}`)\n              } else if ('endsWith' in value) {\n                params.push(`%${(value as any).endsWith}`)\n                conditions.push(`\"${key}\" ILIKE $${params.length}`)\n              } else if ('not' in value) {\n                params.push((value as any).not)\n                conditions.push(`\"${key}\" != $${params.length}`)\n              } else {\n                // Fallback: treat as direct value\n                params.push(value)\n                conditions.push(`\"${key}\" = $${params.length}`)\n              }\n            } else {\n              params.push(value)\n              conditions.push(`\"${key}\" = $${params.length}`)\n            }\n          }\n          if (conditions.length) sql += ` WHERE ${conditions.join(' AND ')}`\n        }\n\n        if (orderBy) {\n          const orderClauses: string[] = []\n          for (const [field, dir] of Object.entries(orderBy)) {\n            orderClauses.push(`\"${field}\" ${(dir as string).toUpperCase()}`)\n          }\n          sql += ` ORDER BY ${orderClauses.join(', ')}`\n        }\n\n        if (take) sql += ` LIMIT ${take}`\n        if (skip) sql += ` OFFSET ${skip}`\n\n        const rows = await query(sql, params)\n        return rows.map(r => toCamelCase(r))\n      },\n      \n      async findFirst({ where, select, orderBy }: any) {\n        // Use findMany with take: 1 to reuse the logic\n        const result = await this.findMany({ where, select, orderBy, take: 1 })\n        return result.length > 0 ? result[0] : null\n      },\n      \n      async count({ where }: any = {}) {\n        const params: any[] = []\n        let sql = `SELECT COUNT(*) as cnt FROM \"${table}\"`\n\n        if (where) {\n          const conditions: string[] = []\n          for (const [key, value] of Object.entries(where)) {\n            if (value === null) {\n              conditions.push(`\"${key}\" IS NULL`)\n            } else if (typeof value === 'object' && value !== null) {\n              // Handle operators for count\n              if ('in' in value) {\n                const placeholders = (value as any).in.map((_: any, i: number) => `$${params.length + i + 1}`).join(', ')\n                params.push(...(value as any).in)\n                conditions.push(`\"${key}\" IN (${placeholders})`)\n              } else if ('not' in value) {\n                params.push((value as any).not)\n                conditions.push(`\"${key}\" != $${params.length}`)\n              } else {\n                params.push(value)\n                conditions.push(`\"${key}\" = $${params.length}`)\n              }\n            } else {\n              params.push(value)\n              conditions.push(`\"${key}\" = $${params.length}`)\n            }\n          }\n          if (conditions.length) sql += ` WHERE ${conditions.join(' AND ')}`\n        }\n\n        const row = await queryOne<any>(sql, params)\n        return row ? parseInt(row.cnt) : 0\n      },\n      \n      async create({ data, select }: any) {\n        const keys = Object.keys(data)\n        const values = Object.values(data)\n        const placeholders = keys.map((_, i) => `$${i + 1}`).join(', ')\n        const keyString = keys.map(k => `\"${k}\"`).join(', ')\n        const fields = select ? Object.keys(select).map(k => `\"${k}\"`).join(', ') : '*'\n        \n        const row = await queryOne(\n          `INSERT INTO \"${table}\" (${keyString}) VALUES (${placeholders}) RETURNING ${fields}`,\n          values\n        )\n        return row ? toCamelCase(row) : null\n      },\n      \n      async update({ where, data, select }: any) {\n        const params: any[] = []\n        const sets: string[] = []\n\n        // Build SET clause\n        for (const [key, value] of Object.entries(data)) {\n          if (value !== undefined) {\n            if (typeof value === 'object' && value !== null) {\n              // Handle increment/decrement operations\n              if ('increment' in value) {\n                params.push((value as any).increment)\n                sets.push(`\"${key}\" = COALESCE(\"${key}\", 0) + $${params.length}`)\n              } else if ('decrement' in value) {\n                params.push((value as any).decrement)\n                sets.push(`\"${key}\" = COALESCE(\"${key}\", 0) - $${params.length}`)\n              } else {\n                // Regular object value\n                params.push(JSON.stringify(value))\n                sets.push(`\"${key}\" = $${params.length}`)\n              }\n            } else {\n              params.push(value)\n              sets.push(`\"${key}\" = $${params.length}`)\n            }\n          }\n        }\n\n        // Build WHERE clause\n        const whereConditions: string[] = []\n        for (const [key, value] of Object.entries(where)) {\n          params.push(value)\n          whereConditions.push(`\"${key}\" = $${params.length}`)\n        }\n\n        const fields = select ? Object.keys(select).map(k => `\"${k}\"`).join(', ') : '*'\n        const row = await queryOne(\n          `UPDATE \"${table}\" SET ${sets.join(', ')} WHERE ${whereConditions.join(' AND ')} RETURNING ${fields}`,\n          params\n        )\n        return row ? toCamelCase(row) : null\n      },\n      \n      async delete({ where }: any) {\n        const [key, value] = Object.entries(where)[0] as [string, any]\n        await execute(`DELETE FROM \"${table}\" WHERE \"${key}\" = $1`, [value])\n        return {}\n      },\n      \n      async deleteMany({ where }: any = {}) {\n        const params: any[] = []\n        let sql = `DELETE FROM \"${table}\"`\n        \n        if (where) {\n          const conditions: string[] = []\n          for (const [key, value] of Object.entries(where)) {\n            params.push(value)\n            conditions.push(`\"${key}\" = $${params.length}`)\n          }\n          if (conditions.length) sql += ` WHERE ${conditions.join(' AND ')}`\n        }\n        \n        const count = await execute(sql, params)\n        return { count }\n      },\n      \n      async aggregate({ where, _sum, _count }: any) {\n        const params: any[] = []\n        const aggs: string[] = []\n        \n        if (_sum) {\n          Object.keys(_sum).forEach(field => {\n            aggs.push(`SUM(\"${field}\") as sum_${field}`)\n          })\n        }\n        if (_count) aggs.push('COUNT(*) as cnt')\n        \n        let sql = `SELECT ${aggs.join(', ')} FROM \"${table}\"`\n        \n        if (where) {\n          const conditions: string[] = []\n          for (const [key, value] of Object.entries(where)) {\n            params.push(value)\n            conditions.push(`\"${key}\" = $${params.length}`)\n          }\n          if (conditions.length) sql += ` WHERE ${conditions.join(' AND ')}`\n        }\n        \n        const row = await queryOne<any>(sql, params)\n        const result: any = {}\n        if (_sum && row) {\n          result._sum = {}\n          Object.keys(_sum).forEach(field => {\n            result._sum[field] = row[`sum_${field}`] ? parseFloat(row[`sum_${field}`]) : 0\n          })\n        }\n        if (_count && row) result._count = row.cnt ? parseInt(row.cnt) : 0\n        return result\n      },\n      \n      async groupBy({ by, _count, _sum, where }: any) {\n        const params: any[] = []\n        const fields = (Array.isArray(by) ? by : [by]).map(f => `\"${f}\"`)\n        const aggs: string[] = []\n        \n        if (_count) aggs.push('COUNT(*) as cnt')\n        if (_sum) {\n          Object.keys(_sum).forEach(field => {\n            aggs.push(`SUM(\"${field}\") as sum_${field}`)\n          })\n        }\n        \n        let sql = `SELECT ${fields.join(', ')}${aggs.length ? ', ' + aggs.join(', ') : ''} FROM \"${table}\"`\n        \n        if (where) {\n          const conditions: string[] = []\n          for (const [key, value] of Object.entries(where)) {\n            params.push(value)\n            conditions.push(`\"${key}\" = $${params.length}`)\n          }\n          if (conditions.length) sql += ` WHERE ${conditions.join(' AND ')}`\n        }\n        \n        sql += ` GROUP BY ${fields.join(', ')}`\n        const rows = await query(sql, params)\n        \n        return rows.map((row: any) => {\n          const transformed: any = {}\n          (Array.isArray(by) ? by : [by]).forEach(field => {\n            transformed[field] = row[field]\n          })\n          if (_count) transformed._count = row.cnt ? parseInt(row.cnt) : 0\n          if (_sum) {\n            transformed._sum = {}\n            Object.keys(_sum).forEach(field => {\n              transformed._sum[field] = row[`sum_${field}`] ? parseFloat(row[`sum_${field}`]) : 0\n            })\n          }\n          return transformed\n        })\n      },\n      \n      async upsert({ where, create, update }: any) {\n        const existing = await this.findUnique({ where })\n        return existing ? this.update({ where, data: update }) : this.create({ data: create })\n      }\n    }\n  }\n})\n\n// Support for await transaction\nexport const $transaction = transaction\n\nexport default {\n  query,\n  queryOne,\n  queryScalar,\n  execute,\n  transaction,\n  disconnect,\n  pool,\n  toCamelCase,\n  toSnakeCase,\n  prisma,\n  $transaction,\n}"],"names":[],"mappings":"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"}},
    {"offset": {"line": 723, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/LENOVO/Desktop/nsc-test/vercel-download/src/utils/server-helpers.ts"],"sourcesContent":["/**\n * Server-only helper functions\n * These use Node.js modules and should only be imported in API routes\n */\n\nimport bcrypt from 'bcrypt'\nimport jwt, { SignOptions, Secret } from 'jsonwebtoken'\nimport crypto from 'crypto'\nimport { JwtPayload } from '@/types/api'\nimport { queryOne, execute, transaction } from '@/lib/db'\n\n/**\n * Hash password\n */\nexport async function hashPassword(password: string): Promise<string> {\n  return await bcrypt.hash(password, 10)\n}\n\n/**\n * Compare password\n */\nexport async function comparePassword(\n  password: string,\n  hash: string\n): Promise<boolean> {\n  return await bcrypt.compare(password, hash)\n}\n\n/**\n * Generate JWT token\n */\nexport function generateToken(payload: Partial<JwtPayload>, expiresIn: string = '24h'): string {\n  if (!process.env.JWT_SECRET) {\n    throw new Error('JWT_SECRET is not defined in environment variables')\n  }\n  // Cast secret to Secret to satisfy TypeScript overloads\n  const secret: Secret = process.env.JWT_SECRET as Secret || 'fallback-secret'\n  // jwt.sign typings are picky about the secret type and options; cast to any\n  return jwt.sign(payload as any, secret as any, { expiresIn } as any);\n}\n\n/**\n * Generate refresh token\n */\nexport function generateRefreshToken(payload: Partial<JwtPayload>): string {\n  if (!process.env.JWT_REFRESH_SECRET) {\n    throw new Error('JWT_REFRESH_SECRET is not defined in environment variables')\n  }\n  const tokenPayload = {\n    ...payload,\n    type: 'refresh'\n  }\n  const refreshSecret: Secret = process.env.JWT_REFRESH_SECRET as Secret || 'fallback-refresh-secret'\n  return jwt.sign(tokenPayload as any, refreshSecret, { expiresIn: '7d' });\n}\n\n/**\n * Verify JWT token\n */\nexport function verifyToken(token: string): JwtPayload | null {\n  try {\n    if (!process.env.JWT_SECRET) {\n      throw new Error('JWT_SECRET is not defined in environment variables')\n    }\n    const decoded = jwt.verify(token, process.env.JWT_SECRET);\n    if (typeof decoded === 'string') {\n      return null;\n    }\n    return decoded as JwtPayload;\n  } catch (error) {\n    return null\n  }\n}\n\n/**\n * Verify refresh token\n */\nexport function verifyRefreshToken(token: string): JwtPayload | null {\n  try {\n    if (!process.env.JWT_REFRESH_SECRET) {\n      throw new Error('JWT_REFRESH_SECRET is not defined in environment variables')\n    }\n    const decoded = jwt.verify(token, process.env.JWT_REFRESH_SECRET);\n    if (typeof decoded === 'string') {\n      return null;\n    }\n    return decoded as JwtPayload;\n  } catch (error) {\n    return null\n  }\n}\n\n/**\n * Generate random token\n */\nexport function generateRandomToken(): string {\n  return crypto.randomBytes(32).toString('hex')\n}\n\n/**\n * Generate unique referral code (DEPRECATED - use getNextReferralCode instead)\n * Kept for backward compatibility\n */\nexport function generateReferralCode(username: string): string {\n  const random = crypto.randomBytes(3).toString('hex').toUpperCase()\n  const userPrefix = username.substring(0, 3).toUpperCase()\n  return `${userPrefix}${random}`\n}\n\n/**\n * Get next sequential referral code (NSCREF1001, NSCREF1002, etc.)\n * This is the code users share with others\n * Uses a transaction to prevent race conditions\n */\nexport async function getNextReferralCode(): Promise<string> {\n  // Use a transaction to ensure atomicity and prevent race conditions\n  const result = await transaction(async (client: any) => {\n    // First, try to find the existing counter\n    let counter = await queryOne<any>(\n      `SELECT * FROM \"ReferralCounter\" WHERE \"counterType\" = 'NSCREF'`,\n      []\n    );\n\n    // If counter doesn't exist, create it with initial value\n    if (!counter) {\n      counter = await queryOne<any>(\n        `INSERT INTO \"ReferralCounter\" (\"counterType\", \"currentValue\") \n         VALUES ('NSCREF', 1001) RETURNING *`,\n        []\n      );\n    } else {\n      // Increment the counter\n      counter = await queryOne<any>(\n        `UPDATE \"ReferralCounter\" SET \"currentValue\" = \"currentValue\" + 1 \n         WHERE \"counterType\" = 'NSCREF' RETURNING *`,\n        []\n      );\n    }\n\n    return counter;\n  });\n  \n  // The result is the counter object\n  const counter = result;\n  \n  // Double-check that the code is unique\n  const codeToUse = `NSCREF${counter.currentValue}`;\n  const existingUser = await queryOne<any>(\n    `SELECT * FROM \"User\" WHERE \"referralCode\" = $1`,\n    [codeToUse]\n  );\n  \n  // In the extremely unlikely case of a collision, add a random suffix\n  if (existingUser) {\n    const randomSuffix = Math.floor(Math.random() * 1000).toString().padStart(3, '0');\n    return `NSCREF${counter.currentValue}_${randomSuffix}`;\n  }\n  \n  return codeToUse;\n}\n\n// NEWNCS function has been completely removed as it's no longer needed\n// All users must now register with a valid referral code\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 860, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/LENOVO/Desktop/nsc-test/vercel-download/src/lib/neon-serverless.ts"],"sourcesContent":["import { neon } from '@neondatabase/serverless'\r\n\r\n/**\r\n * Neon Serverless Database Connection\r\n * Optimized for Neon's serverless environment\r\n */\r\n\r\nlet sql: ReturnType<typeof neon> | null = null\r\n\r\nexport function getNeonSQL() {\r\n  if (!sql) {\r\n    const databaseUrl = process.env.DATABASE_URL\r\n    if (!databaseUrl) {\r\n      throw new Error('DATABASE_URL is not defined in environment variables')\r\n    }\r\n    \r\n    console.log('üöÄ Initializing Neon Serverless SQL connection')\r\n    sql = neon(databaseUrl)\r\n  }\r\n  return sql\r\n}\r\n\r\n/**\r\n * Execute a query with Neon Serverless Driver\r\n * This bypasses traditional connection pooling issues\r\n * Uses tagged template literals as required by Neon\r\n */\r\nexport async function neonQuery<T = any>(\r\n  query: string, \r\n  params: any[] = []\r\n): Promise<T[]> {\r\n  const sql = getNeonSQL()\r\n  \r\n  try {\r\n    console.log(`üîç Executing Neon query: ${query.substring(0, 100)}...`)\r\n    \r\n    // For Neon serverless, we need to use sql.query() for parameterized queries\r\n    const result = await sql.query(query, params)\r\n    \r\n    const resultArray = Array.isArray(result) ? result : [result]\r\n    console.log(`‚úÖ Neon query completed, returned ${resultArray.length} rows`)\r\n    return resultArray as T[]\r\n    \r\n  } catch (error) {\r\n    console.error('‚ùå Neon query failed:', error.message)\r\n    console.error('Query:', query)\r\n    console.error('Params:', params)\r\n    throw error\r\n  }\r\n}\r\n\r\n/**\r\n * Execute a prepared statement with Neon Serverless Driver\r\n * For queries that need parameter binding\r\n */\r\nexport async function neonQueryPrepared<T = any>(\r\n  queryTemplate: (sql: ReturnType<typeof neon>) => Promise<T[]>\r\n): Promise<T[]> {\r\n  const sql = getNeonSQL()\r\n  \r\n  try {\r\n    console.log(`üîç Executing Neon prepared query...`)\r\n    \r\n    const result = await queryTemplate(sql)\r\n    \r\n    console.log(`‚úÖ Neon prepared query completed, returned ${result.length} rows`)\r\n    return result\r\n    \r\n  } catch (error) {\r\n    console.error('‚ùå Neon prepared query failed:', error.message)\r\n    throw error\r\n  }\r\n}\r\n\r\nexport default {\r\n  getNeonSQL,\r\n  neonQuery,\r\n  neonQueryPrepared\r\n}"],"names":[],"mappings":";;;;;;;;;;AAAA;;AAEA;;;CAGC,GAED,IAAI,MAAsC;AAEnC,SAAS;IACd,IAAI,CAAC,KAAK;QACR,MAAM,cAAc,QAAQ,GAAG,CAAC,YAAY;QAC5C,IAAI,CAAC,aAAa;YAChB,MAAM,IAAI,MAAM;QAClB;QAEA,QAAQ,GAAG,CAAC;QACZ,MAAM,IAAA,gKAAI,EAAC;IACb;IACA,OAAO;AACT;AAOO,eAAe,UACpB,KAAa,EACb,SAAgB,EAAE;IAElB,MAAM,MAAM;IAEZ,IAAI;QACF,QAAQ,GAAG,CAAC,CAAC,yBAAyB,EAAE,MAAM,SAAS,CAAC,GAAG,KAAK,GAAG,CAAC;QAEpE,4EAA4E;QAC5E,MAAM,SAAS,MAAM,IAAI,KAAK,CAAC,OAAO;QAEtC,MAAM,cAAc,MAAM,OAAO,CAAC,UAAU,SAAS;YAAC;SAAO;QAC7D,QAAQ,GAAG,CAAC,CAAC,iCAAiC,EAAE,YAAY,MAAM,CAAC,KAAK,CAAC;QACzE,OAAO;IAET,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,wBAAwB,MAAM,OAAO;QACnD,QAAQ,KAAK,CAAC,UAAU;QACxB,QAAQ,KAAK,CAAC,WAAW;QACzB,MAAM;IACR;AACF;AAMO,eAAe,kBACpB,aAA6D;IAE7D,MAAM,MAAM;IAEZ,IAAI;QACF,QAAQ,GAAG,CAAC,CAAC,mCAAmC,CAAC;QAEjD,MAAM,SAAS,MAAM,cAAc;QAEnC,QAAQ,GAAG,CAAC,CAAC,0CAA0C,EAAE,OAAO,MAAM,CAAC,KAAK,CAAC;QAC7E,OAAO;IAET,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,iCAAiC,MAAM,OAAO;QAC5D,MAAM;IACR;AACF;uCAEe;IACb;IACA;IACA;AACF"}},
    {"offset": {"line": 928, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/LENOVO/Desktop/nsc-test/vercel-download/src/services/sessionManagementService.ts"],"sourcesContent":["import { queryWithTimeout } from '../lib/db-connection';\r\n\r\ninterface SessionData {\r\n  sessionId: string;\r\n  userId: string;\r\n  ipAddress: string;\r\n  userAgent: string;\r\n  isActive: boolean;\r\n  createdAt: Date;\r\n  lastActiveAt: Date;\r\n  expiresAt: Date;\r\n}\r\n\r\ninterface SessionStats {\r\n  activeSessions: number;\r\n  uniqueUsers: number;\r\n  sessionsLast24h: number;\r\n}\r\n\r\nexport class SessionManagementService {\r\n  /**\r\n   * Create a new session for a user\r\n   */\r\n  static async createSession(\r\n    userId: string,\r\n    tokenHash: string,\r\n    refreshTokenHash: string,\r\n    ipAddress: string,\r\n    userAgent: string,\r\n    expiresAt: Date = new Date(Date.now() + 30 * 24 * 60 * 60 * 1000) // 30 days default\r\n  ): Promise<SessionData | null> {\r\n    try {\r\n      const result = await queryWithTimeout(\r\n        `SELECT create_session($1::TEXT, $2::TEXT, $3::TEXT, $4::TEXT, $5::TEXT, $6::TIMESTAMP) as session_id`,\r\n        [userId, tokenHash, refreshTokenHash, ipAddress, userAgent, expiresAt],\r\n        5000\r\n      );\r\n\r\n      if (result.rows && result.rows.length > 0) {\r\n        const sessionId = result.rows[0].session_id;\r\n        \r\n        // Return a basic session object\r\n        return {\r\n          sessionId: sessionId,\r\n          userId: userId,\r\n          ipAddress: ipAddress,\r\n          userAgent: userAgent,\r\n          isActive: true,\r\n          createdAt: new Date(),\r\n          lastActiveAt: new Date(),\r\n          expiresAt: expiresAt\r\n        };\r\n      }\r\n\r\n      return null;\r\n    } catch (error) {\r\n      console.error('Error creating session:', error);\r\n      \r\n      // For now, don't throw an error to allow login to complete\r\n      // This allows the system to work while we debug the session creation\r\n      console.warn('Session creation failed, but allowing login to continue');\r\n      return {\r\n        sessionId: 'fallback-session-' + Date.now(),\r\n        userId: userId,\r\n        ipAddress: ipAddress,\r\n        userAgent: userAgent,\r\n        isActive: true,\r\n        createdAt: new Date(),\r\n        lastActiveAt: new Date(),\r\n        expiresAt: expiresAt\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Validate and update session activity\r\n   */\r\n  static async validateSession(tokenHash: string): Promise<SessionData | null> {\r\n    try {\r\n      const result = await queryWithTimeout(\r\n        `SELECT * FROM validate_session($1::TEXT)`,\r\n        [tokenHash],\r\n        5000\r\n      );\r\n\r\n      if (result.rows && result.rows.length > 0) {\r\n        const session = result.rows[0];\r\n        \r\n        // Return null if session is not valid\r\n        if (!session.isValid) {\r\n          return null;\r\n        }\r\n\r\n        return {\r\n          sessionId: session.sessionId,\r\n          userId: session.userId,\r\n          ipAddress: session.ipAddress,\r\n          userAgent: session.userAgent,\r\n          isActive: session.isValid,\r\n          createdAt: new Date(session.createdAt),\r\n          lastActiveAt: new Date(session.lastUsedAt),\r\n          expiresAt: new Date(session.expiresAt)\r\n        };\r\n      }\r\n\r\n      return null;\r\n    } catch (error) {\r\n      console.error('Error validating session:', error);\r\n      return null; // Fail gracefully for validation\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Revoke a specific session\r\n   */\r\n  static async revokeSession(sessionId: string): Promise<boolean> {\r\n    try {\r\n      const result = await queryWithTimeout(\r\n        `SELECT revoke_session($1) as revoked`,\r\n        [sessionId],\r\n        5000\r\n      );\r\n\r\n      return result.rows?.[0]?.revoked === true;\r\n    } catch (error) {\r\n      console.error('Error revoking session:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Revoke all sessions for a user\r\n   */\r\n  static async revokeAllUserSessions(userId: string): Promise<number> {\r\n    try {\r\n      const result = await queryWithTimeout(\r\n        `SELECT revoke_all_user_sessions($1) as revoked_count`,\r\n        [userId],\r\n        5000\r\n      );\r\n\r\n      return result.rows?.[0]?.revoked_count || 0;\r\n    } catch (error) {\r\n      console.error('Error revoking all user sessions:', error);\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Revoke all other sessions except the current one\r\n   */\r\n  static async revokeOtherSessions(userId: string, currentSessionId: string): Promise<number> {\r\n    try {\r\n      const result = await queryWithTimeout(\r\n        `SELECT revoke_other_sessions($1, $2) as revoked_count`,\r\n        [userId, currentSessionId],\r\n        5000\r\n      );\r\n\r\n      return result.rows?.[0]?.revoked_count || 0;\r\n    } catch (error) {\r\n      console.error('Error revoking other sessions:', error);\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get all active sessions for a user\r\n   */\r\n  static async getUserSessions(userId: string): Promise<SessionData[]> {\r\n    try {\r\n      const result = await queryWithTimeout(\r\n        `SELECT * FROM get_user_sessions($1::TEXT)`,\r\n        [userId],\r\n        5000\r\n      );\r\n\r\n      if (result.rows && result.rows.length > 0) {\r\n        return result.rows.map(session => ({\r\n          sessionId: session.sessionId,\r\n          userId: userId,\r\n          ipAddress: session.ipAddress,\r\n          userAgent: session.userAgent,\r\n          isActive: session.isActive,\r\n          createdAt: new Date(session.createdAt),\r\n          lastActiveAt: new Date(session.lastUsedAt),\r\n          expiresAt: new Date(session.expiresAt)\r\n        }));\r\n      }\r\n\r\n      return [];\r\n    } catch (error) {\r\n      console.error('Error getting user sessions:', error);\r\n      return [];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clean up expired sessions\r\n   */\r\n  static async cleanupExpiredSessions(): Promise<number> {\r\n    try {\r\n      const result = await queryWithTimeout(\r\n        `SELECT cleanup_expired_sessions() as cleaned_count`,\r\n        [],\r\n        10000 // Longer timeout for cleanup operation\r\n      );\r\n\r\n      return result.rows?.[0]?.cleaned_count || 0;\r\n    } catch (error) {\r\n      console.error('Error cleaning up expired sessions:', error);\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get session statistics\r\n   */\r\n  static async getSessionStats(): Promise<SessionStats> {\r\n    try {\r\n      const result = await queryWithTimeout(\r\n        `SELECT * FROM get_session_stats()`,\r\n        [],\r\n        5000\r\n      );\r\n\r\n      if (result.rows && result.rows.length > 0) {\r\n        const stats = result.rows[0];\r\n        return {\r\n          activeSessions: stats.active_sessions || 0,\r\n          uniqueUsers: stats.unique_users || 0,\r\n          sessionsLast24h: stats.sessions_last_24h || 0\r\n        };\r\n      }\r\n\r\n      return {\r\n        activeSessions: 0,\r\n        uniqueUsers: 0,\r\n        sessionsLast24h: 0\r\n      };\r\n    } catch (error) {\r\n      console.error('Error getting session stats:', error);\r\n      return {\r\n        activeSessions: 0,\r\n        uniqueUsers: 0,\r\n        sessionsLast24h: 0\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Generate a secure session ID\r\n   */\r\n  static generateSessionId(): string {\r\n    const crypto = require('crypto');\r\n    return crypto.randomBytes(32).toString('hex');\r\n  }\r\n\r\n  /**\r\n   * Extract session ID from JWT token or cookie\r\n   */\r\n  static extractSessionId(token?: string): string | null {\r\n    if (!token) return null;\r\n\r\n    try {\r\n      // If it's a JWT token, decode to get session ID\r\n      const jwt = require('jsonwebtoken');\r\n      const decoded = jwt.decode(token) as any;\r\n      return decoded?.sessionId || null;\r\n    } catch (error) {\r\n      // If not JWT, treat as direct session ID\r\n      return token;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Middleware helper to validate session in requests\r\n   */\r\n  static async validateRequestSession(\r\n    authHeader?: string,\r\n    sessionCookie?: string\r\n  ): Promise<{ isValid: boolean; session?: SessionData; userId?: string }> {\r\n    try {\r\n      // Try to extract session ID from Authorization header or cookie\r\n      let sessionId: string | null = null;\r\n\r\n      if (authHeader?.startsWith('Bearer ')) {\r\n        sessionId = this.extractSessionId(authHeader.substring(7));\r\n      } else if (sessionCookie) {\r\n        sessionId = this.extractSessionId(sessionCookie);\r\n      }\r\n\r\n      if (!sessionId) {\r\n        return { isValid: false };\r\n      }\r\n\r\n      const session = await this.validateSession(sessionId);\r\n      \r\n      if (!session) {\r\n        return { isValid: false };\r\n      }\r\n\r\n      return {\r\n        isValid: true,\r\n        session,\r\n        userId: session.userId\r\n      };\r\n    } catch (error) {\r\n      console.error('Error validating request session:', error);\r\n      return { isValid: false };\r\n    }\r\n  }\r\n}\r\n\r\nexport default SessionManagementService;"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1183, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/LENOVO/Desktop/nsc-test/vercel-download/src/middleware/auth.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server'\nimport { verifyToken } from '@/utils/server-helpers'\nimport { neonQuery } from '@/lib/neon-serverless'\nimport { queryOne } from '@/lib/db'\nimport { AuthUser, JwtPayload } from '@/types/api'\nimport SessionManagementService from '@/services/sessionManagementService'\nimport { createHash } from 'crypto'\n\nexport interface AuthRequest extends NextRequest {\n  user?: AuthUser\n}\n\n/**\n * Authenticate JWT token middleware with session validation\n */\nexport async function authenticateToken(\n  request: NextRequest,\n  options: { validateSession?: boolean } = {}\n): Promise<{ user: AuthUser } | NextResponse> {\n  // Try to get token from cookies first (browser requests)\n  const tokenCookie = request.cookies.get('token')?.value\n  \n  // If not in cookies, try authorization header (API requests)\n  const authHeader = request.headers.get('authorization')\n  const headerToken = authHeader?.split(' ')[1]\n  \n  const token = tokenCookie || headerToken\n  \n  if (!token) {\n    return NextResponse.json(\n      { error: 'Access token required' },\n      { status: 401 }\n    )\n  }\n  \n  try {\n    const decoded = verifyToken(token)\n    if (!decoded || !decoded.userId || !decoded.email) {\n      return NextResponse.json(\n        { error: 'Invalid token payload' },\n        { status: 403 }\n      )\n    }\n\n    // Validate session if requested (for critical operations)\n    if (options.validateSession) {\n      const tokenHash = createHash('sha256').update(token).digest('hex')\n      const session = await SessionManagementService.validateSession(tokenHash)\n      \n      if (!session || !session.isActive) {\n        return NextResponse.json(\n          { error: 'Session expired or revoked' },\n          { status: 401 }\n        )\n      }\n\n      // Verify user is still active in database\n      const user = await queryOne(\n        `SELECT id, email, \"isActive\" FROM \"User\" WHERE id = $1`,\n        [decoded.userId]\n      )\n\n      if (!user || !user.isActive) {\n        return NextResponse.json(\n          { error: 'User account is inactive' },\n          { status: 403 }\n        )\n      }\n    }\n    \n    const user: AuthUser = {\n      userId: decoded.userId,\n      email: decoded.email,\n      isAdmin: decoded.isAdmin || false\n    }\n    \n    return { user }\n  } catch (error) {\n    return NextResponse.json(\n      { error: 'Invalid or expired token' },\n      { status: 403 }\n    )\n  }\n}\n\n/**\n * Require admin role middleware\n */\nexport function requireAdmin(user: AuthUser): { isAdmin: boolean } | NextResponse {\n  if (!user || !user.isAdmin) {\n    return NextResponse.json(\n      { error: 'Admin access required' },\n      { status: 403 }\n    )\n  }\n  \n  return { isAdmin: true }\n}\n\n/**\n * Require bot activation middleware\n */\nexport async function requireBotActivation(userId: string, botType: string): Promise<NextResponse | null> {\n  try {\n    // Use Neon Serverless query to check for active bot activation\n    const query = `\n      SELECT * FROM \"BotActivation\"\n      WHERE \"userId\" = $1 AND \"botType\" = $2\n      AND \"status\" = 'ACTIVE' AND \"isExpired\" = false\n      LIMIT 1\n    `;\n\n    const result = await neonQuery(query, [userId, botType]);\n    const botActivation = Array.isArray(result) && result.length > 0 ? result[0] : null;\n\n    if (!botActivation) {\n      return NextResponse.json(\n        { error: 'Bot activation required for this action' },\n        { status: 403 }\n      );\n    }\n\n    return null;\n  } catch (error) {\n    console.error('Error checking bot activation:', error);\n    return NextResponse.json(\n      { error: 'Error checking bot activation' },\n      { status: 500 }\n    );\n  }\n}\n\n/**\n * Verify authentication from token in cookies or headers\n * Returns user ID if authenticated\n */\nexport async function verifyAuth(request: NextRequest): Promise<{ success: boolean; userId?: string }> {\n  // Try to get token from cookies first\n  const tokenCookie = request.cookies.get('token')?.value\n  \n  // If not in cookies, try authorization header\n  const authHeader = request.headers.get('authorization')\n  const headerToken = authHeader?.split(' ')[1]\n  \n  const token = tokenCookie || headerToken\n  \n  if (!token) {\n    return { success: false }\n  }\n  \n  try {\n    const decoded = verifyToken(token)\n    if (!decoded || !decoded.userId) {\n      return { success: false }\n    }\n    \n    return { success: true, userId: decoded.userId }\n  } catch (error) {\n    return { success: false }\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1352, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/LENOVO/Desktop/nsc-test/vercel-download/src/app/api/admin/bot-packages/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server'\r\nimport { query, queryOne, queryScalar, execute, transaction } from \"@/lib/db\"\r\nimport { authenticateToken, requireAdmin } from '@/middleware/auth'\r\n\r\n// Force dynamic rendering for real-time data\r\nexport const dynamic = 'force-dynamic'\r\nexport const revalidate = 0\r\n\r\nexport async function GET(request: NextRequest) {\r\n  // Authenticate user\r\n  const authResult = await authenticateToken(request)\r\n  if (authResult instanceof NextResponse) return authResult\r\n  \r\n  const { user } = authResult\r\n\r\n  // Check admin\r\n  const adminCheck = requireAdmin(user)\r\n  if (adminCheck instanceof NextResponse) return adminCheck\r\n\r\n  try {\r\n    // Get all user packages with user details\r\n    const packages = await query<{\r\n      id: string\r\n      userId: string\r\n      packageType: string\r\n      amount: string\r\n      roiPercentage: string\r\n      status: string\r\n      investmentDate: Date | null\r\n      expiryDate: Date | null\r\n      totalRoiPaid: string\r\n      roiPaidCount: number\r\n      depositTxHash: string | null\r\n      network: string | null\r\n      createdAt: Date\r\n      userEmail: string\r\n      userFullName: string\r\n    }>(`\r\n      SELECT\r\n        p.id,\r\n        p.\"userId\",\r\n        p.\"packageType\",\r\n        p.amount,\r\n        p.\"roiPercentage\",\r\n        p.status,\r\n        p.\"investmentDate\",\r\n        p.\"expiryDate\",\r\n        p.\"totalRoiPaid\",\r\n        p.\"roiPaidCount\",\r\n        p.\"depositTxHash\",\r\n        p.network,\r\n        p.\"createdAt\",\r\n        u.email as \"userEmail\",\r\n        u.\"fullName\" as \"userFullName\"\r\n      FROM \"Package\" p\r\n      LEFT JOIN \"User\" u ON p.\"userId\" = u.id\r\n      ORDER BY p.\"createdAt\" DESC\r\n    `)\r\n\r\n    // Transform to expected format\r\n    const transformedPackages = packages.map(pkg => {\r\n      // Helper to ensure ISO string\r\n      const toISOString = (value: any) => {\r\n        if (!value) return new Date().toISOString();\r\n        if (typeof value === 'string') return value;\r\n        if (value instanceof Date) return value.toISOString();\r\n        return new Date().toISOString();\r\n      };\r\n\r\n      return {\r\n        id: pkg.id,\r\n        userId: pkg.userId,\r\n        userEmail: pkg.userEmail || 'N/A',\r\n        packageType: pkg.packageType || 'STANDARD',\r\n        amount: Number(pkg.amount),\r\n        roiPercentage: Number(pkg.roiPercentage),\r\n        status: pkg.status || 'PENDING',\r\n        investmentDate: toISOString(pkg.investmentDate || pkg.createdAt),\r\n        expiryDate: toISOString(pkg.expiryDate || pkg.createdAt),\r\n        totalRoiPaid: Number(pkg.totalRoiPaid || 0),\r\n        roiPaidCount: pkg.roiPaidCount || 0,\r\n        depositTxHash: pkg.depositTxHash,\r\n        network: pkg.network,\r\n        createdAt: toISOString(pkg.createdAt)\r\n      };\r\n    });\r\n\r\n    return NextResponse.json({\r\n      success: true,\r\n      packages: transformedPackages\r\n    })\r\n\r\n  } catch (error) {\r\n    console.error('Get bot packages error:', error)\r\n    return NextResponse.json(\r\n      { success: false, error: 'Failed to fetch bot packages' },\r\n      { status: 500 }\r\n    )\r\n  }\r\n}\r\n\r\nexport async function POST(request: NextRequest) {\r\n  // Authenticate user\r\n  const authResult = await authenticateToken(request)\r\n  if (authResult instanceof NextResponse) return authResult\r\n  \r\n  const { user } = authResult\r\n\r\n  // Check admin\r\n  const adminCheck = requireAdmin(user)\r\n  if (adminCheck instanceof NextResponse) return adminCheck\r\n\r\n  try {\r\n    const body = await request.json()\r\n    const { userId, packageType, amount, roiPercentage, network, notes } = body\r\n\r\n    // Validate required fields\r\n    if (!userId || !packageType || !amount || !roiPercentage) {\r\n      return NextResponse.json(\r\n        { success: false, error: 'Missing required fields: userId, packageType, amount, roiPercentage' },\r\n        { status: 400 }\r\n      )\r\n    }\r\n\r\n    // Validate packageType\r\n    const validPackageTypes = ['NEO', 'NEURAL', 'ORACLE']\r\n    if (!validPackageTypes.includes(packageType)) {\r\n      return NextResponse.json(\r\n        { success: false, error: `Invalid packageType. Must be one of: ${validPackageTypes.join(', ')}` },\r\n        { status: 400 }\r\n      )\r\n    }\r\n\r\n    // Create new package\r\n    const newPackageResult = await query<{\r\n      id: string\r\n      userId: string\r\n      packageType: string\r\n      amount: string\r\n      roiPercentage: string\r\n      status: string\r\n      notes: string | null\r\n      network: string | null\r\n    }>(`\r\n      INSERT INTO \"Package\" (\r\n        \"userId\", \"packageType\", amount, \"roiPercentage\", network,\r\n        notes, status, \"createdAt\", \"updatedAt\"\r\n      )\r\n      VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)\r\n      RETURNING id, \"userId\", \"packageType\", amount, \"roiPercentage\", status, notes, network\r\n    `, [\r\n      userId,\r\n      packageType,\r\n      amount,\r\n      roiPercentage,\r\n      network || null,\r\n      notes || null,\r\n      'PENDING',\r\n      new Date(),\r\n      new Date()\r\n    ])\r\n    const newPackage = newPackageResult[0]\r\n\r\n    return NextResponse.json({\r\n      success: true,\r\n      package: {\r\n        id: newPackage.id,\r\n        userId: newPackage.userId,\r\n        packageType: newPackage.packageType,\r\n        amount: Number(newPackage.amount),\r\n        roiPercentage: Number(newPackage.roiPercentage),\r\n        status: newPackage.status,\r\n        network: newPackage.network,\r\n        notes: newPackage.notes\r\n      }\r\n    })\r\n\r\n  } catch (error) {\r\n    console.error('Create bot package error:', error)\r\n    return NextResponse.json(\r\n      { success: false, error: 'Failed to create bot package' },\r\n      { status: 500 }\r\n    )\r\n  }\r\n}\r\n\r\nexport async function PUT(request: NextRequest) {\r\n  // Authenticate user\r\n  const authResult = await authenticateToken(request)\r\n  if (authResult instanceof NextResponse) return authResult\r\n  \r\n  const { user } = authResult\r\n\r\n  // Check admin\r\n  const adminCheck = requireAdmin(user)\r\n  if (adminCheck instanceof NextResponse) return adminCheck\r\n\r\n  try {\r\n    const body = await request.json()\r\n    const { id, packageType, amount, roiPercentage, network, notes, status } = body\r\n\r\n    if (!id) {\r\n      return NextResponse.json(\r\n        { success: false, error: 'Package ID is required' },\r\n        { status: 400 }\r\n      )\r\n    }\r\n\r\n    // Validate packageType if provided\r\n    if (packageType) {\r\n      const validPackageTypes = ['NEO', 'NEURAL', 'ORACLE']\r\n      if (!validPackageTypes.includes(packageType)) {\r\n        return NextResponse.json(\r\n          { success: false, error: `Invalid packageType. Must be one of: ${validPackageTypes.join(', ')}` },\r\n          { status: 400 }\r\n        )\r\n      }\r\n    }\r\n\r\n    // Validate status if provided\r\n    if (status) {\r\n      const validStatuses = ['PENDING', 'ACTIVE', 'EXPIRED', 'WITHDRAWN', 'CANCELLED', 'COMPLETED']\r\n      if (!validStatuses.includes(status)) {\r\n        return NextResponse.json(\r\n          { success: false, error: `Invalid status. Must be one of: ${validStatuses.join(', ')}` },\r\n          { status: 400 }\r\n        )\r\n      }\r\n    }\r\n\r\n    // Build dynamic update query\r\n    const updates: string[] = []\r\n    const params: any[] = []\r\n    let paramCount = 1\r\n\r\n    if (packageType !== undefined) {\r\n      updates.push(`\"packageType\" = $${paramCount}`)\r\n      params.push(packageType)\r\n      paramCount++\r\n    }\r\n    if (amount !== undefined) {\r\n      updates.push(`amount = $${paramCount}`)\r\n      params.push(amount)\r\n      paramCount++\r\n    }\r\n    if (roiPercentage !== undefined) {\r\n      updates.push(`\"roiPercentage\" = $${paramCount}`)\r\n      params.push(roiPercentage)\r\n      paramCount++\r\n    }\r\n    if (network !== undefined) {\r\n      updates.push(`network = $${paramCount}`)\r\n      params.push(network)\r\n      paramCount++\r\n    }\r\n    if (notes !== undefined) {\r\n      updates.push(`notes = $${paramCount}`)\r\n      params.push(notes)\r\n      paramCount++\r\n    }\r\n    if (status !== undefined) {\r\n      updates.push(`status = $${paramCount}::\"PackageStatus\"`)\r\n      params.push(status)\r\n      paramCount++\r\n    }\r\n\r\n    updates.push(`\"updatedAt\" = $${paramCount}`)\r\n    params.push(new Date())\r\n    paramCount++\r\n\r\n    params.push(id)\r\n\r\n    // Update package\r\n    const updatedPackageResult = await query<{\r\n      id: string\r\n      packageType: string\r\n      amount: string\r\n      roiPercentage: string\r\n      network: string | null\r\n      notes: string | null\r\n      status: string\r\n    }>(`\r\n      UPDATE \"Package\"\r\n      SET ${updates.join(', ')}\r\n      WHERE id = $${paramCount}\r\n      RETURNING id, \"packageType\", amount, \"roiPercentage\", network, notes, status\r\n    `, params)\r\n\r\n    if (updatedPackageResult.length === 0) {\r\n      return NextResponse.json(\r\n        { success: false, error: 'Package not found' },\r\n        { status: 404 }\r\n      )\r\n    }\r\n\r\n    const updatedPackage = updatedPackageResult[0]\r\n\r\n    return NextResponse.json({\r\n      success: true,\r\n      package: {\r\n        id: updatedPackage.id,\r\n        packageType: updatedPackage.packageType,\r\n        amount: Number(updatedPackage.amount),\r\n        roiPercentage: Number(updatedPackage.roiPercentage),\r\n        network: updatedPackage.network,\r\n        notes: updatedPackage.notes,\r\n        status: updatedPackage.status\r\n      }\r\n    })\r\n\r\n  } catch (error) {\r\n    console.error('Update bot package error:', error)\r\n    return NextResponse.json(\r\n      { success: false, error: 'Failed to update bot package' },\r\n      { status: 500 }\r\n    )\r\n  }\r\n}\r\n\r\nexport async function DELETE(request: NextRequest) {\r\n  // Authenticate user\r\n  const authResult = await authenticateToken(request)\r\n  if (authResult instanceof NextResponse) return authResult\r\n  \r\n  const { user } = authResult\r\n\r\n  // Check admin\r\n  const adminCheck = requireAdmin(user)\r\n  if (adminCheck instanceof NextResponse) return adminCheck\r\n\r\n  try {\r\n    const { searchParams } = new URL(request.url)\r\n    const id = searchParams.get('id')\r\n\r\n    if (!id) {\r\n      return NextResponse.json(\r\n        { success: false, error: 'Package ID is required' },\r\n        { status: 400 }\r\n      )\r\n    }\r\n\r\n    // Soft delete - mark as cancelled\r\n    await execute(`\r\n      UPDATE \"Package\"\r\n      SET status = 'CANCELLED'::\"PackageStatus\", \"updatedAt\" = $2\r\n      WHERE id = $1\r\n    `, [id, new Date()])\r\n\r\n    return NextResponse.json({\r\n      success: true,\r\n      message: 'Package cancelled successfully'\r\n    })\r\n\r\n  } catch (error) {\r\n    console.error('Delete bot package error:', error)\r\n    return NextResponse.json(\r\n      { success: false, error: 'Failed to delete bot package' },\r\n      { status: 500 }\r\n    )\r\n  }\r\n}\r\n\r\n"],"names":[],"mappings":";;;;;;;;;;;;;;AAAA;AACA;AACA;;;;;;;;;AAGO,MAAM,UAAU;AAChB,MAAM,aAAa;AAEnB,eAAe,IAAI,OAAoB;IAC5C,oBAAoB;IACpB,MAAM,aAAa,MAAM,IAAA,yIAAiB,EAAC;IAC3C,IAAI,sBAAsB,gJAAY,EAAE,OAAO;IAE/C,MAAM,EAAE,IAAI,EAAE,GAAG;IAEjB,cAAc;IACd,MAAM,aAAa,IAAA,oIAAY,EAAC;IAChC,IAAI,sBAAsB,gJAAY,EAAE,OAAO;IAE/C,IAAI;QACF,0CAA0C;QAC1C,MAAM,WAAW,MAAM,IAAA,oIAAK,EAgBzB,CAAC;;;;;;;;;;;;;;;;;;;;IAoBJ,CAAC;QAED,+BAA+B;QAC/B,MAAM,sBAAsB,SAAS,GAAG,CAAC,CAAA;YACvC,8BAA8B;YAC9B,MAAM,cAAc,CAAC;gBACnB,IAAI,CAAC,OAAO,OAAO,IAAI,OAAO,WAAW;gBACzC,IAAI,OAAO,UAAU,UAAU,OAAO;gBACtC,IAAI,iBAAiB,MAAM,OAAO,MAAM,WAAW;gBACnD,OAAO,IAAI,OAAO,WAAW;YAC/B;YAEA,OAAO;gBACL,IAAI,IAAI,EAAE;gBACV,QAAQ,IAAI,MAAM;gBAClB,WAAW,IAAI,SAAS,IAAI;gBAC5B,aAAa,IAAI,WAAW,IAAI;gBAChC,QAAQ,OAAO,IAAI,MAAM;gBACzB,eAAe,OAAO,IAAI,aAAa;gBACvC,QAAQ,IAAI,MAAM,IAAI;gBACtB,gBAAgB,YAAY,IAAI,cAAc,IAAI,IAAI,SAAS;gBAC/D,YAAY,YAAY,IAAI,UAAU,IAAI,IAAI,SAAS;gBACvD,cAAc,OAAO,IAAI,YAAY,IAAI;gBACzC,cAAc,IAAI,YAAY,IAAI;gBAClC,eAAe,IAAI,aAAa;gBAChC,SAAS,IAAI,OAAO;gBACpB,WAAW,YAAY,IAAI,SAAS;YACtC;QACF;QAEA,OAAO,gJAAY,CAAC,IAAI,CAAC;YACvB,SAAS;YACT,UAAU;QACZ;IAEF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,2BAA2B;QACzC,OAAO,gJAAY,CAAC,IAAI,CACtB;YAAE,SAAS;YAAO,OAAO;QAA+B,GACxD;YAAE,QAAQ;QAAI;IAElB;AACF;AAEO,eAAe,KAAK,OAAoB;IAC7C,oBAAoB;IACpB,MAAM,aAAa,MAAM,IAAA,yIAAiB,EAAC;IAC3C,IAAI,sBAAsB,gJAAY,EAAE,OAAO;IAE/C,MAAM,EAAE,IAAI,EAAE,GAAG;IAEjB,cAAc;IACd,MAAM,aAAa,IAAA,oIAAY,EAAC;IAChC,IAAI,sBAAsB,gJAAY,EAAE,OAAO;IAE/C,IAAI;QACF,MAAM,OAAO,MAAM,QAAQ,IAAI;QAC/B,MAAM,EAAE,MAAM,EAAE,WAAW,EAAE,MAAM,EAAE,aAAa,EAAE,OAAO,EAAE,KAAK,EAAE,GAAG;QAEvE,2BAA2B;QAC3B,IAAI,CAAC,UAAU,CAAC,eAAe,CAAC,UAAU,CAAC,eAAe;YACxD,OAAO,gJAAY,CAAC,IAAI,CACtB;gBAAE,SAAS;gBAAO,OAAO;YAAsE,GAC/F;gBAAE,QAAQ;YAAI;QAElB;QAEA,uBAAuB;QACvB,MAAM,oBAAoB;YAAC;YAAO;YAAU;SAAS;QACrD,IAAI,CAAC,kBAAkB,QAAQ,CAAC,cAAc;YAC5C,OAAO,gJAAY,CAAC,IAAI,CACtB;gBAAE,SAAS;gBAAO,OAAO,CAAC,qCAAqC,EAAE,kBAAkB,IAAI,CAAC,OAAO;YAAC,GAChG;gBAAE,QAAQ;YAAI;QAElB;QAEA,qBAAqB;QACrB,MAAM,mBAAmB,MAAM,IAAA,oIAAK,EASjC,CAAC;;;;;;;IAOJ,CAAC,EAAE;YACD;YACA;YACA;YACA;YACA,WAAW;YACX,SAAS;YACT;YACA,IAAI;YACJ,IAAI;SACL;QACD,MAAM,aAAa,gBAAgB,CAAC,EAAE;QAEtC,OAAO,gJAAY,CAAC,IAAI,CAAC;YACvB,SAAS;YACT,SAAS;gBACP,IAAI,WAAW,EAAE;gBACjB,QAAQ,WAAW,MAAM;gBACzB,aAAa,WAAW,WAAW;gBACnC,QAAQ,OAAO,WAAW,MAAM;gBAChC,eAAe,OAAO,WAAW,aAAa;gBAC9C,QAAQ,WAAW,MAAM;gBACzB,SAAS,WAAW,OAAO;gBAC3B,OAAO,WAAW,KAAK;YACzB;QACF;IAEF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,6BAA6B;QAC3C,OAAO,gJAAY,CAAC,IAAI,CACtB;YAAE,SAAS;YAAO,OAAO;QAA+B,GACxD;YAAE,QAAQ;QAAI;IAElB;AACF;AAEO,eAAe,IAAI,OAAoB;IAC5C,oBAAoB;IACpB,MAAM,aAAa,MAAM,IAAA,yIAAiB,EAAC;IAC3C,IAAI,sBAAsB,gJAAY,EAAE,OAAO;IAE/C,MAAM,EAAE,IAAI,EAAE,GAAG;IAEjB,cAAc;IACd,MAAM,aAAa,IAAA,oIAAY,EAAC;IAChC,IAAI,sBAAsB,gJAAY,EAAE,OAAO;IAE/C,IAAI;QACF,MAAM,OAAO,MAAM,QAAQ,IAAI;QAC/B,MAAM,EAAE,EAAE,EAAE,WAAW,EAAE,MAAM,EAAE,aAAa,EAAE,OAAO,EAAE,KAAK,EAAE,MAAM,EAAE,GAAG;QAE3E,IAAI,CAAC,IAAI;YACP,OAAO,gJAAY,CAAC,IAAI,CACtB;gBAAE,SAAS;gBAAO,OAAO;YAAyB,GAClD;gBAAE,QAAQ;YAAI;QAElB;QAEA,mCAAmC;QACnC,IAAI,aAAa;YACf,MAAM,oBAAoB;gBAAC;gBAAO;gBAAU;aAAS;YACrD,IAAI,CAAC,kBAAkB,QAAQ,CAAC,cAAc;gBAC5C,OAAO,gJAAY,CAAC,IAAI,CACtB;oBAAE,SAAS;oBAAO,OAAO,CAAC,qCAAqC,EAAE,kBAAkB,IAAI,CAAC,OAAO;gBAAC,GAChG;oBAAE,QAAQ;gBAAI;YAElB;QACF;QAEA,8BAA8B;QAC9B,IAAI,QAAQ;YACV,MAAM,gBAAgB;gBAAC;gBAAW;gBAAU;gBAAW;gBAAa;gBAAa;aAAY;YAC7F,IAAI,CAAC,cAAc,QAAQ,CAAC,SAAS;gBACnC,OAAO,gJAAY,CAAC,IAAI,CACtB;oBAAE,SAAS;oBAAO,OAAO,CAAC,gCAAgC,EAAE,cAAc,IAAI,CAAC,OAAO;gBAAC,GACvF;oBAAE,QAAQ;gBAAI;YAElB;QACF;QAEA,6BAA6B;QAC7B,MAAM,UAAoB,EAAE;QAC5B,MAAM,SAAgB,EAAE;QACxB,IAAI,aAAa;QAEjB,IAAI,gBAAgB,WAAW;YAC7B,QAAQ,IAAI,CAAC,CAAC,iBAAiB,EAAE,YAAY;YAC7C,OAAO,IAAI,CAAC;YACZ;QACF;QACA,IAAI,WAAW,WAAW;YACxB,QAAQ,IAAI,CAAC,CAAC,UAAU,EAAE,YAAY;YACtC,OAAO,IAAI,CAAC;YACZ;QACF;QACA,IAAI,kBAAkB,WAAW;YAC/B,QAAQ,IAAI,CAAC,CAAC,mBAAmB,EAAE,YAAY;YAC/C,OAAO,IAAI,CAAC;YACZ;QACF;QACA,IAAI,YAAY,WAAW;YACzB,QAAQ,IAAI,CAAC,CAAC,WAAW,EAAE,YAAY;YACvC,OAAO,IAAI,CAAC;YACZ;QACF;QACA,IAAI,UAAU,WAAW;YACvB,QAAQ,IAAI,CAAC,CAAC,SAAS,EAAE,YAAY;YACrC,OAAO,IAAI,CAAC;YACZ;QACF;QACA,IAAI,WAAW,WAAW;YACxB,QAAQ,IAAI,CAAC,CAAC,UAAU,EAAE,WAAW,iBAAiB,CAAC;YACvD,OAAO,IAAI,CAAC;YACZ;QACF;QAEA,QAAQ,IAAI,CAAC,CAAC,eAAe,EAAE,YAAY;QAC3C,OAAO,IAAI,CAAC,IAAI;QAChB;QAEA,OAAO,IAAI,CAAC;QAEZ,iBAAiB;QACjB,MAAM,uBAAuB,MAAM,IAAA,oIAAK,EAQrC,CAAC;;UAEE,EAAE,QAAQ,IAAI,CAAC,MAAM;kBACb,EAAE,WAAW;;IAE3B,CAAC,EAAE;QAEH,IAAI,qBAAqB,MAAM,KAAK,GAAG;YACrC,OAAO,gJAAY,CAAC,IAAI,CACtB;gBAAE,SAAS;gBAAO,OAAO;YAAoB,GAC7C;gBAAE,QAAQ;YAAI;QAElB;QAEA,MAAM,iBAAiB,oBAAoB,CAAC,EAAE;QAE9C,OAAO,gJAAY,CAAC,IAAI,CAAC;YACvB,SAAS;YACT,SAAS;gBACP,IAAI,eAAe,EAAE;gBACrB,aAAa,eAAe,WAAW;gBACvC,QAAQ,OAAO,eAAe,MAAM;gBACpC,eAAe,OAAO,eAAe,aAAa;gBAClD,SAAS,eAAe,OAAO;gBAC/B,OAAO,eAAe,KAAK;gBAC3B,QAAQ,eAAe,MAAM;YAC/B;QACF;IAEF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,6BAA6B;QAC3C,OAAO,gJAAY,CAAC,IAAI,CACtB;YAAE,SAAS;YAAO,OAAO;QAA+B,GACxD;YAAE,QAAQ;QAAI;IAElB;AACF;AAEO,eAAe,OAAO,OAAoB;IAC/C,oBAAoB;IACpB,MAAM,aAAa,MAAM,IAAA,yIAAiB,EAAC;IAC3C,IAAI,sBAAsB,gJAAY,EAAE,OAAO;IAE/C,MAAM,EAAE,IAAI,EAAE,GAAG;IAEjB,cAAc;IACd,MAAM,aAAa,IAAA,oIAAY,EAAC;IAChC,IAAI,sBAAsB,gJAAY,EAAE,OAAO;IAE/C,IAAI;QACF,MAAM,EAAE,YAAY,EAAE,GAAG,IAAI,IAAI,QAAQ,GAAG;QAC5C,MAAM,KAAK,aAAa,GAAG,CAAC;QAE5B,IAAI,CAAC,IAAI;YACP,OAAO,gJAAY,CAAC,IAAI,CACtB;gBAAE,SAAS;gBAAO,OAAO;YAAyB,GAClD;gBAAE,QAAQ;YAAI;QAElB;QAEA,kCAAkC;QAClC,MAAM,IAAA,sIAAO,EAAC,CAAC;;;;IAIf,CAAC,EAAE;YAAC;YAAI,IAAI;SAAO;QAEnB,OAAO,gJAAY,CAAC,IAAI,CAAC;YACvB,SAAS;YACT,SAAS;QACX;IAEF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,6BAA6B;QAC3C,OAAO,gJAAY,CAAC,IAAI,CACtB;YAAE,SAAS;YAAO,OAAO;QAA+B,GACxD;YAAE,QAAQ;QAAI;IAElB;AACF"}}]
}