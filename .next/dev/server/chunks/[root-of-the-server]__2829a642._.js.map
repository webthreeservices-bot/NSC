{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 106, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/LENOVO/Desktop/nsc-test/vercel-download/src/lib/db-connection.ts"],"sourcesContent":["import { Pool } from 'pg'\n\n// Load environment variables only in development\nif (process.env.NODE_ENV !== 'production') {\n  try {\n    const dotenv = require('dotenv')\n    dotenv.config()\n  } catch (error) {\n    // dotenv is optional, might not be installed in production\n    console.log('dotenv not available, using system environment variables')\n  }\n}\n\n// Parse DATABASE_URL to handle Neon and other providers\nconst getDatabaseConfig = () => {\n  const connectionString = process.env.DATABASE_URL\n\n  if (!connectionString) {\n    console.error('‚ùå DATABASE_URL is not defined in environment variables')\n    console.error('Please ensure your .env file contains a valid DATABASE_URL')\n    throw new Error('DATABASE_URL is not defined in environment variables')\n  }\n\n  // For Neon and other cloud providers, always use SSL\n  const isCloudProvider = connectionString.includes('neon.tech') ||\n                         connectionString.includes('supabase.co') ||\n                         connectionString.includes('amazonaws.com') ||\n                         connectionString.includes('azure.com')\n\n  // For Neon, we need specific SSL settings\n  const isNeon = connectionString.includes('neon.tech')\n\n  // SSL configuration based on provider\n  const sslConfig = isNeon\n    ? {\n        rejectUnauthorized: false,\n        ca: null,\n        checkServerIdentity: () => undefined\n      }\n    : { rejectUnauthorized: process.env.DB_SSL_REJECT_UNAUTHORIZED !== 'false' }\n\n  // Optimized configuration for NeonDB\n  return {\n    connectionString,\n    ssl: isCloudProvider ? sslConfig : false,\n    max: 20, // ‚úÖ Increased pool size for better concurrent request handling\n    min: 5, // ‚úÖ Keep more connections warm to avoid timeouts\n    idleTimeoutMillis: 60000, // 60 seconds idle timeout (increased)\n    connectionTimeoutMillis: 20000, // 20 seconds connection timeout (increased)\n    allowExitOnIdle: false, // ‚úÖ Don't exit on idle to maintain connections\n    statement_timeout: 60000, // 60 seconds (increased)\n    query_timeout: 60000, // 60 seconds (increased)\n    keepAlive: true, // ‚úÖ Keep connections alive\n    keepAliveInitialDelayMillis: 5000, // 5 seconds\n    // Additional Neon-specific optimizations\n    application_name: 'nsc-bot-platform',\n    idle_in_transaction_session_timeout: 120000 // 2 minutes (increased)\n  }\n}\n\n// Single pool instance - NO resets, NO lazy initialization\nlet pool: Pool | null = null;\nlet isInitializing = false;\n\nconst getPool = () => {\n  // Create pool only once\n  if (!pool && !isInitializing) {\n    isInitializing = true;\n    try {\n      pool = new Pool(getDatabaseConfig());\n\n      // Add error handling for the pool - DO NOT reset pool or exit process\n      pool.on('error', (err) => {\n        console.error('‚ùå Unexpected error on idle client:', err);\n        console.error('Connection will be removed from pool and recreated automatically');\n        // ‚úÖ Let pg handle reconnection automatically - don't reset pool\n      });\n\n      // Only log connection events when VERBOSE_DB_LOGS is set (not during build)\n      const isBuilding = process.env.NEXT_PHASE === 'phase-production-build';\n      const shouldLog = !isBuilding && (process.env.NODE_ENV !== 'production' || process.env.VERBOSE_DB_LOGS === 'true');\n\n      if (shouldLog) {\n        pool.on('connect', (client) => {\n          console.log('‚úÖ New client connected to NeonDB');\n        });\n\n        pool.on('remove', (client) => {\n          console.log('üîå Client removed from pool');\n        });\n      }\n\n      if (!isBuilding) {\n        console.log('üöÄ Database pool initialized for NeonDB');\n      }\n    } catch (error) {\n      isInitializing = false;\n      console.error('‚ùå Failed to initialize database pool:', error);\n      throw error;\n    } finally {\n      isInitializing = false;\n    }\n  }\n\n  // Wait for initialization if it's in progress\n  while (isInitializing && !pool) {\n    // Busy wait - this is acceptable because initialization is fast\n  }\n\n  return pool!;\n};\n\n// Test database connection\nexport async function testConnection() {\n  let client\n  try {\n    const poolInstance = getPool();\n    client = await poolInstance.connect()\n    const result = await client.query('SELECT NOW()')\n    console.log('Database connection successful:', result.rows[0])\n    return true\n  } catch (err) {\n    console.error('Database connection error:', err)\n    return false\n  } finally {\n    if (client) client.release()\n  }\n}\n\n// Warmup database connection - call this on server start (NOT during build)\nexport async function warmupConnection() {\n  // Skip warmup during build phase\n  const isBuilding = process.env.NEXT_PHASE === 'phase-production-build';\n  if (isBuilding) {\n    return;\n  }\n\n  console.log('üî• Warming up database connection...')\n\n  try {\n    // Try to establish a connection and run a simple query\n    const success = await testConnection()\n\n    if (success) {\n      console.log('‚úÖ Database connection warmed up successfully')\n\n      // Pre-establish a connection in the pool\n      const poolInstance = getPool();\n      const client = await poolInstance.connect()\n\n      // Keep the connection alive briefly then release\n      setTimeout(() => {\n        client.release()\n        console.log('üîå Warmup connection released')\n      }, 1000)\n\n    } else {\n      console.warn('‚ö†Ô∏è Database warmup failed, but continuing...')\n    }\n  } catch (error: any) {\n    console.warn('‚ö†Ô∏è Database warmup error:', error?.message || 'Unknown error')\n  }\n}\n\n// Export a proxy that lazily initializes the pool\nconst poolProxy = new Proxy({} as Pool, {\n  get(target, prop) {\n    const poolInstance = getPool();\n    return poolInstance[prop as keyof Pool];\n  }\n});\n\n/**\n * Get a database client with timeout protection\n * @param timeoutMs Timeout in milliseconds (default: 20000ms)\n * @returns Database client\n * @throws Error if connection times out or fails\n */\nexport async function getClientWithTimeout(timeoutMs: number = 20000) {\n  const poolInstance = getPool();\n  \n  return Promise.race([\n    poolInstance.connect(),\n    new Promise<never>((_, reject) => \n      setTimeout(() => reject(new Error(`Database connection timeout after ${timeoutMs}ms`)), timeoutMs)\n    )\n  ]);\n}\n\n/**\n * Execute a query with timeout protection\n * @param query SQL query string\n * @param params Query parameters\n * @param timeoutMs Query timeout in milliseconds (default: 20000ms)\n * @returns Query result\n */\nexport async function queryWithTimeout(query: string, params: any[] = [], timeoutMs: number = 20000) {\n  let client;\n  try {\n    client = await getClientWithTimeout(timeoutMs);\n    \n    const queryPromise = client.query(query, params);\n    const timeoutPromise = new Promise<never>((_, reject) => \n      setTimeout(() => reject(new Error(`Query timeout after ${timeoutMs}ms`)), timeoutMs)\n    );\n    \n    return await Promise.race([queryPromise, timeoutPromise]);\n  } finally {\n    if (client) {\n      client.release();\n    }\n  }\n}\n\n// Export the pool for use in other modules\nexport default poolProxy\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 295, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/LENOVO/Desktop/nsc-test/vercel-download/src/lib/db.ts"],"sourcesContent":["/**\n * Pure PostgreSQL Database Layer\n * NO PRISMA. NO ORM. Just direct SQL via pg driver.\n * Neon DB (Serverless PostgreSQL)\n */\n\nimport pool from './db-connection'\n\n// Helper to convert snake_case to camelCase\nfunction toCamelCase(obj: any): any {\n  if (Array.isArray(obj)) {\n    return obj.map(toCamelCase)\n  }\n  if (obj !== null && typeof obj === 'object') {\n    return Object.keys(obj).reduce((acc, key) => {\n      const camelKey = key.replace(/_([a-z])/g, (g) => g[1].toUpperCase())\n      acc[camelKey] = toCamelCase(obj[key])\n      return acc\n    }, {} as any)\n  }\n  return obj\n}\n\n// Helper to convert camelCase to snake_case\nfunction toSnakeCase(obj: any): any {\n  if (obj instanceof Date) return obj.toISOString()\n  if (Array.isArray(obj)) return obj.map(toSnakeCase)\n  if (obj !== null && typeof obj === 'object') {\n    const result: any = {}\n    for (const key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        result[key] = toSnakeCase(obj[key])\n      }\n    }\n    return result\n  }\n  return obj\n}\n\n/**\n * Execute any PostgreSQL query and return rows\n * @example\n * const users = await query<User>('SELECT * FROM \"User\" WHERE \"isActive\" = $1', [true])\n */\nexport async function query<T = any>(sql: string, params: any[] = []): Promise<T[]> {\n  // Validate that sql is actually a string\n  if (typeof sql !== 'string' || sql.trim().length === 0) {\n    const error = new Error('A query must have either text or a name. Supplying neither is unsupported.')\n    console.error('PostgreSQL Error:', {\n      message: error.message,\n      sql: sql,\n      code: undefined,\n    })\n    throw error\n  }\n\n  try {\n    const result = await pool.query(sql, params)\n    return result.rows as T[]\n  } catch (error: any) {\n    console.error('PostgreSQL Error:', {\n      message: error.message,\n      sql: typeof sql === 'string' ? sql.substring(0, 200) : sql,\n      code: error.code,\n    })\n    throw error\n  }\n}\n\n/**\n * Get a single row from query (or null)\n * @example\n * const user = await queryOne<User>('SELECT * FROM \"User\" WHERE \"id\" = $1', [userId])\n */\nexport async function queryOne<T = any>(sql: string, params: any[] = []): Promise<T | null> {\n  const rows = await query<T>(sql, params)\n  return rows.length > 0 ? rows[0] : null\n}\n\n/**\n * Get a single scalar value (for COUNT, SUM, MAX, AVG, etc.)\n * @example\n * const count = await queryScalar<number>('SELECT COUNT(*) as count FROM \"User\"')\n */\nexport async function queryScalar<T = any>(sql: string, params: any[] = []): Promise<T | null> {\n  const rows = await query<any>(sql, params)\n  if (rows.length === 0) return null\n  const firstValue = Object.values(rows[0])[0]\n  return firstValue as T\n}\n\n/**\n * Execute INSERT/UPDATE/DELETE query\n * Returns number of affected rows\n * @example\n * const count = await execute('UPDATE \"User\" SET \"isActive\" = $1 WHERE \"id\" = $2', [true, userId])\n */\nexport async function execute(sql: string, params: any[] = []): Promise<number> {\n  // Validate that sql is actually a string\n  if (typeof sql !== 'string' || sql.trim().length === 0) {\n    const error = new Error('A query must have either text or a name. Supplying neither is unsupported.')\n    console.error('PostgreSQL Error:', {\n      message: error.message,\n      sql: sql,\n      code: undefined,\n    })\n    throw error\n  }\n\n  try {\n    const result = await pool.query(sql, params)\n    return result.rowCount || 0\n  } catch (error: any) {\n    console.error('PostgreSQL Error:', {\n      message: error.message,\n      sql: typeof sql === 'string' ? sql.substring(0, 200) : sql,\n      code: error.code,\n    })\n    throw error\n  }\n}\n\n/**\n * Run multiple queries atomically in a transaction\n * Automatically COMMIT on success or ROLLBACK on error\n * @example\n * await transaction(async (client) => {\n *   await client.query('INSERT INTO \"User\" VALUES (...)')\n *   await client.query('UPDATE \"Package\" SET ...')\n * })\n */\nexport async function transaction<T>(\n  callback: (client: any) => Promise<T>\n): Promise<T> {\n  const client = await pool.connect()\n  try {\n    await client.query('BEGIN')\n    const result = await callback(client)\n    await client.query('COMMIT')\n    return result\n  } catch (error) {\n    await client.query('ROLLBACK')\n    throw error\n  } finally {\n    client.release()\n  }\n}\n\n/**\n * Disconnect from database (graceful shutdown)\n */\nexport async function disconnect(): Promise<void> {\n  await pool.end()\n}\n\n// Re-export pool for advanced use cases\nexport { pool }\n\n// Export helpers for use in refactored code\nexport { toCamelCase, toSnakeCase }\n\n/**\n * SQL translator - Converts SQL-style calls to pure queries\n * Translates ALL SQL calls to direct database queries underneath\n * This allows 60+ existing files to work while transitioning to pure SQL\n */\nexport const prisma: any = new Proxy({}, {\n  get: (target, table: string | symbol) => {\n    if (typeof table !== 'string') return undefined\n    \n    return {\n      async findUnique({ where, select }: any) {\n        const [key, value] = Object.entries(where)[0] as [string, any]\n        const fields = select ? Object.keys(select).map(k => `\"${k}\"`).join(', ') : '*'\n        const row = await queryOne(\n          `SELECT ${fields} FROM \"${table}\" WHERE \"${key}\" = $1 LIMIT 1`,\n          [value]\n        )\n        return row ? toCamelCase(row) : null\n      },\n      \n      async findMany({ where, select, orderBy, take, skip }: any = {}) {\n        const params: any[] = []\n        const fields = select ? Object.keys(select).map(k => `\"${k}\"`).join(', ') : '*'\n        let sql = `SELECT ${fields} FROM \"${table}\"`\n\n        if (where) {\n          const conditions: string[] = []\n          for (const [key, value] of Object.entries(where)) {\n            if (value === null) {\n              conditions.push(`\"${key}\" IS NULL`)\n            } else if (typeof value === 'object' && value !== null) {\n              // Handle various operators\n              if ('in' in value) {\n                const placeholders = (value as any).in.map((_: any, i: number) => `$${params.length + i + 1}`).join(', ')\n                params.push(...(value as any).in)\n                conditions.push(`\"${key}\" IN (${placeholders})`)\n              } else if ('notIn' in value) {\n                const placeholders = (value as any).notIn.map((_: any, i: number) => `$${params.length + i + 1}`).join(', ')\n                params.push(...(value as any).notIn)\n                conditions.push(`\"${key}\" NOT IN (${placeholders})`)\n              } else if ('lt' in value) {\n                params.push((value as any).lt)\n                conditions.push(`\"${key}\" < $${params.length}`)\n              } else if ('lte' in value) {\n                params.push((value as any).lte)\n                conditions.push(`\"${key}\" <= $${params.length}`)\n              } else if ('gt' in value) {\n                params.push((value as any).gt)\n                conditions.push(`\"${key}\" > $${params.length}`)\n              } else if ('gte' in value) {\n                params.push((value as any).gte)\n                conditions.push(`\"${key}\" >= $${params.length}`)\n              } else if ('contains' in value) {\n                params.push(`%${(value as any).contains}%`)\n                conditions.push(`\"${key}\" ILIKE $${params.length}`)\n              } else if ('startsWith' in value) {\n                params.push(`${(value as any).startsWith}%`)\n                conditions.push(`\"${key}\" ILIKE $${params.length}`)\n              } else if ('endsWith' in value) {\n                params.push(`%${(value as any).endsWith}`)\n                conditions.push(`\"${key}\" ILIKE $${params.length}`)\n              } else if ('not' in value) {\n                params.push((value as any).not)\n                conditions.push(`\"${key}\" != $${params.length}`)\n              } else {\n                // Fallback: treat as direct value\n                params.push(value)\n                conditions.push(`\"${key}\" = $${params.length}`)\n              }\n            } else {\n              params.push(value)\n              conditions.push(`\"${key}\" = $${params.length}`)\n            }\n          }\n          if (conditions.length) sql += ` WHERE ${conditions.join(' AND ')}`\n        }\n\n        if (orderBy) {\n          const orderClauses: string[] = []\n          for (const [field, dir] of Object.entries(orderBy)) {\n            orderClauses.push(`\"${field}\" ${(dir as string).toUpperCase()}`)\n          }\n          sql += ` ORDER BY ${orderClauses.join(', ')}`\n        }\n\n        if (take) sql += ` LIMIT ${take}`\n        if (skip) sql += ` OFFSET ${skip}`\n\n        const rows = await query(sql, params)\n        return rows.map(r => toCamelCase(r))\n      },\n      \n      async findFirst({ where, select, orderBy }: any) {\n        // Use findMany with take: 1 to reuse the logic\n        const result = await this.findMany({ where, select, orderBy, take: 1 })\n        return result.length > 0 ? result[0] : null\n      },\n      \n      async count({ where }: any = {}) {\n        const params: any[] = []\n        let sql = `SELECT COUNT(*) as cnt FROM \"${table}\"`\n\n        if (where) {\n          const conditions: string[] = []\n          for (const [key, value] of Object.entries(where)) {\n            if (value === null) {\n              conditions.push(`\"${key}\" IS NULL`)\n            } else if (typeof value === 'object' && value !== null) {\n              // Handle operators for count\n              if ('in' in value) {\n                const placeholders = (value as any).in.map((_: any, i: number) => `$${params.length + i + 1}`).join(', ')\n                params.push(...(value as any).in)\n                conditions.push(`\"${key}\" IN (${placeholders})`)\n              } else if ('not' in value) {\n                params.push((value as any).not)\n                conditions.push(`\"${key}\" != $${params.length}`)\n              } else {\n                params.push(value)\n                conditions.push(`\"${key}\" = $${params.length}`)\n              }\n            } else {\n              params.push(value)\n              conditions.push(`\"${key}\" = $${params.length}`)\n            }\n          }\n          if (conditions.length) sql += ` WHERE ${conditions.join(' AND ')}`\n        }\n\n        const row = await queryOne<any>(sql, params)\n        return row ? parseInt(row.cnt) : 0\n      },\n      \n      async create({ data, select }: any) {\n        const keys = Object.keys(data)\n        const values = Object.values(data)\n        const placeholders = keys.map((_, i) => `$${i + 1}`).join(', ')\n        const keyString = keys.map(k => `\"${k}\"`).join(', ')\n        const fields = select ? Object.keys(select).map(k => `\"${k}\"`).join(', ') : '*'\n        \n        const row = await queryOne(\n          `INSERT INTO \"${table}\" (${keyString}) VALUES (${placeholders}) RETURNING ${fields}`,\n          values\n        )\n        return row ? toCamelCase(row) : null\n      },\n      \n      async update({ where, data, select }: any) {\n        const params: any[] = []\n        const sets: string[] = []\n\n        // Build SET clause\n        for (const [key, value] of Object.entries(data)) {\n          if (value !== undefined) {\n            if (typeof value === 'object' && value !== null) {\n              // Handle increment/decrement operations\n              if ('increment' in value) {\n                params.push((value as any).increment)\n                sets.push(`\"${key}\" = COALESCE(\"${key}\", 0) + $${params.length}`)\n              } else if ('decrement' in value) {\n                params.push((value as any).decrement)\n                sets.push(`\"${key}\" = COALESCE(\"${key}\", 0) - $${params.length}`)\n              } else {\n                // Regular object value\n                params.push(JSON.stringify(value))\n                sets.push(`\"${key}\" = $${params.length}`)\n              }\n            } else {\n              params.push(value)\n              sets.push(`\"${key}\" = $${params.length}`)\n            }\n          }\n        }\n\n        // Build WHERE clause\n        const whereConditions: string[] = []\n        for (const [key, value] of Object.entries(where)) {\n          params.push(value)\n          whereConditions.push(`\"${key}\" = $${params.length}`)\n        }\n\n        const fields = select ? Object.keys(select).map(k => `\"${k}\"`).join(', ') : '*'\n        const row = await queryOne(\n          `UPDATE \"${table}\" SET ${sets.join(', ')} WHERE ${whereConditions.join(' AND ')} RETURNING ${fields}`,\n          params\n        )\n        return row ? toCamelCase(row) : null\n      },\n      \n      async delete({ where }: any) {\n        const [key, value] = Object.entries(where)[0] as [string, any]\n        await execute(`DELETE FROM \"${table}\" WHERE \"${key}\" = $1`, [value])\n        return {}\n      },\n      \n      async deleteMany({ where }: any = {}) {\n        const params: any[] = []\n        let sql = `DELETE FROM \"${table}\"`\n        \n        if (where) {\n          const conditions: string[] = []\n          for (const [key, value] of Object.entries(where)) {\n            params.push(value)\n            conditions.push(`\"${key}\" = $${params.length}`)\n          }\n          if (conditions.length) sql += ` WHERE ${conditions.join(' AND ')}`\n        }\n        \n        const count = await execute(sql, params)\n        return { count }\n      },\n      \n      async aggregate({ where, _sum, _count }: any) {\n        const params: any[] = []\n        const aggs: string[] = []\n        \n        if (_sum) {\n          Object.keys(_sum).forEach(field => {\n            aggs.push(`SUM(\"${field}\") as sum_${field}`)\n          })\n        }\n        if (_count) aggs.push('COUNT(*) as cnt')\n        \n        let sql = `SELECT ${aggs.join(', ')} FROM \"${table}\"`\n        \n        if (where) {\n          const conditions: string[] = []\n          for (const [key, value] of Object.entries(where)) {\n            params.push(value)\n            conditions.push(`\"${key}\" = $${params.length}`)\n          }\n          if (conditions.length) sql += ` WHERE ${conditions.join(' AND ')}`\n        }\n        \n        const row = await queryOne<any>(sql, params)\n        const result: any = {}\n        if (_sum && row) {\n          result._sum = {}\n          Object.keys(_sum).forEach(field => {\n            result._sum[field] = row[`sum_${field}`] ? parseFloat(row[`sum_${field}`]) : 0\n          })\n        }\n        if (_count && row) result._count = row.cnt ? parseInt(row.cnt) : 0\n        return result\n      },\n      \n      async groupBy({ by, _count, _sum, where }: any) {\n        const params: any[] = []\n        const fields = (Array.isArray(by) ? by : [by]).map(f => `\"${f}\"`)\n        const aggs: string[] = []\n        \n        if (_count) aggs.push('COUNT(*) as cnt')\n        if (_sum) {\n          Object.keys(_sum).forEach(field => {\n            aggs.push(`SUM(\"${field}\") as sum_${field}`)\n          })\n        }\n        \n        let sql = `SELECT ${fields.join(', ')}${aggs.length ? ', ' + aggs.join(', ') : ''} FROM \"${table}\"`\n        \n        if (where) {\n          const conditions: string[] = []\n          for (const [key, value] of Object.entries(where)) {\n            params.push(value)\n            conditions.push(`\"${key}\" = $${params.length}`)\n          }\n          if (conditions.length) sql += ` WHERE ${conditions.join(' AND ')}`\n        }\n        \n        sql += ` GROUP BY ${fields.join(', ')}`\n        const rows = await query(sql, params)\n        \n        return rows.map((row: any) => {\n          const transformed: any = {}\n          (Array.isArray(by) ? by : [by]).forEach(field => {\n            transformed[field] = row[field]\n          })\n          if (_count) transformed._count = row.cnt ? parseInt(row.cnt) : 0\n          if (_sum) {\n            transformed._sum = {}\n            Object.keys(_sum).forEach(field => {\n              transformed._sum[field] = row[`sum_${field}`] ? parseFloat(row[`sum_${field}`]) : 0\n            })\n          }\n          return transformed\n        })\n      },\n      \n      async upsert({ where, create, update }: any) {\n        const existing = await this.findUnique({ where })\n        return existing ? this.update({ where, data: update }) : this.create({ data: create })\n      }\n    }\n  }\n})\n\n// Support for await transaction\nexport const $transaction = transaction\n\nexport default {\n  query,\n  queryOne,\n  queryScalar,\n  execute,\n  transaction,\n  disconnect,\n  pool,\n  toCamelCase,\n  toSnakeCase,\n  prisma,\n  $transaction,\n}"],"names":[],"mappings":"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"}},
    {"offset": {"line": 723, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/LENOVO/Desktop/nsc-test/vercel-download/src/utils/server-helpers.ts"],"sourcesContent":["/**\n * Server-only helper functions\n * These use Node.js modules and should only be imported in API routes\n */\n\nimport bcrypt from 'bcrypt'\nimport jwt, { SignOptions, Secret } from 'jsonwebtoken'\nimport crypto from 'crypto'\nimport { JwtPayload } from '@/types/api'\nimport { queryOne, execute, transaction } from '@/lib/db'\n\n/**\n * Hash password\n */\nexport async function hashPassword(password: string): Promise<string> {\n  return await bcrypt.hash(password, 10)\n}\n\n/**\n * Compare password\n */\nexport async function comparePassword(\n  password: string,\n  hash: string\n): Promise<boolean> {\n  return await bcrypt.compare(password, hash)\n}\n\n/**\n * Generate JWT token\n */\nexport function generateToken(payload: Partial<JwtPayload>, expiresIn: string = '24h'): string {\n  if (!process.env.JWT_SECRET) {\n    throw new Error('JWT_SECRET is not defined in environment variables')\n  }\n  // Cast secret to Secret to satisfy TypeScript overloads\n  const secret: Secret = process.env.JWT_SECRET as Secret || 'fallback-secret'\n  // jwt.sign typings are picky about the secret type and options; cast to any\n  return jwt.sign(payload as any, secret as any, { expiresIn } as any);\n}\n\n/**\n * Generate refresh token\n */\nexport function generateRefreshToken(payload: Partial<JwtPayload>): string {\n  if (!process.env.JWT_REFRESH_SECRET) {\n    throw new Error('JWT_REFRESH_SECRET is not defined in environment variables')\n  }\n  const tokenPayload = {\n    ...payload,\n    type: 'refresh'\n  }\n  const refreshSecret: Secret = process.env.JWT_REFRESH_SECRET as Secret || 'fallback-refresh-secret'\n  return jwt.sign(tokenPayload as any, refreshSecret, { expiresIn: '7d' });\n}\n\n/**\n * Verify JWT token\n */\nexport function verifyToken(token: string): JwtPayload | null {\n  try {\n    if (!process.env.JWT_SECRET) {\n      throw new Error('JWT_SECRET is not defined in environment variables')\n    }\n    const decoded = jwt.verify(token, process.env.JWT_SECRET);\n    if (typeof decoded === 'string') {\n      return null;\n    }\n    return decoded as JwtPayload;\n  } catch (error) {\n    return null\n  }\n}\n\n/**\n * Verify refresh token\n */\nexport function verifyRefreshToken(token: string): JwtPayload | null {\n  try {\n    if (!process.env.JWT_REFRESH_SECRET) {\n      throw new Error('JWT_REFRESH_SECRET is not defined in environment variables')\n    }\n    const decoded = jwt.verify(token, process.env.JWT_REFRESH_SECRET);\n    if (typeof decoded === 'string') {\n      return null;\n    }\n    return decoded as JwtPayload;\n  } catch (error) {\n    return null\n  }\n}\n\n/**\n * Generate random token\n */\nexport function generateRandomToken(): string {\n  return crypto.randomBytes(32).toString('hex')\n}\n\n/**\n * Generate unique referral code (DEPRECATED - use getNextReferralCode instead)\n * Kept for backward compatibility\n */\nexport function generateReferralCode(username: string): string {\n  const random = crypto.randomBytes(3).toString('hex').toUpperCase()\n  const userPrefix = username.substring(0, 3).toUpperCase()\n  return `${userPrefix}${random}`\n}\n\n/**\n * Get next sequential referral code (NSCREF1001, NSCREF1002, etc.)\n * This is the code users share with others\n * Uses a transaction to prevent race conditions\n */\nexport async function getNextReferralCode(): Promise<string> {\n  // Use a transaction to ensure atomicity and prevent race conditions\n  const result = await transaction(async (client: any) => {\n    // First, try to find the existing counter\n    let counter = await queryOne<any>(\n      `SELECT * FROM \"ReferralCounter\" WHERE \"counterType\" = 'NSCREF'`,\n      []\n    );\n\n    // If counter doesn't exist, create it with initial value\n    if (!counter) {\n      counter = await queryOne<any>(\n        `INSERT INTO \"ReferralCounter\" (\"counterType\", \"currentValue\") \n         VALUES ('NSCREF', 1001) RETURNING *`,\n        []\n      );\n    } else {\n      // Increment the counter\n      counter = await queryOne<any>(\n        `UPDATE \"ReferralCounter\" SET \"currentValue\" = \"currentValue\" + 1 \n         WHERE \"counterType\" = 'NSCREF' RETURNING *`,\n        []\n      );\n    }\n\n    return counter;\n  });\n  \n  // The result is the counter object\n  const counter = result;\n  \n  // Double-check that the code is unique\n  const codeToUse = `NSCREF${counter.currentValue}`;\n  const existingUser = await queryOne<any>(\n    `SELECT * FROM \"User\" WHERE \"referralCode\" = $1`,\n    [codeToUse]\n  );\n  \n  // In the extremely unlikely case of a collision, add a random suffix\n  if (existingUser) {\n    const randomSuffix = Math.floor(Math.random() * 1000).toString().padStart(3, '0');\n    return `NSCREF${counter.currentValue}_${randomSuffix}`;\n  }\n  \n  return codeToUse;\n}\n\n// NEWNCS function has been completely removed as it's no longer needed\n// All users must now register with a valid referral code\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 860, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/LENOVO/Desktop/nsc-test/vercel-download/src/lib/cors.ts"],"sourcesContent":["import { NextResponse } from 'next/server'\n\n// Get allowed origins from environment or use localhost for development\nconst getAllowedOrigin = () => {\n  const allowedOrigins = process.env.ALLOWED_ORIGINS?.split(',') || [\n    process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000'\n  ]\n\n  // In production, never allow all origins\n  if (process.env.NODE_ENV === 'production' && allowedOrigins.includes('*')) {\n    throw new Error('CORS: Wildcard origin (*) is not allowed in production')\n  }\n\n  return allowedOrigins[0] // Return first allowed origin\n}\n\nexport function corsHeaders() {\n  return {\n    'Access-Control-Allow-Origin': getAllowedOrigin(),\n    'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',\n    'Access-Control-Allow-Headers': 'Content-Type, Authorization',\n    'Access-Control-Allow-Credentials': 'true', // Required for cookies\n  }\n}\n\nexport function handleCors(response: NextResponse) {\n  Object.entries(corsHeaders()).forEach(([key, value]) => {\n    response.headers.set(key, value)\n  })\n  return response\n}\n\nexport function handleOptions() {\n  return new NextResponse(null, {\n    status: 200,\n    headers: corsHeaders(),\n  })\n}\n"],"names":[],"mappings":";;;;;;;;AAAA;;AAEA,wEAAwE;AACxE,MAAM,mBAAmB;IACvB,MAAM,iBAAiB,QAAQ,GAAG,CAAC,eAAe,EAAE,MAAM,QAAQ;QAChE,6DAAmC;KACpC;IAED,yCAAyC;IACzC,IAAI,oDAAyB,gBAAgB,eAAe,QAAQ,CAAC;;IAIrE,OAAO,cAAc,CAAC,EAAE,CAAC,8BAA8B;;AACzD;AAEO,SAAS;IACd,OAAO;QACL,+BAA+B;QAC/B,gCAAgC;QAChC,gCAAgC;QAChC,oCAAoC;IACtC;AACF;AAEO,SAAS,WAAW,QAAsB;IAC/C,OAAO,OAAO,CAAC,eAAe,OAAO,CAAC,CAAC,CAAC,KAAK,MAAM;QACjD,SAAS,OAAO,CAAC,GAAG,CAAC,KAAK;IAC5B;IACA,OAAO;AACT;AAEO,SAAS;IACd,OAAO,IAAI,gJAAY,CAAC,MAAM;QAC5B,QAAQ;QACR,SAAS;IACX;AACF"}},
    {"offset": {"line": 905, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/LENOVO/Desktop/nsc-test/vercel-download/src/lib/logger.ts"],"sourcesContent":["/**\r\n * Development logger utility\r\n * Only logs in development environment to avoid console overhead in production\r\n */\r\n\r\nconst isDevelopment = process.env.NODE_ENV === 'development'\r\n\r\nexport const logger = {\r\n  log: (...args: any[]) => {\r\n    if (isDevelopment) {\r\n      console.log(...args)\r\n    }\r\n  },\r\n  \r\n  error: (...args: any[]) => {\r\n    if (isDevelopment) {\r\n      console.error(...args)\r\n    }\r\n  },\r\n  \r\n  warn: (...args: any[]) => {\r\n    if (isDevelopment) {\r\n      console.warn(...args)\r\n    }\r\n  },\r\n  \r\n  info: (...args: any[]) => {\r\n    if (isDevelopment) {\r\n      console.info(...args)\r\n    }\r\n  },\r\n  \r\n  debug: (...args: any[]) => {\r\n    if (isDevelopment) {\r\n      console.debug(...args)\r\n    }\r\n  }\r\n}\r\n\r\n// For critical production errors that should always be logged\r\nexport const productionLogger = {\r\n  error: (...args: any[]) => {\r\n    console.error(...args)\r\n  }\r\n}\r\n"],"names":[],"mappings":"AAAA;;;CAGC;;;;;;AAED,MAAM,gBAAgB,oDAAyB;AAExC,MAAM,SAAS;IACpB,KAAK,CAAC,GAAG;QACP,wCAAmB;YACjB,QAAQ,GAAG,IAAI;QACjB;IACF;IAEA,OAAO,CAAC,GAAG;QACT,wCAAmB;YACjB,QAAQ,KAAK,IAAI;QACnB;IACF;IAEA,MAAM,CAAC,GAAG;QACR,wCAAmB;YACjB,QAAQ,IAAI,IAAI;QAClB;IACF;IAEA,MAAM,CAAC,GAAG;QACR,wCAAmB;YACjB,QAAQ,IAAI,IAAI;QAClB;IACF;IAEA,OAAO,CAAC,GAAG;QACT,wCAAmB;YACjB,QAAQ,KAAK,IAAI;QACnB;IACF;AACF;AAGO,MAAM,mBAAmB;IAC9B,OAAO,CAAC,GAAG;QACT,QAAQ,KAAK,IAAI;IACnB;AACF"}},
    {"offset": {"line": 953, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/LENOVO/Desktop/nsc-test/vercel-download/src/lib/audit-logger.ts"],"sourcesContent":["/**\r\n * Audit Logging Service\r\n * Tracks all security-sensitive and administrative actions\r\n */\r\n\r\nimport pool from '@/lib/db-connection'\r\n\r\nexport type AuditAction = \r\n  | 'LOGIN_SUCCESS'\r\n  | 'LOGIN_FAILED'\r\n  | 'LOGOUT'\r\n  | 'PASSWORD_CHANGE'\r\n  | 'EMAIL_CHANGE'\r\n  | 'TWO_FACTOR_ENABLED'\r\n  | 'TWO_FACTOR_DISABLED'\r\n  | 'ACCOUNT_LOCKED'\r\n  | 'ACCOUNT_UNLOCKED'\r\n  | 'BRUTE_FORCE_BLOCKED'\r\n  | 'USER_CREATED'\r\n  | 'USER_UPDATED'\r\n  | 'USER_DELETED'\r\n  | 'USER_BLOCKED'\r\n  | 'USER_UNBLOCKED'\r\n  | 'PACKAGE_CREATED'\r\n  | 'PACKAGE_UPDATED'\r\n  | 'PACKAGE_DELETED'\r\n  | 'PACKAGE_ACTIVATED'\r\n  | 'PAYMENT_RECEIVED'\r\n  | 'PAYMENT_CONFIRMED'\r\n  | 'PAYMENT_FAILED'\r\n  | 'WITHDRAWAL_REQUESTED'\r\n  | 'WITHDRAWAL_APPROVED'\r\n  | 'WITHDRAWAL_REJECTED'\r\n  | 'KYC_SUBMITTED'\r\n  | 'KYC_APPROVED'\r\n  | 'KYC_REJECTED'\r\n  | 'ADMIN_ACTION'\r\n  | 'PERMISSION_CHANGED'\r\n  | 'SETTINGS_UPDATED'\r\n\r\nexport interface AuditLogEntry {\r\n  userId?: string\r\n  action: AuditAction\r\n  details: Record<string, any>\r\n  ipAddress?: string\r\n  userAgent?: string\r\n  severity?: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL'\r\n}\r\n\r\n/**\r\n * Create audit log entry\r\n */\r\nexport async function createAuditLog(entry: AuditLogEntry): Promise<void> {\r\n  const client = await pool.connect()\r\n  try {\r\n    await client.query(\r\n      `INSERT INTO \"AuditLog\" (\r\n        \"userId\", \r\n        \"action\", \r\n        \"metadata\", \r\n        \"ipAddress\", \r\n        \"userAgent\", \r\n        \"createdAt\"\r\n      ) VALUES ($1, $2, $3, $4, $5, NOW())`,\r\n      [\r\n        entry.userId || null,\r\n        entry.action,\r\n        JSON.stringify(entry.details || {}),\r\n        entry.ipAddress || null,\r\n        entry.userAgent || null\r\n      ]\r\n    )\r\n  } catch (error) {\r\n    // Don't fail the request if audit logging fails\r\n    console.error('Failed to create audit log:', error)\r\n  } finally {\r\n    client.release()\r\n  }\r\n}\r\n\r\n/**\r\n * Log authentication events\r\n */\r\nexport async function logAuthEvent(\r\n  action: 'LOGIN_SUCCESS' | 'LOGIN_FAILED' | 'LOGOUT',\r\n  userId: string | undefined,\r\n  details: Record<string, any>,\r\n  request?: Request\r\n): Promise<void> {\r\n  const ipAddress = request?.headers.get('x-forwarded-for') || \r\n                   request?.headers.get('x-real-ip') || \r\n                   'unknown'\r\n  const userAgent = request?.headers.get('user-agent') || 'unknown'\r\n\r\n  await createAuditLog({\r\n    userId,\r\n    action,\r\n    details,\r\n    ipAddress,\r\n    userAgent,\r\n    severity: action === 'LOGIN_FAILED' ? 'MEDIUM' : 'LOW'\r\n  })\r\n}\r\n\r\n/**\r\n * Log admin actions\r\n */\r\nexport async function logAdminAction(\r\n  adminId: string,\r\n  action: string,\r\n  targetUserId: string | undefined,\r\n  details: Record<string, any>,\r\n  request?: Request\r\n): Promise<void> {\r\n  const ipAddress = request?.headers.get('x-forwarded-for') || \r\n                   request?.headers.get('x-real-ip') || \r\n                   'unknown'\r\n  const userAgent = request?.headers.get('user-agent') || 'unknown'\r\n\r\n  await createAuditLog({\r\n    userId: adminId,\r\n    action: 'ADMIN_ACTION',\r\n    details: {\r\n      ...details,\r\n      targetUserId,\r\n      adminAction: action\r\n    },\r\n    ipAddress,\r\n    userAgent,\r\n    severity: 'HIGH'\r\n  })\r\n}\r\n\r\n/**\r\n * Log payment events\r\n */\r\nexport async function logPaymentEvent(\r\n  action: 'PAYMENT_RECEIVED' | 'PAYMENT_CONFIRMED' | 'PAYMENT_FAILED',\r\n  userId: string | undefined,\r\n  details: Record<string, any>\r\n): Promise<void> {\r\n  await createAuditLog({\r\n    userId,\r\n    action,\r\n    details,\r\n    severity: action === 'PAYMENT_FAILED' ? 'MEDIUM' : 'LOW'\r\n  })\r\n}\r\n\r\n/**\r\n * Log security events\r\n */\r\nexport async function logSecurityEvent(\r\n  action: AuditAction,\r\n  userId: string | undefined,\r\n  details: Record<string, any>,\r\n  severity: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL' = 'HIGH'\r\n): Promise<void> {\r\n  await createAuditLog({\r\n    userId,\r\n    action,\r\n    details,\r\n    severity\r\n  })\r\n}\r\n\r\n/**\r\n * Query audit logs (admin only)\r\n */\r\nexport async function getAuditLogs(filters: {\r\n  userId?: string\r\n  action?: AuditAction\r\n  startDate?: Date\r\n  endDate?: Date\r\n  severity?: string\r\n  limit?: number\r\n  offset?: number\r\n}): Promise<any[]> {\r\n  const client = await pool.connect()\r\n  try {\r\n    const conditions: string[] = []\r\n    const params: any[] = []\r\n    let paramIndex = 1\r\n\r\n    if (filters.userId) {\r\n      conditions.push(`\"userId\" = $${paramIndex++}`)\r\n      params.push(filters.userId)\r\n    }\r\n\r\n    if (filters.action) {\r\n      conditions.push(`action = $${paramIndex++}`)\r\n      params.push(filters.action)\r\n    }\r\n\r\n    if (filters.startDate) {\r\n      conditions.push(`\"createdAt\" >= $${paramIndex++}`)\r\n      params.push(filters.startDate)\r\n    }\r\n\r\n    if (filters.endDate) {\r\n      conditions.push(`\"createdAt\" <= $${paramIndex++}`)\r\n      params.push(filters.endDate)\r\n    }\r\n\r\n    if (filters.severity) {\r\n      conditions.push(`severity = $${paramIndex++}`)\r\n      params.push(filters.severity)\r\n    }\r\n\r\n    const whereClause = conditions.length > 0 ? `WHERE ${conditions.join(' AND ')}` : ''\r\n    const limit = filters.limit || 100\r\n    const offset = filters.offset || 0\r\n\r\n    params.push(limit)\r\n    params.push(offset)\r\n\r\n    const result = await client.query(\r\n      `SELECT * FROM \"AuditLog\" ${whereClause} ORDER BY \"createdAt\" DESC LIMIT $${paramIndex++} OFFSET $${paramIndex++}`,\r\n      params\r\n    )\r\n\r\n    return result.rows\r\n  } catch (error) {\r\n    console.error('Failed to query audit logs:', error)\r\n    return []\r\n  } finally {\r\n    client.release()\r\n  }\r\n}\r\n\r\n/**\r\n * Initialize audit logs table (run this once during deployment)\r\n * NOTE: This is not needed if you run the NEONDB_SECURITY_MIGRATION.sql\r\n */\r\nexport async function initializeAuditLogsTable(): Promise<void> {\r\n  const client = await pool.connect()\r\n  try {\r\n    await client.query(`\r\n      CREATE TABLE IF NOT EXISTS \"AuditLog\" (\r\n        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\r\n        \"userId\" TEXT,\r\n        action VARCHAR(100) NOT NULL,\r\n        details JSONB,\r\n        \"ipAddress\" VARCHAR(45),\r\n        \"userAgent\" TEXT,\r\n        severity VARCHAR(20) DEFAULT 'LOW',\r\n        \"createdAt\" TIMESTAMP DEFAULT NOW()\r\n      )\r\n    `)\r\n\r\n    await client.query(`\r\n      CREATE INDEX IF NOT EXISTS idx_audit_user_id ON \"AuditLog\"(\"userId\")\r\n    `)\r\n    await client.query(`\r\n      CREATE INDEX IF NOT EXISTS idx_audit_action ON \"AuditLog\"(action)\r\n    `)\r\n    await client.query(`\r\n      CREATE INDEX IF NOT EXISTS idx_audit_created_at ON \"AuditLog\"(\"createdAt\")\r\n    `)\r\n    await client.query(`\r\n      CREATE INDEX IF NOT EXISTS idx_audit_severity ON \"AuditLog\"(severity)\r\n    `)\r\n\r\n    console.log('‚úì Audit logs table initialized successfully')\r\n  } catch (error) {\r\n    console.error('Failed to initialize audit logs table:', error)\r\n  } finally {\r\n    client.release()\r\n  }\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1125, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/LENOVO/Desktop/nsc-test/vercel-download/src/lib/neon-serverless.ts"],"sourcesContent":["import { neon } from '@neondatabase/serverless'\r\n\r\n/**\r\n * Neon Serverless Database Connection\r\n * Optimized for Neon's serverless environment\r\n */\r\n\r\nlet sql: ReturnType<typeof neon> | null = null\r\n\r\nexport function getNeonSQL() {\r\n  if (!sql) {\r\n    const databaseUrl = process.env.DATABASE_URL\r\n    if (!databaseUrl) {\r\n      throw new Error('DATABASE_URL is not defined in environment variables')\r\n    }\r\n    \r\n    console.log('üöÄ Initializing Neon Serverless SQL connection')\r\n    sql = neon(databaseUrl)\r\n  }\r\n  return sql\r\n}\r\n\r\n/**\r\n * Execute a query with Neon Serverless Driver\r\n * This bypasses traditional connection pooling issues\r\n * Uses tagged template literals as required by Neon\r\n */\r\nexport async function neonQuery<T = any>(\r\n  query: string, \r\n  params: any[] = []\r\n): Promise<T[]> {\r\n  const sql = getNeonSQL()\r\n  \r\n  try {\r\n    console.log(`üîç Executing Neon query: ${query.substring(0, 100)}...`)\r\n    \r\n    // For Neon serverless, we need to use sql.query() for parameterized queries\r\n    const result = await sql.query(query, params)\r\n    \r\n    const resultArray = Array.isArray(result) ? result : [result]\r\n    console.log(`‚úÖ Neon query completed, returned ${resultArray.length} rows`)\r\n    return resultArray as T[]\r\n    \r\n  } catch (error) {\r\n    console.error('‚ùå Neon query failed:', error.message)\r\n    console.error('Query:', query)\r\n    console.error('Params:', params)\r\n    throw error\r\n  }\r\n}\r\n\r\n/**\r\n * Execute a prepared statement with Neon Serverless Driver\r\n * For queries that need parameter binding\r\n */\r\nexport async function neonQueryPrepared<T = any>(\r\n  queryTemplate: (sql: ReturnType<typeof neon>) => Promise<T[]>\r\n): Promise<T[]> {\r\n  const sql = getNeonSQL()\r\n  \r\n  try {\r\n    console.log(`üîç Executing Neon prepared query...`)\r\n    \r\n    const result = await queryTemplate(sql)\r\n    \r\n    console.log(`‚úÖ Neon prepared query completed, returned ${result.length} rows`)\r\n    return result\r\n    \r\n  } catch (error) {\r\n    console.error('‚ùå Neon prepared query failed:', error.message)\r\n    throw error\r\n  }\r\n}\r\n\r\nexport default {\r\n  getNeonSQL,\r\n  neonQuery,\r\n  neonQueryPrepared\r\n}"],"names":[],"mappings":";;;;;;;;;;AAAA;;AAEA;;;CAGC,GAED,IAAI,MAAsC;AAEnC,SAAS;IACd,IAAI,CAAC,KAAK;QACR,MAAM,cAAc,QAAQ,GAAG,CAAC,YAAY;QAC5C,IAAI,CAAC,aAAa;YAChB,MAAM,IAAI,MAAM;QAClB;QAEA,QAAQ,GAAG,CAAC;QACZ,MAAM,IAAA,gKAAI,EAAC;IACb;IACA,OAAO;AACT;AAOO,eAAe,UACpB,KAAa,EACb,SAAgB,EAAE;IAElB,MAAM,MAAM;IAEZ,IAAI;QACF,QAAQ,GAAG,CAAC,CAAC,yBAAyB,EAAE,MAAM,SAAS,CAAC,GAAG,KAAK,GAAG,CAAC;QAEpE,4EAA4E;QAC5E,MAAM,SAAS,MAAM,IAAI,KAAK,CAAC,OAAO;QAEtC,MAAM,cAAc,MAAM,OAAO,CAAC,UAAU,SAAS;YAAC;SAAO;QAC7D,QAAQ,GAAG,CAAC,CAAC,iCAAiC,EAAE,YAAY,MAAM,CAAC,KAAK,CAAC;QACzE,OAAO;IAET,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,wBAAwB,MAAM,OAAO;QACnD,QAAQ,KAAK,CAAC,UAAU;QACxB,QAAQ,KAAK,CAAC,WAAW;QACzB,MAAM;IACR;AACF;AAMO,eAAe,kBACpB,aAA6D;IAE7D,MAAM,MAAM;IAEZ,IAAI;QACF,QAAQ,GAAG,CAAC,CAAC,mCAAmC,CAAC;QAEjD,MAAM,SAAS,MAAM,cAAc;QAEnC,QAAQ,GAAG,CAAC,CAAC,0CAA0C,EAAE,OAAO,MAAM,CAAC,KAAK,CAAC;QAC7E,OAAO;IAET,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,iCAAiC,MAAM,OAAO;QAC5D,MAAM;IACR;AACF;uCAEe;IACb;IACA;IACA;AACF"}},
    {"offset": {"line": 1193, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/LENOVO/Desktop/nsc-test/vercel-download/src/services/loginSecurityService.ts"],"sourcesContent":["import { queryWithTimeout } from '@/lib/db-connection'\r\nimport { neonQuery } from '@/lib/neon-serverless'\r\nimport { NextRequest } from 'next/server'\r\n\r\ninterface LoginAttemptResult {\r\n  isBlocked: boolean\r\n  blockReason?: string\r\n  failedAttempts: number\r\n  lastAttemptAt?: Date\r\n  blockUntil?: Date\r\n}\r\n\r\ninterface LoginStats {\r\n  date: string\r\n  totalAttempts: number\r\n  successfulLogins: number\r\n  failedLogins: number\r\n  uniqueIPs: number\r\n  uniqueEmails: number\r\n  successRate: number\r\n}\r\n\r\n/**\r\n * Security service for login attempt tracking and brute-force protection\r\n */\r\nexport class LoginSecurityService {\r\n  // Configuration\r\n  private static readonly MAX_ATTEMPTS_EMAIL = 5\r\n  private static readonly MAX_ATTEMPTS_IP = 10 // IP gets double limit\r\n  private static readonly WINDOW_MINUTES = 15\r\n\r\n  /**\r\n   * Record a login attempt (success or failure)\r\n   */\r\n  static async recordAttempt(\r\n    email: string,\r\n    ipAddress: string,\r\n    userAgent: string,\r\n    success: boolean,\r\n    failureReason?: string\r\n  ): Promise<string> {\r\n    try {\r\n      const result = await queryWithTimeout(\r\n        'SELECT record_login_attempt($1, $2, $3, $4, $5) as attempt_id',\r\n        [email.toLowerCase(), ipAddress, userAgent, success, failureReason],\r\n        20000 // Increased to 20 seconds for cloud database\r\n      )\r\n      \r\n      const attemptId = result.rows[0]?.attempt_id\r\n      \r\n      if (success) {\r\n        console.log(`‚úÖ Successful login recorded for ${email} from ${ipAddress}`)\r\n      } else {\r\n        console.log(`‚ùå Failed login recorded for ${email} from ${ipAddress}: ${failureReason}`)\r\n      }\r\n      \r\n      return attemptId\r\n    } catch (error) {\r\n      console.error('‚ùå Error recording login attempt:', error)\r\n      throw new Error(`Failed to record login attempt: ${error}`)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if email or IP should be blocked due to too many failed attempts\r\n   */\r\n  static async checkBlocking(\r\n    email: string,\r\n    ipAddress: string\r\n  ): Promise<LoginAttemptResult> {\r\n    try {\r\n      console.log(`üîç Checking login blocking for ${email} from ${ipAddress}`)\r\n      \r\n      // Use Neon serverless driver for better reliability\r\n      const result = await neonQuery(\r\n        'SELECT * FROM check_login_blocking($1, $2, $3, $4)',\r\n        [\r\n          email.toLowerCase(),\r\n          ipAddress,\r\n          this.MAX_ATTEMPTS_EMAIL,\r\n          this.WINDOW_MINUTES\r\n        ]\r\n      )\r\n      \r\n      if (result.length === 0) {\r\n        console.log(`‚úÖ No blocking found for ${email}`)\r\n        return {\r\n          isBlocked: false,\r\n          failedAttempts: 0\r\n        }\r\n      }\r\n      \r\n      const row = result[0]\r\n      \r\n      const blockingResult = {\r\n        isBlocked: row.isBlocked,\r\n        blockReason: row.blockReason,\r\n        failedAttempts: parseInt(row.failedAttempts),\r\n        lastAttemptAt: row.lastAttemptAt ? new Date(row.lastAttemptAt) : undefined,\r\n        blockUntil: row.blockUntil ? new Date(row.blockUntil) : undefined\r\n      }\r\n      \r\n      if (blockingResult.isBlocked) {\r\n        console.log(`üö´ Login blocked for ${email}: ${blockingResult.blockReason}`)\r\n      } else {\r\n        console.log(`‚úÖ Login allowed for ${email} (${blockingResult.failedAttempts} failed attempts)`)\r\n      }\r\n      \r\n      return blockingResult\r\n    } catch (error) {\r\n      console.error(`‚ùå Error checking login blocking for ${email}:`, error.message)\r\n      \r\n      // On database error, allow login but log the issue\r\n      console.warn(`‚ö†Ô∏è Allowing login due to database error for ${email}`)\r\n      return {\r\n        isBlocked: false,\r\n        failedAttempts: 0\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get login statistics for the last N days\r\n   */\r\n  static async getLoginStats(daysBack: number = 7): Promise<LoginStats[]> {\r\n    try {\r\n      const result = await queryWithTimeout(\r\n        'SELECT * FROM get_login_stats($1)',\r\n        [daysBack],\r\n        20000 // Increased to 20 seconds for cloud database\r\n      )\r\n      \r\n      return result.rows.map(row => ({\r\n        date: row.date,\r\n        totalAttempts: parseInt(row.totalAttempts),\r\n        successfulLogins: parseInt(row.successfulLogins),\r\n        failedLogins: parseInt(row.failedLogins),\r\n        uniqueIPs: parseInt(row.uniqueIPs),\r\n        uniqueEmails: parseInt(row.uniqueEmails),\r\n        successRate: parseFloat(row.successRate)\r\n      }))\r\n    } catch (error) {\r\n      console.error('‚ùå Error getting login stats:', error)\r\n      throw new Error(`Failed to get login stats: ${error}`)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clean up old login attempts (call this periodically)\r\n   */\r\n  static async cleanupOldAttempts(daysToKeep: number = 30): Promise<number> {\r\n    try {\r\n      const result = await queryWithTimeout(\r\n        'SELECT cleanup_old_login_attempts($1) as deleted_count',\r\n        [daysToKeep],\r\n        20000 // Increased to 20 seconds for cloud database\r\n      )\r\n      \r\n      const deletedCount = parseInt(result.rows[0]?.deleted_count || 0)\r\n      console.log(`üßπ Cleaned up ${deletedCount} old login attempts`)\r\n      \r\n      return deletedCount\r\n    } catch (error) {\r\n      console.error('‚ùå Error cleaning up old login attempts:', error)\r\n      throw new Error(`Failed to cleanup old attempts: ${error}`)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Extract IP address from request (handles proxies)\r\n   */\r\n  static getClientIP(request: NextRequest): string {\r\n    // Check various headers for real IP (in order of preference)\r\n    const forwardedFor = request.headers.get('x-forwarded-for')\r\n    const realIP = request.headers.get('x-real-ip')\r\n    const cfConnectingIP = request.headers.get('cf-connecting-ip') // Cloudflare\r\n    \r\n    if (cfConnectingIP) return cfConnectingIP\r\n    if (realIP) return realIP\r\n    if (forwardedFor) {\r\n      // x-forwarded-for can contain multiple IPs, first one is the client\r\n      return forwardedFor.split(',')[0].trim()\r\n    }\r\n    \r\n    // Fallback to localhost\r\n    return '127.0.0.1'\r\n  }\r\n\r\n  /**\r\n   * Get user agent from request\r\n   */\r\n  static getUserAgent(request: NextRequest): string {\r\n    return request.headers.get('user-agent') || 'Unknown'\r\n  }\r\n\r\n  /**\r\n   * Check if an IP address appears to be suspicious\r\n   * (This is a basic implementation - you could enhance with IP reputation services)\r\n   */\r\n  static isSuspiciousIP(ipAddress: string): boolean {\r\n    // Basic checks for obviously suspicious IPs\r\n    if (ipAddress === '127.0.0.1' || ipAddress === 'localhost') {\r\n      return false // Local development\r\n    }\r\n    \r\n    // Add more sophisticated checks here:\r\n    // - Known malicious IP lists\r\n    // - Tor exit nodes\r\n    // - VPN detection\r\n    // - Geolocation checks\r\n    \r\n    return false\r\n  }\r\n\r\n  /**\r\n   * Generate security report for admin dashboard\r\n   */\r\n  static async generateSecurityReport(): Promise<{\r\n    recentStats: LoginStats[]\r\n    summary: {\r\n      totalAttempts: number\r\n      successRate: number\r\n      uniqueIPs: number\r\n      suspiciousActivity: boolean\r\n    }\r\n  }> {\r\n    try {\r\n      const stats = await this.getLoginStats(7) // Last 7 days\r\n      \r\n      const summary = stats.reduce(\r\n        (acc, day) => ({\r\n          totalAttempts: acc.totalAttempts + day.totalAttempts,\r\n          successfulLogins: acc.successfulLogins + day.successfulLogins,\r\n          uniqueIPs: Math.max(acc.uniqueIPs, day.uniqueIPs)\r\n        }),\r\n        { totalAttempts: 0, successfulLogins: 0, uniqueIPs: 0 }\r\n      )\r\n      \r\n      const overallSuccessRate = summary.totalAttempts > 0 \r\n        ? (summary.successfulLogins / summary.totalAttempts) * 100 \r\n        : 100\r\n      \r\n      // Simple suspicious activity detection\r\n      const suspiciousActivity = overallSuccessRate < 50 || // Low success rate\r\n        stats.some(day => day.failedLogins > 100) // High failed attempts in a day\r\n      \r\n      return {\r\n        recentStats: stats,\r\n        summary: {\r\n          totalAttempts: summary.totalAttempts,\r\n          successRate: Math.round(overallSuccessRate * 100) / 100,\r\n          uniqueIPs: summary.uniqueIPs,\r\n          suspiciousActivity\r\n        }\r\n      }\r\n    } catch (error) {\r\n      console.error('‚ùå Error generating security report:', error)\r\n      throw new Error(`Failed to generate security report: ${error}`)\r\n    }\r\n  }\r\n}\r\n\r\nexport default LoginSecurityService"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1399, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/LENOVO/Desktop/nsc-test/vercel-download/src/services/sessionManagementService.ts"],"sourcesContent":["import { queryWithTimeout } from '../lib/db-connection';\r\n\r\ninterface SessionData {\r\n  sessionId: string;\r\n  userId: string;\r\n  ipAddress: string;\r\n  userAgent: string;\r\n  isActive: boolean;\r\n  createdAt: Date;\r\n  lastActiveAt: Date;\r\n  expiresAt: Date;\r\n}\r\n\r\ninterface SessionStats {\r\n  activeSessions: number;\r\n  uniqueUsers: number;\r\n  sessionsLast24h: number;\r\n}\r\n\r\nexport class SessionManagementService {\r\n  /**\r\n   * Create a new session for a user\r\n   */\r\n  static async createSession(\r\n    userId: string,\r\n    tokenHash: string,\r\n    refreshTokenHash: string,\r\n    ipAddress: string,\r\n    userAgent: string,\r\n    expiresAt: Date = new Date(Date.now() + 30 * 24 * 60 * 60 * 1000) // 30 days default\r\n  ): Promise<SessionData | null> {\r\n    try {\r\n      const result = await queryWithTimeout(\r\n        `SELECT create_session($1::TEXT, $2::TEXT, $3::TEXT, $4::TEXT, $5::TEXT, $6::TIMESTAMP) as session_id`,\r\n        [userId, tokenHash, refreshTokenHash, ipAddress, userAgent, expiresAt],\r\n        5000\r\n      );\r\n\r\n      if (result.rows && result.rows.length > 0) {\r\n        const sessionId = result.rows[0].session_id;\r\n        \r\n        // Return a basic session object\r\n        return {\r\n          sessionId: sessionId,\r\n          userId: userId,\r\n          ipAddress: ipAddress,\r\n          userAgent: userAgent,\r\n          isActive: true,\r\n          createdAt: new Date(),\r\n          lastActiveAt: new Date(),\r\n          expiresAt: expiresAt\r\n        };\r\n      }\r\n\r\n      return null;\r\n    } catch (error) {\r\n      console.error('Error creating session:', error);\r\n      \r\n      // For now, don't throw an error to allow login to complete\r\n      // This allows the system to work while we debug the session creation\r\n      console.warn('Session creation failed, but allowing login to continue');\r\n      return {\r\n        sessionId: 'fallback-session-' + Date.now(),\r\n        userId: userId,\r\n        ipAddress: ipAddress,\r\n        userAgent: userAgent,\r\n        isActive: true,\r\n        createdAt: new Date(),\r\n        lastActiveAt: new Date(),\r\n        expiresAt: expiresAt\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Validate and update session activity\r\n   */\r\n  static async validateSession(tokenHash: string): Promise<SessionData | null> {\r\n    try {\r\n      const result = await queryWithTimeout(\r\n        `SELECT * FROM validate_session($1::TEXT)`,\r\n        [tokenHash],\r\n        5000\r\n      );\r\n\r\n      if (result.rows && result.rows.length > 0) {\r\n        const session = result.rows[0];\r\n        \r\n        // Return null if session is not valid\r\n        if (!session.isValid) {\r\n          return null;\r\n        }\r\n\r\n        return {\r\n          sessionId: session.sessionId,\r\n          userId: session.userId,\r\n          ipAddress: session.ipAddress,\r\n          userAgent: session.userAgent,\r\n          isActive: session.isValid,\r\n          createdAt: new Date(session.createdAt),\r\n          lastActiveAt: new Date(session.lastUsedAt),\r\n          expiresAt: new Date(session.expiresAt)\r\n        };\r\n      }\r\n\r\n      return null;\r\n    } catch (error) {\r\n      console.error('Error validating session:', error);\r\n      return null; // Fail gracefully for validation\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Revoke a specific session\r\n   */\r\n  static async revokeSession(sessionId: string): Promise<boolean> {\r\n    try {\r\n      const result = await queryWithTimeout(\r\n        `SELECT revoke_session($1) as revoked`,\r\n        [sessionId],\r\n        5000\r\n      );\r\n\r\n      return result.rows?.[0]?.revoked === true;\r\n    } catch (error) {\r\n      console.error('Error revoking session:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Revoke all sessions for a user\r\n   */\r\n  static async revokeAllUserSessions(userId: string): Promise<number> {\r\n    try {\r\n      const result = await queryWithTimeout(\r\n        `SELECT revoke_all_user_sessions($1) as revoked_count`,\r\n        [userId],\r\n        5000\r\n      );\r\n\r\n      return result.rows?.[0]?.revoked_count || 0;\r\n    } catch (error) {\r\n      console.error('Error revoking all user sessions:', error);\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Revoke all other sessions except the current one\r\n   */\r\n  static async revokeOtherSessions(userId: string, currentSessionId: string): Promise<number> {\r\n    try {\r\n      const result = await queryWithTimeout(\r\n        `SELECT revoke_other_sessions($1, $2) as revoked_count`,\r\n        [userId, currentSessionId],\r\n        5000\r\n      );\r\n\r\n      return result.rows?.[0]?.revoked_count || 0;\r\n    } catch (error) {\r\n      console.error('Error revoking other sessions:', error);\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get all active sessions for a user\r\n   */\r\n  static async getUserSessions(userId: string): Promise<SessionData[]> {\r\n    try {\r\n      const result = await queryWithTimeout(\r\n        `SELECT * FROM get_user_sessions($1::TEXT)`,\r\n        [userId],\r\n        5000\r\n      );\r\n\r\n      if (result.rows && result.rows.length > 0) {\r\n        return result.rows.map(session => ({\r\n          sessionId: session.sessionId,\r\n          userId: userId,\r\n          ipAddress: session.ipAddress,\r\n          userAgent: session.userAgent,\r\n          isActive: session.isActive,\r\n          createdAt: new Date(session.createdAt),\r\n          lastActiveAt: new Date(session.lastUsedAt),\r\n          expiresAt: new Date(session.expiresAt)\r\n        }));\r\n      }\r\n\r\n      return [];\r\n    } catch (error) {\r\n      console.error('Error getting user sessions:', error);\r\n      return [];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clean up expired sessions\r\n   */\r\n  static async cleanupExpiredSessions(): Promise<number> {\r\n    try {\r\n      const result = await queryWithTimeout(\r\n        `SELECT cleanup_expired_sessions() as cleaned_count`,\r\n        [],\r\n        10000 // Longer timeout for cleanup operation\r\n      );\r\n\r\n      return result.rows?.[0]?.cleaned_count || 0;\r\n    } catch (error) {\r\n      console.error('Error cleaning up expired sessions:', error);\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get session statistics\r\n   */\r\n  static async getSessionStats(): Promise<SessionStats> {\r\n    try {\r\n      const result = await queryWithTimeout(\r\n        `SELECT * FROM get_session_stats()`,\r\n        [],\r\n        5000\r\n      );\r\n\r\n      if (result.rows && result.rows.length > 0) {\r\n        const stats = result.rows[0];\r\n        return {\r\n          activeSessions: stats.active_sessions || 0,\r\n          uniqueUsers: stats.unique_users || 0,\r\n          sessionsLast24h: stats.sessions_last_24h || 0\r\n        };\r\n      }\r\n\r\n      return {\r\n        activeSessions: 0,\r\n        uniqueUsers: 0,\r\n        sessionsLast24h: 0\r\n      };\r\n    } catch (error) {\r\n      console.error('Error getting session stats:', error);\r\n      return {\r\n        activeSessions: 0,\r\n        uniqueUsers: 0,\r\n        sessionsLast24h: 0\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Generate a secure session ID\r\n   */\r\n  static generateSessionId(): string {\r\n    const crypto = require('crypto');\r\n    return crypto.randomBytes(32).toString('hex');\r\n  }\r\n\r\n  /**\r\n   * Extract session ID from JWT token or cookie\r\n   */\r\n  static extractSessionId(token?: string): string | null {\r\n    if (!token) return null;\r\n\r\n    try {\r\n      // If it's a JWT token, decode to get session ID\r\n      const jwt = require('jsonwebtoken');\r\n      const decoded = jwt.decode(token) as any;\r\n      return decoded?.sessionId || null;\r\n    } catch (error) {\r\n      // If not JWT, treat as direct session ID\r\n      return token;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Middleware helper to validate session in requests\r\n   */\r\n  static async validateRequestSession(\r\n    authHeader?: string,\r\n    sessionCookie?: string\r\n  ): Promise<{ isValid: boolean; session?: SessionData; userId?: string }> {\r\n    try {\r\n      // Try to extract session ID from Authorization header or cookie\r\n      let sessionId: string | null = null;\r\n\r\n      if (authHeader?.startsWith('Bearer ')) {\r\n        sessionId = this.extractSessionId(authHeader.substring(7));\r\n      } else if (sessionCookie) {\r\n        sessionId = this.extractSessionId(sessionCookie);\r\n      }\r\n\r\n      if (!sessionId) {\r\n        return { isValid: false };\r\n      }\r\n\r\n      const session = await this.validateSession(sessionId);\r\n      \r\n      if (!session) {\r\n        return { isValid: false };\r\n      }\r\n\r\n      return {\r\n        isValid: true,\r\n        session,\r\n        userId: session.userId\r\n      };\r\n    } catch (error) {\r\n      console.error('Error validating request session:', error);\r\n      return { isValid: false };\r\n    }\r\n  }\r\n}\r\n\r\nexport default SessionManagementService;"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1654, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/LENOVO/Desktop/nsc-test/vercel-download/src/lib/db-health-manager.ts"],"sourcesContent":["import { Pool } from 'pg'\r\nimport { warmupConnection } from './db-connection'\r\n\r\n// Database connection health checker\r\nexport class DatabaseHealthChecker {\r\n  private static lastHealthCheck = 0\r\n  private static isHealthy = false\r\n  private static readonly HEALTH_CHECK_INTERVAL = 30000 // 30 seconds\r\n\r\n  static async checkHealth(): Promise<boolean> {\r\n    const now = Date.now()\r\n    \r\n    // Return cached result if check was recent\r\n    if (now - this.lastHealthCheck < this.HEALTH_CHECK_INTERVAL) {\r\n      return this.isHealthy\r\n    }\r\n\r\n    try {\r\n      console.log('üè• Checking database health...')\r\n      \r\n      // Import here to avoid circular dependencies\r\n      const { testConnection } = await import('./db-connection')\r\n      this.isHealthy = await testConnection()\r\n      this.lastHealthCheck = now\r\n      \r\n      if (this.isHealthy) {\r\n        console.log('‚úÖ Database health check passed')\r\n      } else {\r\n        console.warn('‚ö†Ô∏è Database health check failed')\r\n      }\r\n      \r\n      return this.isHealthy\r\n    } catch (error) {\r\n      console.error('‚ùå Database health check error:', error.message)\r\n      this.isHealthy = false\r\n      this.lastHealthCheck = now\r\n      return false\r\n    }\r\n  }\r\n\r\n  static async ensureConnection(): Promise<void> {\r\n    const isHealthy = await this.checkHealth()\r\n    \r\n    if (!isHealthy) {\r\n      console.log('üîß Attempting to restore database connection...')\r\n      \r\n      try {\r\n        // Try to warmup the connection\r\n        await warmupConnection()\r\n        \r\n        // Check again\r\n        const restored = await this.checkHealth()\r\n        \r\n        if (restored) {\r\n          console.log('‚úÖ Database connection restored')\r\n        } else {\r\n          console.error('‚ùå Failed to restore database connection')\r\n          throw new Error('Database connection could not be restored')\r\n        }\r\n      } catch (error) {\r\n        console.error('‚ùå Error restoring database connection:', error.message)\r\n        throw error\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n// Connection manager for critical operations\r\nexport class CriticalConnectionManager {\r\n  private static activeConnections = 0\r\n  private static readonly MAX_CONCURRENT_CONNECTIONS = 1 // Very conservative for Neon\r\n\r\n  static async executeWithConnection<T>(\r\n    operation: () => Promise<T>,\r\n    operationName: string = 'Unknown operation'\r\n  ): Promise<T> {\r\n    // Check if we're at connection limit\r\n    if (this.activeConnections >= this.MAX_CONCURRENT_CONNECTIONS) {\r\n      console.warn(`‚ö†Ô∏è Connection limit reached, queuing ${operationName}`)\r\n      \r\n      // Wait for a connection to free up\r\n      await this.waitForAvailableConnection()\r\n    }\r\n\r\n    this.activeConnections++\r\n    console.log(`üîó Starting ${operationName} (active: ${this.activeConnections}/${this.MAX_CONCURRENT_CONNECTIONS})`)\r\n\r\n    try {\r\n      // Ensure database is healthy before executing\r\n      await DatabaseHealthChecker.ensureConnection()\r\n      \r\n      // Execute the operation with timeout\r\n      const result = await Promise.race([\r\n        operation(),\r\n        new Promise<never>((_, reject) => \r\n          setTimeout(() => reject(new Error(`Operation timeout: ${operationName}`)), 30000)\r\n        )\r\n      ])\r\n\r\n      console.log(`‚úÖ Completed ${operationName}`)\r\n      return result\r\n    } catch (error) {\r\n      console.error(`‚ùå Failed ${operationName}:`, error.message)\r\n      throw error\r\n    } finally {\r\n      this.activeConnections--\r\n      console.log(`üîå Released connection for ${operationName} (active: ${this.activeConnections}/${this.MAX_CONCURRENT_CONNECTIONS})`)\r\n    }\r\n  }\r\n\r\n  private static async waitForAvailableConnection(): Promise<void> {\r\n    return new Promise<void>((resolve) => {\r\n      const checkInterval = setInterval(() => {\r\n        if (this.activeConnections < this.MAX_CONCURRENT_CONNECTIONS) {\r\n          clearInterval(checkInterval)\r\n          resolve()\r\n        }\r\n      }, 100) // Check every 100ms\r\n      \r\n      // Timeout after 10 seconds\r\n      setTimeout(() => {\r\n        clearInterval(checkInterval)\r\n        resolve() // Proceed anyway after timeout\r\n      }, 10000)\r\n    })\r\n  }\r\n}\r\n\r\nexport default {\r\n  DatabaseHealthChecker,\r\n  CriticalConnectionManager\r\n}"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1785, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/LENOVO/Desktop/nsc-test/vercel-download/src/app/api/admin/login/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server'\r\nimport { comparePassword, generateToken, generateRefreshToken } from '@/utils/server-helpers'\r\nimport { query, queryOne, queryScalar, execute, transaction } from \"@/lib/db\"\r\nimport { handleOptions, handleCors } from '@/lib/cors'\r\nimport { logger } from '@/lib/logger'\r\nimport { logAuthEvent } from '@/lib/audit-logger'\r\nimport LoginSecurityService from '@/services/loginSecurityService'\r\nimport SessionManagementService from '@/services/sessionManagementService'\r\nimport { CriticalConnectionManager } from '@/lib/db-health-manager'\r\nimport speakeasy from 'speakeasy'\r\n\r\nexport async function OPTIONS(request: NextRequest) {\r\n  return handleOptions()\r\n}\r\n\r\nexport async function POST(request: NextRequest) {\r\n  try {\r\n    const body = await request.json()\r\n    const { email, password, twoFactorCode } = body\r\n\r\n    if (!email || !password) {\r\n      return NextResponse.json(\r\n        { error: 'Email and password are required' },\r\n        { status: 400 }\r\n      )\r\n    }\r\n\r\n    const normalizedEmail = email.toLowerCase().trim()\r\n\r\n    // Get client IP and user agent\r\n    const clientIP = request.headers.get('x-forwarded-for')?.split(',')[0] || \r\n      request.headers.get('x-real-ip') || \r\n      '127.0.0.1'\r\n    const userAgent = request.headers.get('user-agent') || 'Unknown'\r\n\r\n    // Check for security blocks (same security as regular login)\r\n    const blockingCheck = await CriticalConnectionManager.executeWithConnection(\r\n      () => LoginSecurityService.checkBlocking(normalizedEmail, clientIP),\r\n      'Admin login blocking check'\r\n    )\r\n    \r\n    if (blockingCheck.isBlocked) {\r\n      const minutesRemaining = Math.ceil((blockingCheck.blockUntil!.getTime() - Date.now()) / (60 * 1000))\r\n      \r\n      await logAuthEvent('LOGIN_FAILED', undefined, {\r\n        email: normalizedEmail,\r\n        reason: 'IP/Email blocked',\r\n        ipAddress: clientIP,\r\n        blockedUntil: blockingCheck.blockUntil\r\n      }, request)\r\n      \r\n      return NextResponse.json(\r\n        { \r\n          error: `Too many failed login attempts. Please try again in ${minutesRemaining} minute(s).`,\r\n          blockedUntil: blockingCheck.blockUntil\r\n        },\r\n        { status: 429 }\r\n      )\r\n    }\r\n\r\n    // Find admin user\r\n    const user = await CriticalConnectionManager.executeWithConnection(\r\n      () => queryOne(\r\n        'SELECT * FROM \"User\" WHERE \"email\" = $1 AND \"isAdmin\" = true',\r\n        [normalizedEmail]\r\n      ),\r\n      'Admin user lookup'\r\n    )\r\n\r\n    if (!user) {\r\n      // Record failed login attempt\r\n      await LoginSecurityService.recordAttempt(\r\n        normalizedEmail,\r\n        clientIP,\r\n        userAgent,\r\n        false,\r\n        'Invalid admin credentials'\r\n      )\r\n\r\n      await logAuthEvent('LOGIN_FAILED', undefined, {\r\n        email: normalizedEmail,\r\n        reason: 'Invalid admin credentials',\r\n        ipAddress: clientIP\r\n      }, request)\r\n\r\n      return NextResponse.json(\r\n        { error: 'Invalid admin credentials' },\r\n        { status: 401 }\r\n      )\r\n    }\r\n\r\n    // Verify password\r\n    const isValidPassword = await comparePassword(password, user.password)\r\n    if (!isValidPassword) {\r\n      // Record failed login attempt\r\n      await LoginSecurityService.recordAttempt(\r\n        normalizedEmail,\r\n        clientIP,\r\n        userAgent,\r\n        false,\r\n        'Invalid password'\r\n      )\r\n\r\n      await logAuthEvent('LOGIN_FAILED', user.id, {\r\n        email: normalizedEmail,\r\n        reason: 'Invalid password',\r\n        ipAddress: clientIP\r\n      }, request)\r\n\r\n      return NextResponse.json(\r\n        { error: 'Invalid admin credentials' },\r\n        { status: 401 }\r\n      )\r\n    }\r\n\r\n    // Check 2FA if enabled\r\n    if (user.twoFactorEnabled && user.twoFactorSecret) {\r\n      if (!twoFactorCode) {\r\n        return NextResponse.json(\r\n          { error: '2FA code required', requires2FA: true },\r\n          { status: 401 }\r\n        )\r\n      }\r\n\r\n      const isValid = speakeasy.totp.verify({\r\n        secret: user.twoFactorSecret,\r\n        encoding: 'base32',\r\n        token: twoFactorCode,\r\n        window: 2\r\n      })\r\n\r\n      if (!isValid) {\r\n        await LoginSecurityService.recordAttempt(\r\n          normalizedEmail,\r\n          clientIP,\r\n          userAgent,\r\n          false,\r\n          'Invalid 2FA code'\r\n        )\r\n\r\n        return NextResponse.json(\r\n          { error: 'Invalid 2FA code' },\r\n          { status: 401 }\r\n        )\r\n      }\r\n    }\r\n\r\n    // Generate session ID and tokens\r\n    const sessionId = SessionManagementService.generateSessionId()\r\n    const token = generateToken({ \r\n      userId: user.id, \r\n      email: user.email, \r\n      isAdmin: true, \r\n      sessionId \r\n    })\r\n    const refreshToken = generateRefreshToken({ \r\n      userId: user.id, \r\n      sessionId \r\n    })\r\n\r\n    // Create session record\r\n    try {\r\n      const session = await SessionManagementService.createSession(\r\n        user.id,\r\n        token,\r\n        refreshToken,\r\n        clientIP,\r\n        userAgent,\r\n        new Date(Date.now() + 30 * 24 * 60 * 60 * 1000) // 30 days\r\n      )\r\n      \r\n      if (session) {\r\n        console.log(`√¢≈ì‚Ä¶ Admin session created: ${session.sessionId}`)\r\n      }\r\n    } catch (sessionError) {\r\n      logger.error('Failed to create admin session:', sessionError)\r\n      // Continue with login but log the error\r\n    }\r\n\r\n    // Record successful login\r\n    await LoginSecurityService.recordAttempt(\r\n      normalizedEmail,\r\n      clientIP,\r\n      userAgent,\r\n      true,\r\n      'Admin login successful'\r\n    )\r\n\r\n    await logAuthEvent('LOGIN_SUCCESS', user.id, {\r\n      email: user.email,\r\n      isAdmin: true,\r\n      twoFactorUsed: user.twoFactorEnabled,\r\n      ipAddress: clientIP\r\n    }, request)\r\n\r\n    // Return user data\r\n    const userData = {\r\n      id: user.id,\r\n      email: user.email,\r\n      fullName: user.fullName,\r\n      isAdmin: true,\r\n      isEmailVerified: user.isEmailVerified,\r\n      twoFactorEnabled: user.twoFactorEnabled\r\n    }\r\n\r\n    const response = NextResponse.json({\r\n      success: true,\r\n      message: 'Admin login successful',\r\n      user: userData,\r\n      token,\r\n      refreshToken\r\n    })\r\n\r\n    // Set consistent cookie names (same as regular login)\r\n    response.cookies.set('token', token, {\r\n      httpOnly: true,\r\n      secure: process.env.NODE_ENV === 'production',\r\n      sameSite: 'lax',\r\n      path: '/',\r\n      maxAge: 60 * 60 * 24 // 24 hours\r\n    })\r\n\r\n    response.cookies.set('refreshToken', refreshToken, {\r\n      httpOnly: true,\r\n      secure: process.env.NODE_ENV === 'production',\r\n      sameSite: 'lax',\r\n      path: '/',\r\n      maxAge: 60 * 60 * 24 * 7 // 7 days\r\n    })\r\n\r\n    return handleCors(response)\r\n\r\n  } catch (error: any) {\r\n    logger.error('Admin login error:', error)\r\n    return NextResponse.json(\r\n      { error: 'Internal server error' },\r\n      { status: 500 }\r\n    )\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AAEO,eAAe,QAAQ,OAAoB;IAChD,OAAO,IAAA,8HAAa;AACtB;AAEO,eAAe,KAAK,OAAoB;IAC7C,IAAI;QACF,MAAM,OAAO,MAAM,QAAQ,IAAI;QAC/B,MAAM,EAAE,KAAK,EAAE,QAAQ,EAAE,aAAa,EAAE,GAAG;QAE3C,IAAI,CAAC,SAAS,CAAC,UAAU;YACvB,OAAO,gJAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAAkC,GAC3C;gBAAE,QAAQ;YAAI;QAElB;QAEA,MAAM,kBAAkB,MAAM,WAAW,GAAG,IAAI;QAEhD,+BAA+B;QAC/B,MAAM,WAAW,QAAQ,OAAO,CAAC,GAAG,CAAC,oBAAoB,MAAM,IAAI,CAAC,EAAE,IACpE,QAAQ,OAAO,CAAC,GAAG,CAAC,gBACpB;QACF,MAAM,YAAY,QAAQ,OAAO,CAAC,GAAG,CAAC,iBAAiB;QAEvD,6DAA6D;QAC7D,MAAM,gBAAgB,MAAM,6JAAyB,CAAC,qBAAqB,CACzE,IAAM,6IAAoB,CAAC,aAAa,CAAC,iBAAiB,WAC1D;QAGF,IAAI,cAAc,SAAS,EAAE;YAC3B,MAAM,mBAAmB,KAAK,IAAI,CAAC,CAAC,cAAc,UAAU,CAAE,OAAO,KAAK,KAAK,GAAG,EAAE,IAAI,CAAC,KAAK,IAAI;YAElG,MAAM,IAAA,wIAAY,EAAC,gBAAgB,WAAW;gBAC5C,OAAO;gBACP,QAAQ;gBACR,WAAW;gBACX,cAAc,cAAc,UAAU;YACxC,GAAG;YAEH,OAAO,gJAAY,CAAC,IAAI,CACtB;gBACE,OAAO,CAAC,oDAAoD,EAAE,iBAAiB,WAAW,CAAC;gBAC3F,cAAc,cAAc,UAAU;YACxC,GACA;gBAAE,QAAQ;YAAI;QAElB;QAEA,kBAAkB;QAClB,MAAM,OAAO,MAAM,6JAAyB,CAAC,qBAAqB,CAChE,IAAM,IAAA,uIAAQ,EACZ,gEACA;gBAAC;aAAgB,GAEnB;QAGF,IAAI,CAAC,MAAM;YACT,8BAA8B;YAC9B,MAAM,6IAAoB,CAAC,aAAa,CACtC,iBACA,UACA,WACA,OACA;YAGF,MAAM,IAAA,wIAAY,EAAC,gBAAgB,WAAW;gBAC5C,OAAO;gBACP,QAAQ;gBACR,WAAW;YACb,GAAG;YAEH,OAAO,gJAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAA4B,GACrC;gBAAE,QAAQ;YAAI;QAElB;QAEA,kBAAkB;QAClB,MAAM,kBAAkB,MAAM,IAAA,+IAAe,EAAC,UAAU,KAAK,QAAQ;QACrE,IAAI,CAAC,iBAAiB;YACpB,8BAA8B;YAC9B,MAAM,6IAAoB,CAAC,aAAa,CACtC,iBACA,UACA,WACA,OACA;YAGF,MAAM,IAAA,wIAAY,EAAC,gBAAgB,KAAK,EAAE,EAAE;gBAC1C,OAAO;gBACP,QAAQ;gBACR,WAAW;YACb,GAAG;YAEH,OAAO,gJAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAA4B,GACrC;gBAAE,QAAQ;YAAI;QAElB;QAEA,uBAAuB;QACvB,IAAI,KAAK,gBAAgB,IAAI,KAAK,eAAe,EAAE;YACjD,IAAI,CAAC,eAAe;gBAClB,OAAO,gJAAY,CAAC,IAAI,CACtB;oBAAE,OAAO;oBAAqB,aAAa;gBAAK,GAChD;oBAAE,QAAQ;gBAAI;YAElB;YAEA,MAAM,UAAU,+IAAS,CAAC,IAAI,CAAC,MAAM,CAAC;gBACpC,QAAQ,KAAK,eAAe;gBAC5B,UAAU;gBACV,OAAO;gBACP,QAAQ;YACV;YAEA,IAAI,CAAC,SAAS;gBACZ,MAAM,6IAAoB,CAAC,aAAa,CACtC,iBACA,UACA,WACA,OACA;gBAGF,OAAO,gJAAY,CAAC,IAAI,CACtB;oBAAE,OAAO;gBAAmB,GAC5B;oBAAE,QAAQ;gBAAI;YAElB;QACF;QAEA,iCAAiC;QACjC,MAAM,YAAY,iJAAwB,CAAC,iBAAiB;QAC5D,MAAM,QAAQ,IAAA,6IAAa,EAAC;YAC1B,QAAQ,KAAK,EAAE;YACf,OAAO,KAAK,KAAK;YACjB,SAAS;YACT;QACF;QACA,MAAM,eAAe,IAAA,oJAAoB,EAAC;YACxC,QAAQ,KAAK,EAAE;YACf;QACF;QAEA,wBAAwB;QACxB,IAAI;YACF,MAAM,UAAU,MAAM,iJAAwB,CAAC,aAAa,CAC1D,KAAK,EAAE,EACP,OACA,cACA,UACA,WACA,IAAI,KAAK,KAAK,GAAG,KAAK,KAAK,KAAK,KAAK,KAAK,MAAM,UAAU;;YAG5D,IAAI,SAAS;gBACX,QAAQ,GAAG,CAAC,CAAC,2BAA2B,EAAE,QAAQ,SAAS,EAAE;YAC/D;QACF,EAAE,OAAO,cAAc;YACrB,yHAAM,CAAC,KAAK,CAAC,mCAAmC;QAChD,wCAAwC;QAC1C;QAEA,0BAA0B;QAC1B,MAAM,6IAAoB,CAAC,aAAa,CACtC,iBACA,UACA,WACA,MACA;QAGF,MAAM,IAAA,wIAAY,EAAC,iBAAiB,KAAK,EAAE,EAAE;YAC3C,OAAO,KAAK,KAAK;YACjB,SAAS;YACT,eAAe,KAAK,gBAAgB;YACpC,WAAW;QACb,GAAG;QAEH,mBAAmB;QACnB,MAAM,WAAW;YACf,IAAI,KAAK,EAAE;YACX,OAAO,KAAK,KAAK;YACjB,UAAU,KAAK,QAAQ;YACvB,SAAS;YACT,iBAAiB,KAAK,eAAe;YACrC,kBAAkB,KAAK,gBAAgB;QACzC;QAEA,MAAM,WAAW,gJAAY,CAAC,IAAI,CAAC;YACjC,SAAS;YACT,SAAS;YACT,MAAM;YACN;YACA;QACF;QAEA,sDAAsD;QACtD,SAAS,OAAO,CAAC,GAAG,CAAC,SAAS,OAAO;YACnC,UAAU;YACV,QAAQ,oDAAyB;YACjC,UAAU;YACV,MAAM;YACN,QAAQ,KAAK,KAAK,GAAG,WAAW;QAClC;QAEA,SAAS,OAAO,CAAC,GAAG,CAAC,gBAAgB,cAAc;YACjD,UAAU;YACV,QAAQ,oDAAyB;YACjC,UAAU;YACV,MAAM;YACN,QAAQ,KAAK,KAAK,KAAK,EAAE,SAAS;QACpC;QAEA,OAAO,IAAA,2HAAU,EAAC;IAEpB,EAAE,OAAO,OAAY;QACnB,yHAAM,CAAC,KAAK,CAAC,sBAAsB;QACnC,OAAO,gJAAY,CAAC,IAAI,CACtB;YAAE,OAAO;QAAwB,GACjC;YAAE,QAAQ;QAAI;IAElB;AACF"}}]
}