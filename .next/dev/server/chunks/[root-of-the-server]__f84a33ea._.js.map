{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 106, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/LENOVO/Desktop/nsc-test/vercel-download/src/lib/db-connection.ts"],"sourcesContent":["import { Pool } from 'pg'\n\n// Load environment variables only in development\nif (process.env.NODE_ENV !== 'production') {\n  try {\n    const dotenv = require('dotenv')\n    dotenv.config()\n  } catch (error) {\n    // dotenv is optional, might not be installed in production\n    console.log('dotenv not available, using system environment variables')\n  }\n}\n\n// Parse DATABASE_URL to handle Neon and other providers\nconst getDatabaseConfig = () => {\n  const connectionString = process.env.DATABASE_URL\n\n  if (!connectionString) {\n    console.error('‚ùå DATABASE_URL is not defined in environment variables')\n    console.error('Please ensure your .env file contains a valid DATABASE_URL')\n    throw new Error('DATABASE_URL is not defined in environment variables')\n  }\n\n  // For Neon and other cloud providers, always use SSL\n  const isCloudProvider = connectionString.includes('neon.tech') ||\n                         connectionString.includes('supabase.co') ||\n                         connectionString.includes('amazonaws.com') ||\n                         connectionString.includes('azure.com')\n\n  // For Neon, we need specific SSL settings\n  const isNeon = connectionString.includes('neon.tech')\n\n  // SSL configuration based on provider\n  const sslConfig = isNeon\n    ? {\n        rejectUnauthorized: false,\n        ca: null,\n        checkServerIdentity: () => undefined\n      }\n    : { rejectUnauthorized: process.env.DB_SSL_REJECT_UNAUTHORIZED !== 'false' }\n\n  // Optimized configuration for NeonDB\n  return {\n    connectionString,\n    ssl: isCloudProvider ? sslConfig : false,\n    max: 20, // ‚úÖ Increased pool size for better concurrent request handling\n    min: 5, // ‚úÖ Keep more connections warm to avoid timeouts\n    idleTimeoutMillis: 60000, // 60 seconds idle timeout (increased)\n    connectionTimeoutMillis: 20000, // 20 seconds connection timeout (increased)\n    allowExitOnIdle: false, // ‚úÖ Don't exit on idle to maintain connections\n    statement_timeout: 60000, // 60 seconds (increased)\n    query_timeout: 60000, // 60 seconds (increased)\n    keepAlive: true, // ‚úÖ Keep connections alive\n    keepAliveInitialDelayMillis: 5000, // 5 seconds\n    // Additional Neon-specific optimizations\n    application_name: 'nsc-bot-platform',\n    idle_in_transaction_session_timeout: 120000 // 2 minutes (increased)\n  }\n}\n\n// Single pool instance - NO resets, NO lazy initialization\nlet pool: Pool | null = null;\nlet isInitializing = false;\n\nconst getPool = () => {\n  // Create pool only once\n  if (!pool && !isInitializing) {\n    isInitializing = true;\n    try {\n      pool = new Pool(getDatabaseConfig());\n\n      // Add error handling for the pool - DO NOT reset pool or exit process\n      pool.on('error', (err) => {\n        console.error('‚ùå Unexpected error on idle client:', err);\n        console.error('Connection will be removed from pool and recreated automatically');\n        // ‚úÖ Let pg handle reconnection automatically - don't reset pool\n      });\n\n      // Only log connection events when VERBOSE_DB_LOGS is set (not during build)\n      const isBuilding = process.env.NEXT_PHASE === 'phase-production-build';\n      const shouldLog = !isBuilding && (process.env.NODE_ENV !== 'production' || process.env.VERBOSE_DB_LOGS === 'true');\n\n      if (shouldLog) {\n        pool.on('connect', (client) => {\n          console.log('‚úÖ New client connected to NeonDB');\n        });\n\n        pool.on('remove', (client) => {\n          console.log('üîå Client removed from pool');\n        });\n      }\n\n      if (!isBuilding) {\n        console.log('üöÄ Database pool initialized for NeonDB');\n      }\n    } catch (error) {\n      isInitializing = false;\n      console.error('‚ùå Failed to initialize database pool:', error);\n      throw error;\n    } finally {\n      isInitializing = false;\n    }\n  }\n\n  // Wait for initialization if it's in progress\n  while (isInitializing && !pool) {\n    // Busy wait - this is acceptable because initialization is fast\n  }\n\n  return pool!;\n};\n\n// Test database connection\nexport async function testConnection() {\n  let client\n  try {\n    const poolInstance = getPool();\n    client = await poolInstance.connect()\n    const result = await client.query('SELECT NOW()')\n    console.log('Database connection successful:', result.rows[0])\n    return true\n  } catch (err) {\n    console.error('Database connection error:', err)\n    return false\n  } finally {\n    if (client) client.release()\n  }\n}\n\n// Warmup database connection - call this on server start (NOT during build)\nexport async function warmupConnection() {\n  // Skip warmup during build phase\n  const isBuilding = process.env.NEXT_PHASE === 'phase-production-build';\n  if (isBuilding) {\n    return;\n  }\n\n  console.log('üî• Warming up database connection...')\n\n  try {\n    // Try to establish a connection and run a simple query\n    const success = await testConnection()\n\n    if (success) {\n      console.log('‚úÖ Database connection warmed up successfully')\n\n      // Pre-establish a connection in the pool\n      const poolInstance = getPool();\n      const client = await poolInstance.connect()\n\n      // Keep the connection alive briefly then release\n      setTimeout(() => {\n        client.release()\n        console.log('üîå Warmup connection released')\n      }, 1000)\n\n    } else {\n      console.warn('‚ö†Ô∏è Database warmup failed, but continuing...')\n    }\n  } catch (error: any) {\n    console.warn('‚ö†Ô∏è Database warmup error:', error?.message || 'Unknown error')\n  }\n}\n\n// Export a proxy that lazily initializes the pool\nconst poolProxy = new Proxy({} as Pool, {\n  get(target, prop) {\n    const poolInstance = getPool();\n    return poolInstance[prop as keyof Pool];\n  }\n});\n\n/**\n * Get a database client with timeout protection\n * @param timeoutMs Timeout in milliseconds (default: 20000ms)\n * @returns Database client\n * @throws Error if connection times out or fails\n */\nexport async function getClientWithTimeout(timeoutMs: number = 20000) {\n  const poolInstance = getPool();\n  \n  return Promise.race([\n    poolInstance.connect(),\n    new Promise<never>((_, reject) => \n      setTimeout(() => reject(new Error(`Database connection timeout after ${timeoutMs}ms`)), timeoutMs)\n    )\n  ]);\n}\n\n/**\n * Execute a query with timeout protection\n * @param query SQL query string\n * @param params Query parameters\n * @param timeoutMs Query timeout in milliseconds (default: 20000ms)\n * @returns Query result\n */\nexport async function queryWithTimeout(query: string, params: any[] = [], timeoutMs: number = 20000) {\n  let client;\n  try {\n    client = await getClientWithTimeout(timeoutMs);\n    \n    const queryPromise = client.query(query, params);\n    const timeoutPromise = new Promise<never>((_, reject) => \n      setTimeout(() => reject(new Error(`Query timeout after ${timeoutMs}ms`)), timeoutMs)\n    );\n    \n    return await Promise.race([queryPromise, timeoutPromise]);\n  } finally {\n    if (client) {\n      client.release();\n    }\n  }\n}\n\n// Export the pool for use in other modules\nexport default poolProxy\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 295, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/LENOVO/Desktop/nsc-test/vercel-download/src/lib/db.ts"],"sourcesContent":["/**\n * Pure PostgreSQL Database Layer\n * NO PRISMA. NO ORM. Just direct SQL via pg driver.\n * Neon DB (Serverless PostgreSQL)\n */\n\nimport pool from './db-connection'\n\n// Helper to convert snake_case to camelCase\nfunction toCamelCase(obj: any): any {\n  if (Array.isArray(obj)) {\n    return obj.map(toCamelCase)\n  }\n  if (obj !== null && typeof obj === 'object') {\n    return Object.keys(obj).reduce((acc, key) => {\n      const camelKey = key.replace(/_([a-z])/g, (g) => g[1].toUpperCase())\n      acc[camelKey] = toCamelCase(obj[key])\n      return acc\n    }, {} as any)\n  }\n  return obj\n}\n\n// Helper to convert camelCase to snake_case\nfunction toSnakeCase(obj: any): any {\n  if (obj instanceof Date) return obj.toISOString()\n  if (Array.isArray(obj)) return obj.map(toSnakeCase)\n  if (obj !== null && typeof obj === 'object') {\n    const result: any = {}\n    for (const key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        result[key] = toSnakeCase(obj[key])\n      }\n    }\n    return result\n  }\n  return obj\n}\n\n/**\n * Execute any PostgreSQL query and return rows\n * @example\n * const users = await query<User>('SELECT * FROM \"User\" WHERE \"isActive\" = $1', [true])\n */\nexport async function query<T = any>(sql: string, params: any[] = []): Promise<T[]> {\n  // Validate that sql is actually a string\n  if (typeof sql !== 'string' || sql.trim().length === 0) {\n    const error = new Error('A query must have either text or a name. Supplying neither is unsupported.')\n    console.error('PostgreSQL Error:', {\n      message: error.message,\n      sql: sql,\n      code: undefined,\n    })\n    throw error\n  }\n\n  try {\n    const result = await pool.query(sql, params)\n    return result.rows as T[]\n  } catch (error: any) {\n    console.error('PostgreSQL Error:', {\n      message: error.message,\n      sql: typeof sql === 'string' ? sql.substring(0, 200) : sql,\n      code: error.code,\n    })\n    throw error\n  }\n}\n\n/**\n * Get a single row from query (or null)\n * @example\n * const user = await queryOne<User>('SELECT * FROM \"User\" WHERE \"id\" = $1', [userId])\n */\nexport async function queryOne<T = any>(sql: string, params: any[] = []): Promise<T | null> {\n  const rows = await query<T>(sql, params)\n  return rows.length > 0 ? rows[0] : null\n}\n\n/**\n * Get a single scalar value (for COUNT, SUM, MAX, AVG, etc.)\n * @example\n * const count = await queryScalar<number>('SELECT COUNT(*) as count FROM \"User\"')\n */\nexport async function queryScalar<T = any>(sql: string, params: any[] = []): Promise<T | null> {\n  const rows = await query<any>(sql, params)\n  if (rows.length === 0) return null\n  const firstValue = Object.values(rows[0])[0]\n  return firstValue as T\n}\n\n/**\n * Execute INSERT/UPDATE/DELETE query\n * Returns number of affected rows\n * @example\n * const count = await execute('UPDATE \"User\" SET \"isActive\" = $1 WHERE \"id\" = $2', [true, userId])\n */\nexport async function execute(sql: string, params: any[] = []): Promise<number> {\n  // Validate that sql is actually a string\n  if (typeof sql !== 'string' || sql.trim().length === 0) {\n    const error = new Error('A query must have either text or a name. Supplying neither is unsupported.')\n    console.error('PostgreSQL Error:', {\n      message: error.message,\n      sql: sql,\n      code: undefined,\n    })\n    throw error\n  }\n\n  try {\n    const result = await pool.query(sql, params)\n    return result.rowCount || 0\n  } catch (error: any) {\n    console.error('PostgreSQL Error:', {\n      message: error.message,\n      sql: typeof sql === 'string' ? sql.substring(0, 200) : sql,\n      code: error.code,\n    })\n    throw error\n  }\n}\n\n/**\n * Run multiple queries atomically in a transaction\n * Automatically COMMIT on success or ROLLBACK on error\n * @example\n * await transaction(async (client) => {\n *   await client.query('INSERT INTO \"User\" VALUES (...)')\n *   await client.query('UPDATE \"Package\" SET ...')\n * })\n */\nexport async function transaction<T>(\n  callback: (client: any) => Promise<T>\n): Promise<T> {\n  const client = await pool.connect()\n  try {\n    await client.query('BEGIN')\n    const result = await callback(client)\n    await client.query('COMMIT')\n    return result\n  } catch (error) {\n    await client.query('ROLLBACK')\n    throw error\n  } finally {\n    client.release()\n  }\n}\n\n/**\n * Disconnect from database (graceful shutdown)\n */\nexport async function disconnect(): Promise<void> {\n  await pool.end()\n}\n\n// Re-export pool for advanced use cases\nexport { pool }\n\n// Export helpers for use in refactored code\nexport { toCamelCase, toSnakeCase }\n\n/**\n * SQL translator - Converts SQL-style calls to pure queries\n * Translates ALL SQL calls to direct database queries underneath\n * This allows 60+ existing files to work while transitioning to pure SQL\n */\nexport const prisma: any = new Proxy({}, {\n  get: (target, table: string | symbol) => {\n    if (typeof table !== 'string') return undefined\n    \n    return {\n      async findUnique({ where, select }: any) {\n        const [key, value] = Object.entries(where)[0] as [string, any]\n        const fields = select ? Object.keys(select).map(k => `\"${k}\"`).join(', ') : '*'\n        const row = await queryOne(\n          `SELECT ${fields} FROM \"${table}\" WHERE \"${key}\" = $1 LIMIT 1`,\n          [value]\n        )\n        return row ? toCamelCase(row) : null\n      },\n      \n      async findMany({ where, select, orderBy, take, skip }: any = {}) {\n        const params: any[] = []\n        const fields = select ? Object.keys(select).map(k => `\"${k}\"`).join(', ') : '*'\n        let sql = `SELECT ${fields} FROM \"${table}\"`\n\n        if (where) {\n          const conditions: string[] = []\n          for (const [key, value] of Object.entries(where)) {\n            if (value === null) {\n              conditions.push(`\"${key}\" IS NULL`)\n            } else if (typeof value === 'object' && value !== null) {\n              // Handle various operators\n              if ('in' in value) {\n                const placeholders = (value as any).in.map((_: any, i: number) => `$${params.length + i + 1}`).join(', ')\n                params.push(...(value as any).in)\n                conditions.push(`\"${key}\" IN (${placeholders})`)\n              } else if ('notIn' in value) {\n                const placeholders = (value as any).notIn.map((_: any, i: number) => `$${params.length + i + 1}`).join(', ')\n                params.push(...(value as any).notIn)\n                conditions.push(`\"${key}\" NOT IN (${placeholders})`)\n              } else if ('lt' in value) {\n                params.push((value as any).lt)\n                conditions.push(`\"${key}\" < $${params.length}`)\n              } else if ('lte' in value) {\n                params.push((value as any).lte)\n                conditions.push(`\"${key}\" <= $${params.length}`)\n              } else if ('gt' in value) {\n                params.push((value as any).gt)\n                conditions.push(`\"${key}\" > $${params.length}`)\n              } else if ('gte' in value) {\n                params.push((value as any).gte)\n                conditions.push(`\"${key}\" >= $${params.length}`)\n              } else if ('contains' in value) {\n                params.push(`%${(value as any).contains}%`)\n                conditions.push(`\"${key}\" ILIKE $${params.length}`)\n              } else if ('startsWith' in value) {\n                params.push(`${(value as any).startsWith}%`)\n                conditions.push(`\"${key}\" ILIKE $${params.length}`)\n              } else if ('endsWith' in value) {\n                params.push(`%${(value as any).endsWith}`)\n                conditions.push(`\"${key}\" ILIKE $${params.length}`)\n              } else if ('not' in value) {\n                params.push((value as any).not)\n                conditions.push(`\"${key}\" != $${params.length}`)\n              } else {\n                // Fallback: treat as direct value\n                params.push(value)\n                conditions.push(`\"${key}\" = $${params.length}`)\n              }\n            } else {\n              params.push(value)\n              conditions.push(`\"${key}\" = $${params.length}`)\n            }\n          }\n          if (conditions.length) sql += ` WHERE ${conditions.join(' AND ')}`\n        }\n\n        if (orderBy) {\n          const orderClauses: string[] = []\n          for (const [field, dir] of Object.entries(orderBy)) {\n            orderClauses.push(`\"${field}\" ${(dir as string).toUpperCase()}`)\n          }\n          sql += ` ORDER BY ${orderClauses.join(', ')}`\n        }\n\n        if (take) sql += ` LIMIT ${take}`\n        if (skip) sql += ` OFFSET ${skip}`\n\n        const rows = await query(sql, params)\n        return rows.map(r => toCamelCase(r))\n      },\n      \n      async findFirst({ where, select, orderBy }: any) {\n        // Use findMany with take: 1 to reuse the logic\n        const result = await this.findMany({ where, select, orderBy, take: 1 })\n        return result.length > 0 ? result[0] : null\n      },\n      \n      async count({ where }: any = {}) {\n        const params: any[] = []\n        let sql = `SELECT COUNT(*) as cnt FROM \"${table}\"`\n\n        if (where) {\n          const conditions: string[] = []\n          for (const [key, value] of Object.entries(where)) {\n            if (value === null) {\n              conditions.push(`\"${key}\" IS NULL`)\n            } else if (typeof value === 'object' && value !== null) {\n              // Handle operators for count\n              if ('in' in value) {\n                const placeholders = (value as any).in.map((_: any, i: number) => `$${params.length + i + 1}`).join(', ')\n                params.push(...(value as any).in)\n                conditions.push(`\"${key}\" IN (${placeholders})`)\n              } else if ('not' in value) {\n                params.push((value as any).not)\n                conditions.push(`\"${key}\" != $${params.length}`)\n              } else {\n                params.push(value)\n                conditions.push(`\"${key}\" = $${params.length}`)\n              }\n            } else {\n              params.push(value)\n              conditions.push(`\"${key}\" = $${params.length}`)\n            }\n          }\n          if (conditions.length) sql += ` WHERE ${conditions.join(' AND ')}`\n        }\n\n        const row = await queryOne<any>(sql, params)\n        return row ? parseInt(row.cnt) : 0\n      },\n      \n      async create({ data, select }: any) {\n        const keys = Object.keys(data)\n        const values = Object.values(data)\n        const placeholders = keys.map((_, i) => `$${i + 1}`).join(', ')\n        const keyString = keys.map(k => `\"${k}\"`).join(', ')\n        const fields = select ? Object.keys(select).map(k => `\"${k}\"`).join(', ') : '*'\n        \n        const row = await queryOne(\n          `INSERT INTO \"${table}\" (${keyString}) VALUES (${placeholders}) RETURNING ${fields}`,\n          values\n        )\n        return row ? toCamelCase(row) : null\n      },\n      \n      async update({ where, data, select }: any) {\n        const params: any[] = []\n        const sets: string[] = []\n\n        // Build SET clause\n        for (const [key, value] of Object.entries(data)) {\n          if (value !== undefined) {\n            if (typeof value === 'object' && value !== null) {\n              // Handle increment/decrement operations\n              if ('increment' in value) {\n                params.push((value as any).increment)\n                sets.push(`\"${key}\" = COALESCE(\"${key}\", 0) + $${params.length}`)\n              } else if ('decrement' in value) {\n                params.push((value as any).decrement)\n                sets.push(`\"${key}\" = COALESCE(\"${key}\", 0) - $${params.length}`)\n              } else {\n                // Regular object value\n                params.push(JSON.stringify(value))\n                sets.push(`\"${key}\" = $${params.length}`)\n              }\n            } else {\n              params.push(value)\n              sets.push(`\"${key}\" = $${params.length}`)\n            }\n          }\n        }\n\n        // Build WHERE clause\n        const whereConditions: string[] = []\n        for (const [key, value] of Object.entries(where)) {\n          params.push(value)\n          whereConditions.push(`\"${key}\" = $${params.length}`)\n        }\n\n        const fields = select ? Object.keys(select).map(k => `\"${k}\"`).join(', ') : '*'\n        const row = await queryOne(\n          `UPDATE \"${table}\" SET ${sets.join(', ')} WHERE ${whereConditions.join(' AND ')} RETURNING ${fields}`,\n          params\n        )\n        return row ? toCamelCase(row) : null\n      },\n      \n      async delete({ where }: any) {\n        const [key, value] = Object.entries(where)[0] as [string, any]\n        await execute(`DELETE FROM \"${table}\" WHERE \"${key}\" = $1`, [value])\n        return {}\n      },\n      \n      async deleteMany({ where }: any = {}) {\n        const params: any[] = []\n        let sql = `DELETE FROM \"${table}\"`\n        \n        if (where) {\n          const conditions: string[] = []\n          for (const [key, value] of Object.entries(where)) {\n            params.push(value)\n            conditions.push(`\"${key}\" = $${params.length}`)\n          }\n          if (conditions.length) sql += ` WHERE ${conditions.join(' AND ')}`\n        }\n        \n        const count = await execute(sql, params)\n        return { count }\n      },\n      \n      async aggregate({ where, _sum, _count }: any) {\n        const params: any[] = []\n        const aggs: string[] = []\n        \n        if (_sum) {\n          Object.keys(_sum).forEach(field => {\n            aggs.push(`SUM(\"${field}\") as sum_${field}`)\n          })\n        }\n        if (_count) aggs.push('COUNT(*) as cnt')\n        \n        let sql = `SELECT ${aggs.join(', ')} FROM \"${table}\"`\n        \n        if (where) {\n          const conditions: string[] = []\n          for (const [key, value] of Object.entries(where)) {\n            params.push(value)\n            conditions.push(`\"${key}\" = $${params.length}`)\n          }\n          if (conditions.length) sql += ` WHERE ${conditions.join(' AND ')}`\n        }\n        \n        const row = await queryOne<any>(sql, params)\n        const result: any = {}\n        if (_sum && row) {\n          result._sum = {}\n          Object.keys(_sum).forEach(field => {\n            result._sum[field] = row[`sum_${field}`] ? parseFloat(row[`sum_${field}`]) : 0\n          })\n        }\n        if (_count && row) result._count = row.cnt ? parseInt(row.cnt) : 0\n        return result\n      },\n      \n      async groupBy({ by, _count, _sum, where }: any) {\n        const params: any[] = []\n        const fields = (Array.isArray(by) ? by : [by]).map(f => `\"${f}\"`)\n        const aggs: string[] = []\n        \n        if (_count) aggs.push('COUNT(*) as cnt')\n        if (_sum) {\n          Object.keys(_sum).forEach(field => {\n            aggs.push(`SUM(\"${field}\") as sum_${field}`)\n          })\n        }\n        \n        let sql = `SELECT ${fields.join(', ')}${aggs.length ? ', ' + aggs.join(', ') : ''} FROM \"${table}\"`\n        \n        if (where) {\n          const conditions: string[] = []\n          for (const [key, value] of Object.entries(where)) {\n            params.push(value)\n            conditions.push(`\"${key}\" = $${params.length}`)\n          }\n          if (conditions.length) sql += ` WHERE ${conditions.join(' AND ')}`\n        }\n        \n        sql += ` GROUP BY ${fields.join(', ')}`\n        const rows = await query(sql, params)\n        \n        return rows.map((row: any) => {\n          const transformed: any = {}\n          (Array.isArray(by) ? by : [by]).forEach(field => {\n            transformed[field] = row[field]\n          })\n          if (_count) transformed._count = row.cnt ? parseInt(row.cnt) : 0\n          if (_sum) {\n            transformed._sum = {}\n            Object.keys(_sum).forEach(field => {\n              transformed._sum[field] = row[`sum_${field}`] ? parseFloat(row[`sum_${field}`]) : 0\n            })\n          }\n          return transformed\n        })\n      },\n      \n      async upsert({ where, create, update }: any) {\n        const existing = await this.findUnique({ where })\n        return existing ? this.update({ where, data: update }) : this.create({ data: create })\n      }\n    }\n  }\n})\n\n// Support for await transaction\nexport const $transaction = transaction\n\nexport default {\n  query,\n  queryOne,\n  queryScalar,\n  execute,\n  transaction,\n  disconnect,\n  pool,\n  toCamelCase,\n  toSnakeCase,\n  prisma,\n  $transaction,\n}"],"names":[],"mappings":"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"}},
    {"offset": {"line": 723, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/LENOVO/Desktop/nsc-test/vercel-download/src/utils/server-helpers.ts"],"sourcesContent":["/**\n * Server-only helper functions\n * These use Node.js modules and should only be imported in API routes\n */\n\nimport bcrypt from 'bcrypt'\nimport jwt, { SignOptions, Secret } from 'jsonwebtoken'\nimport crypto from 'crypto'\nimport { JwtPayload } from '@/types/api'\nimport { queryOne, execute, transaction } from '@/lib/db'\n\n/**\n * Hash password\n */\nexport async function hashPassword(password: string): Promise<string> {\n  return await bcrypt.hash(password, 10)\n}\n\n/**\n * Compare password\n */\nexport async function comparePassword(\n  password: string,\n  hash: string\n): Promise<boolean> {\n  return await bcrypt.compare(password, hash)\n}\n\n/**\n * Generate JWT token\n */\nexport function generateToken(payload: Partial<JwtPayload>, expiresIn: string = '24h'): string {\n  if (!process.env.JWT_SECRET) {\n    throw new Error('JWT_SECRET is not defined in environment variables')\n  }\n  // Cast secret to Secret to satisfy TypeScript overloads\n  const secret: Secret = process.env.JWT_SECRET as Secret || 'fallback-secret'\n  // jwt.sign typings are picky about the secret type and options; cast to any\n  return jwt.sign(payload as any, secret as any, { expiresIn } as any);\n}\n\n/**\n * Generate refresh token\n */\nexport function generateRefreshToken(payload: Partial<JwtPayload>): string {\n  if (!process.env.JWT_REFRESH_SECRET) {\n    throw new Error('JWT_REFRESH_SECRET is not defined in environment variables')\n  }\n  const tokenPayload = {\n    ...payload,\n    type: 'refresh'\n  }\n  const refreshSecret: Secret = process.env.JWT_REFRESH_SECRET as Secret || 'fallback-refresh-secret'\n  return jwt.sign(tokenPayload as any, refreshSecret, { expiresIn: '7d' });\n}\n\n/**\n * Verify JWT token\n */\nexport function verifyToken(token: string): JwtPayload | null {\n  try {\n    if (!process.env.JWT_SECRET) {\n      throw new Error('JWT_SECRET is not defined in environment variables')\n    }\n    const decoded = jwt.verify(token, process.env.JWT_SECRET);\n    if (typeof decoded === 'string') {\n      return null;\n    }\n    return decoded as JwtPayload;\n  } catch (error) {\n    return null\n  }\n}\n\n/**\n * Verify refresh token\n */\nexport function verifyRefreshToken(token: string): JwtPayload | null {\n  try {\n    if (!process.env.JWT_REFRESH_SECRET) {\n      throw new Error('JWT_REFRESH_SECRET is not defined in environment variables')\n    }\n    const decoded = jwt.verify(token, process.env.JWT_REFRESH_SECRET);\n    if (typeof decoded === 'string') {\n      return null;\n    }\n    return decoded as JwtPayload;\n  } catch (error) {\n    return null\n  }\n}\n\n/**\n * Generate random token\n */\nexport function generateRandomToken(): string {\n  return crypto.randomBytes(32).toString('hex')\n}\n\n/**\n * Generate unique referral code (DEPRECATED - use getNextReferralCode instead)\n * Kept for backward compatibility\n */\nexport function generateReferralCode(username: string): string {\n  const random = crypto.randomBytes(3).toString('hex').toUpperCase()\n  const userPrefix = username.substring(0, 3).toUpperCase()\n  return `${userPrefix}${random}`\n}\n\n/**\n * Get next sequential referral code (NSCREF1001, NSCREF1002, etc.)\n * This is the code users share with others\n * Uses a transaction to prevent race conditions\n */\nexport async function getNextReferralCode(): Promise<string> {\n  // Use a transaction to ensure atomicity and prevent race conditions\n  const result = await transaction(async (client: any) => {\n    // First, try to find the existing counter\n    let counter = await queryOne<any>(\n      `SELECT * FROM \"ReferralCounter\" WHERE \"counterType\" = 'NSCREF'`,\n      []\n    );\n\n    // If counter doesn't exist, create it with initial value\n    if (!counter) {\n      counter = await queryOne<any>(\n        `INSERT INTO \"ReferralCounter\" (\"counterType\", \"currentValue\") \n         VALUES ('NSCREF', 1001) RETURNING *`,\n        []\n      );\n    } else {\n      // Increment the counter\n      counter = await queryOne<any>(\n        `UPDATE \"ReferralCounter\" SET \"currentValue\" = \"currentValue\" + 1 \n         WHERE \"counterType\" = 'NSCREF' RETURNING *`,\n        []\n      );\n    }\n\n    return counter;\n  });\n  \n  // The result is the counter object\n  const counter = result;\n  \n  // Double-check that the code is unique\n  const codeToUse = `NSCREF${counter.currentValue}`;\n  const existingUser = await queryOne<any>(\n    `SELECT * FROM \"User\" WHERE \"referralCode\" = $1`,\n    [codeToUse]\n  );\n  \n  // In the extremely unlikely case of a collision, add a random suffix\n  if (existingUser) {\n    const randomSuffix = Math.floor(Math.random() * 1000).toString().padStart(3, '0');\n    return `NSCREF${counter.currentValue}_${randomSuffix}`;\n  }\n  \n  return codeToUse;\n}\n\n// NEWNCS function has been completely removed as it's no longer needed\n// All users must now register with a valid referral code\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 860, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/LENOVO/Desktop/nsc-test/vercel-download/src/lib/neon-serverless.ts"],"sourcesContent":["import { neon } from '@neondatabase/serverless'\r\n\r\n/**\r\n * Neon Serverless Database Connection\r\n * Optimized for Neon's serverless environment\r\n */\r\n\r\nlet sql: ReturnType<typeof neon> | null = null\r\n\r\nexport function getNeonSQL() {\r\n  if (!sql) {\r\n    const databaseUrl = process.env.DATABASE_URL\r\n    if (!databaseUrl) {\r\n      throw new Error('DATABASE_URL is not defined in environment variables')\r\n    }\r\n    \r\n    console.log('üöÄ Initializing Neon Serverless SQL connection')\r\n    sql = neon(databaseUrl)\r\n  }\r\n  return sql\r\n}\r\n\r\n/**\r\n * Execute a query with Neon Serverless Driver\r\n * This bypasses traditional connection pooling issues\r\n * Uses tagged template literals as required by Neon\r\n */\r\nexport async function neonQuery<T = any>(\r\n  query: string, \r\n  params: any[] = []\r\n): Promise<T[]> {\r\n  const sql = getNeonSQL()\r\n  \r\n  try {\r\n    console.log(`üîç Executing Neon query: ${query.substring(0, 100)}...`)\r\n    \r\n    // For Neon serverless, we need to use sql.query() for parameterized queries\r\n    const result = await sql.query(query, params)\r\n    \r\n    const resultArray = Array.isArray(result) ? result : [result]\r\n    console.log(`‚úÖ Neon query completed, returned ${resultArray.length} rows`)\r\n    return resultArray as T[]\r\n    \r\n  } catch (error) {\r\n    console.error('‚ùå Neon query failed:', error.message)\r\n    console.error('Query:', query)\r\n    console.error('Params:', params)\r\n    throw error\r\n  }\r\n}\r\n\r\n/**\r\n * Execute a prepared statement with Neon Serverless Driver\r\n * For queries that need parameter binding\r\n */\r\nexport async function neonQueryPrepared<T = any>(\r\n  queryTemplate: (sql: ReturnType<typeof neon>) => Promise<T[]>\r\n): Promise<T[]> {\r\n  const sql = getNeonSQL()\r\n  \r\n  try {\r\n    console.log(`üîç Executing Neon prepared query...`)\r\n    \r\n    const result = await queryTemplate(sql)\r\n    \r\n    console.log(`‚úÖ Neon prepared query completed, returned ${result.length} rows`)\r\n    return result\r\n    \r\n  } catch (error) {\r\n    console.error('‚ùå Neon prepared query failed:', error.message)\r\n    throw error\r\n  }\r\n}\r\n\r\nexport default {\r\n  getNeonSQL,\r\n  neonQuery,\r\n  neonQueryPrepared\r\n}"],"names":[],"mappings":";;;;;;;;;;AAAA;;AAEA;;;CAGC,GAED,IAAI,MAAsC;AAEnC,SAAS;IACd,IAAI,CAAC,KAAK;QACR,MAAM,cAAc,QAAQ,GAAG,CAAC,YAAY;QAC5C,IAAI,CAAC,aAAa;YAChB,MAAM,IAAI,MAAM;QAClB;QAEA,QAAQ,GAAG,CAAC;QACZ,MAAM,IAAA,gKAAI,EAAC;IACb;IACA,OAAO;AACT;AAOO,eAAe,UACpB,KAAa,EACb,SAAgB,EAAE;IAElB,MAAM,MAAM;IAEZ,IAAI;QACF,QAAQ,GAAG,CAAC,CAAC,yBAAyB,EAAE,MAAM,SAAS,CAAC,GAAG,KAAK,GAAG,CAAC;QAEpE,4EAA4E;QAC5E,MAAM,SAAS,MAAM,IAAI,KAAK,CAAC,OAAO;QAEtC,MAAM,cAAc,MAAM,OAAO,CAAC,UAAU,SAAS;YAAC;SAAO;QAC7D,QAAQ,GAAG,CAAC,CAAC,iCAAiC,EAAE,YAAY,MAAM,CAAC,KAAK,CAAC;QACzE,OAAO;IAET,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,wBAAwB,MAAM,OAAO;QACnD,QAAQ,KAAK,CAAC,UAAU;QACxB,QAAQ,KAAK,CAAC,WAAW;QACzB,MAAM;IACR;AACF;AAMO,eAAe,kBACpB,aAA6D;IAE7D,MAAM,MAAM;IAEZ,IAAI;QACF,QAAQ,GAAG,CAAC,CAAC,mCAAmC,CAAC;QAEjD,MAAM,SAAS,MAAM,cAAc;QAEnC,QAAQ,GAAG,CAAC,CAAC,0CAA0C,EAAE,OAAO,MAAM,CAAC,KAAK,CAAC;QAC7E,OAAO;IAET,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,iCAAiC,MAAM,OAAO;QAC5D,MAAM;IACR;AACF;uCAEe;IACb;IACA;IACA;AACF"}},
    {"offset": {"line": 928, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/LENOVO/Desktop/nsc-test/vercel-download/src/services/sessionManagementService.ts"],"sourcesContent":["import { queryWithTimeout } from '../lib/db-connection';\r\n\r\ninterface SessionData {\r\n  sessionId: string;\r\n  userId: string;\r\n  ipAddress: string;\r\n  userAgent: string;\r\n  isActive: boolean;\r\n  createdAt: Date;\r\n  lastActiveAt: Date;\r\n  expiresAt: Date;\r\n}\r\n\r\ninterface SessionStats {\r\n  activeSessions: number;\r\n  uniqueUsers: number;\r\n  sessionsLast24h: number;\r\n}\r\n\r\nexport class SessionManagementService {\r\n  /**\r\n   * Create a new session for a user\r\n   */\r\n  static async createSession(\r\n    userId: string,\r\n    tokenHash: string,\r\n    refreshTokenHash: string,\r\n    ipAddress: string,\r\n    userAgent: string,\r\n    expiresAt: Date = new Date(Date.now() + 30 * 24 * 60 * 60 * 1000) // 30 days default\r\n  ): Promise<SessionData | null> {\r\n    try {\r\n      const result = await queryWithTimeout(\r\n        `SELECT create_session($1::TEXT, $2::TEXT, $3::TEXT, $4::TEXT, $5::TEXT, $6::TIMESTAMP) as session_id`,\r\n        [userId, tokenHash, refreshTokenHash, ipAddress, userAgent, expiresAt],\r\n        5000\r\n      );\r\n\r\n      if (result.rows && result.rows.length > 0) {\r\n        const sessionId = result.rows[0].session_id;\r\n        \r\n        // Return a basic session object\r\n        return {\r\n          sessionId: sessionId,\r\n          userId: userId,\r\n          ipAddress: ipAddress,\r\n          userAgent: userAgent,\r\n          isActive: true,\r\n          createdAt: new Date(),\r\n          lastActiveAt: new Date(),\r\n          expiresAt: expiresAt\r\n        };\r\n      }\r\n\r\n      return null;\r\n    } catch (error) {\r\n      console.error('Error creating session:', error);\r\n      \r\n      // For now, don't throw an error to allow login to complete\r\n      // This allows the system to work while we debug the session creation\r\n      console.warn('Session creation failed, but allowing login to continue');\r\n      return {\r\n        sessionId: 'fallback-session-' + Date.now(),\r\n        userId: userId,\r\n        ipAddress: ipAddress,\r\n        userAgent: userAgent,\r\n        isActive: true,\r\n        createdAt: new Date(),\r\n        lastActiveAt: new Date(),\r\n        expiresAt: expiresAt\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Validate and update session activity\r\n   */\r\n  static async validateSession(tokenHash: string): Promise<SessionData | null> {\r\n    try {\r\n      const result = await queryWithTimeout(\r\n        `SELECT * FROM validate_session($1::TEXT)`,\r\n        [tokenHash],\r\n        5000\r\n      );\r\n\r\n      if (result.rows && result.rows.length > 0) {\r\n        const session = result.rows[0];\r\n        \r\n        // Return null if session is not valid\r\n        if (!session.isValid) {\r\n          return null;\r\n        }\r\n\r\n        return {\r\n          sessionId: session.sessionId,\r\n          userId: session.userId,\r\n          ipAddress: session.ipAddress,\r\n          userAgent: session.userAgent,\r\n          isActive: session.isValid,\r\n          createdAt: new Date(session.createdAt),\r\n          lastActiveAt: new Date(session.lastUsedAt),\r\n          expiresAt: new Date(session.expiresAt)\r\n        };\r\n      }\r\n\r\n      return null;\r\n    } catch (error) {\r\n      console.error('Error validating session:', error);\r\n      return null; // Fail gracefully for validation\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Revoke a specific session\r\n   */\r\n  static async revokeSession(sessionId: string): Promise<boolean> {\r\n    try {\r\n      const result = await queryWithTimeout(\r\n        `SELECT revoke_session($1) as revoked`,\r\n        [sessionId],\r\n        5000\r\n      );\r\n\r\n      return result.rows?.[0]?.revoked === true;\r\n    } catch (error) {\r\n      console.error('Error revoking session:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Revoke all sessions for a user\r\n   */\r\n  static async revokeAllUserSessions(userId: string): Promise<number> {\r\n    try {\r\n      const result = await queryWithTimeout(\r\n        `SELECT revoke_all_user_sessions($1) as revoked_count`,\r\n        [userId],\r\n        5000\r\n      );\r\n\r\n      return result.rows?.[0]?.revoked_count || 0;\r\n    } catch (error) {\r\n      console.error('Error revoking all user sessions:', error);\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Revoke all other sessions except the current one\r\n   */\r\n  static async revokeOtherSessions(userId: string, currentSessionId: string): Promise<number> {\r\n    try {\r\n      const result = await queryWithTimeout(\r\n        `SELECT revoke_other_sessions($1, $2) as revoked_count`,\r\n        [userId, currentSessionId],\r\n        5000\r\n      );\r\n\r\n      return result.rows?.[0]?.revoked_count || 0;\r\n    } catch (error) {\r\n      console.error('Error revoking other sessions:', error);\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get all active sessions for a user\r\n   */\r\n  static async getUserSessions(userId: string): Promise<SessionData[]> {\r\n    try {\r\n      const result = await queryWithTimeout(\r\n        `SELECT * FROM get_user_sessions($1::TEXT)`,\r\n        [userId],\r\n        5000\r\n      );\r\n\r\n      if (result.rows && result.rows.length > 0) {\r\n        return result.rows.map(session => ({\r\n          sessionId: session.sessionId,\r\n          userId: userId,\r\n          ipAddress: session.ipAddress,\r\n          userAgent: session.userAgent,\r\n          isActive: session.isActive,\r\n          createdAt: new Date(session.createdAt),\r\n          lastActiveAt: new Date(session.lastUsedAt),\r\n          expiresAt: new Date(session.expiresAt)\r\n        }));\r\n      }\r\n\r\n      return [];\r\n    } catch (error) {\r\n      console.error('Error getting user sessions:', error);\r\n      return [];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clean up expired sessions\r\n   */\r\n  static async cleanupExpiredSessions(): Promise<number> {\r\n    try {\r\n      const result = await queryWithTimeout(\r\n        `SELECT cleanup_expired_sessions() as cleaned_count`,\r\n        [],\r\n        10000 // Longer timeout for cleanup operation\r\n      );\r\n\r\n      return result.rows?.[0]?.cleaned_count || 0;\r\n    } catch (error) {\r\n      console.error('Error cleaning up expired sessions:', error);\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get session statistics\r\n   */\r\n  static async getSessionStats(): Promise<SessionStats> {\r\n    try {\r\n      const result = await queryWithTimeout(\r\n        `SELECT * FROM get_session_stats()`,\r\n        [],\r\n        5000\r\n      );\r\n\r\n      if (result.rows && result.rows.length > 0) {\r\n        const stats = result.rows[0];\r\n        return {\r\n          activeSessions: stats.active_sessions || 0,\r\n          uniqueUsers: stats.unique_users || 0,\r\n          sessionsLast24h: stats.sessions_last_24h || 0\r\n        };\r\n      }\r\n\r\n      return {\r\n        activeSessions: 0,\r\n        uniqueUsers: 0,\r\n        sessionsLast24h: 0\r\n      };\r\n    } catch (error) {\r\n      console.error('Error getting session stats:', error);\r\n      return {\r\n        activeSessions: 0,\r\n        uniqueUsers: 0,\r\n        sessionsLast24h: 0\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Generate a secure session ID\r\n   */\r\n  static generateSessionId(): string {\r\n    const crypto = require('crypto');\r\n    return crypto.randomBytes(32).toString('hex');\r\n  }\r\n\r\n  /**\r\n   * Extract session ID from JWT token or cookie\r\n   */\r\n  static extractSessionId(token?: string): string | null {\r\n    if (!token) return null;\r\n\r\n    try {\r\n      // If it's a JWT token, decode to get session ID\r\n      const jwt = require('jsonwebtoken');\r\n      const decoded = jwt.decode(token) as any;\r\n      return decoded?.sessionId || null;\r\n    } catch (error) {\r\n      // If not JWT, treat as direct session ID\r\n      return token;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Middleware helper to validate session in requests\r\n   */\r\n  static async validateRequestSession(\r\n    authHeader?: string,\r\n    sessionCookie?: string\r\n  ): Promise<{ isValid: boolean; session?: SessionData; userId?: string }> {\r\n    try {\r\n      // Try to extract session ID from Authorization header or cookie\r\n      let sessionId: string | null = null;\r\n\r\n      if (authHeader?.startsWith('Bearer ')) {\r\n        sessionId = this.extractSessionId(authHeader.substring(7));\r\n      } else if (sessionCookie) {\r\n        sessionId = this.extractSessionId(sessionCookie);\r\n      }\r\n\r\n      if (!sessionId) {\r\n        return { isValid: false };\r\n      }\r\n\r\n      const session = await this.validateSession(sessionId);\r\n      \r\n      if (!session) {\r\n        return { isValid: false };\r\n      }\r\n\r\n      return {\r\n        isValid: true,\r\n        session,\r\n        userId: session.userId\r\n      };\r\n    } catch (error) {\r\n      console.error('Error validating request session:', error);\r\n      return { isValid: false };\r\n    }\r\n  }\r\n}\r\n\r\nexport default SessionManagementService;"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1183, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/LENOVO/Desktop/nsc-test/vercel-download/src/middleware/auth.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server'\nimport { verifyToken } from '@/utils/server-helpers'\nimport { neonQuery } from '@/lib/neon-serverless'\nimport { queryOne } from '@/lib/db'\nimport { AuthUser, JwtPayload } from '@/types/api'\nimport SessionManagementService from '@/services/sessionManagementService'\nimport { createHash } from 'crypto'\n\nexport interface AuthRequest extends NextRequest {\n  user?: AuthUser\n}\n\n/**\n * Authenticate JWT token middleware with session validation\n */\nexport async function authenticateToken(\n  request: NextRequest,\n  options: { validateSession?: boolean } = {}\n): Promise<{ user: AuthUser } | NextResponse> {\n  // Try to get token from cookies first (browser requests)\n  const tokenCookie = request.cookies.get('token')?.value\n  \n  // If not in cookies, try authorization header (API requests)\n  const authHeader = request.headers.get('authorization')\n  const headerToken = authHeader?.split(' ')[1]\n  \n  const token = tokenCookie || headerToken\n  \n  if (!token) {\n    return NextResponse.json(\n      { error: 'Access token required' },\n      { status: 401 }\n    )\n  }\n  \n  try {\n    const decoded = verifyToken(token)\n    if (!decoded || !decoded.userId || !decoded.email) {\n      return NextResponse.json(\n        { error: 'Invalid token payload' },\n        { status: 403 }\n      )\n    }\n\n    // Validate session if requested (for critical operations)\n    if (options.validateSession) {\n      const tokenHash = createHash('sha256').update(token).digest('hex')\n      const session = await SessionManagementService.validateSession(tokenHash)\n      \n      if (!session || !session.isActive) {\n        return NextResponse.json(\n          { error: 'Session expired or revoked' },\n          { status: 401 }\n        )\n      }\n\n      // Verify user is still active in database\n      const user = await queryOne(\n        `SELECT id, email, \"isActive\" FROM \"User\" WHERE id = $1`,\n        [decoded.userId]\n      )\n\n      if (!user || !user.isActive) {\n        return NextResponse.json(\n          { error: 'User account is inactive' },\n          { status: 403 }\n        )\n      }\n    }\n    \n    const user: AuthUser = {\n      userId: decoded.userId,\n      email: decoded.email,\n      isAdmin: decoded.isAdmin || false\n    }\n    \n    return { user }\n  } catch (error) {\n    return NextResponse.json(\n      { error: 'Invalid or expired token' },\n      { status: 403 }\n    )\n  }\n}\n\n/**\n * Require admin role middleware\n */\nexport function requireAdmin(user: AuthUser): { isAdmin: boolean } | NextResponse {\n  if (!user || !user.isAdmin) {\n    return NextResponse.json(\n      { error: 'Admin access required' },\n      { status: 403 }\n    )\n  }\n  \n  return { isAdmin: true }\n}\n\n/**\n * Require bot activation middleware\n */\nexport async function requireBotActivation(userId: string, botType: string): Promise<NextResponse | null> {\n  try {\n    // Use Neon Serverless query to check for active bot activation\n    const query = `\n      SELECT * FROM \"BotActivation\"\n      WHERE \"userId\" = $1 AND \"botType\" = $2\n      AND \"status\" = 'ACTIVE' AND \"isExpired\" = false\n      LIMIT 1\n    `;\n\n    const result = await neonQuery(query, [userId, botType]);\n    const botActivation = Array.isArray(result) && result.length > 0 ? result[0] : null;\n\n    if (!botActivation) {\n      return NextResponse.json(\n        { error: 'Bot activation required for this action' },\n        { status: 403 }\n      );\n    }\n\n    return null;\n  } catch (error) {\n    console.error('Error checking bot activation:', error);\n    return NextResponse.json(\n      { error: 'Error checking bot activation' },\n      { status: 500 }\n    );\n  }\n}\n\n/**\n * Verify authentication from token in cookies or headers\n * Returns user ID if authenticated\n */\nexport async function verifyAuth(request: NextRequest): Promise<{ success: boolean; userId?: string }> {\n  // Try to get token from cookies first\n  const tokenCookie = request.cookies.get('token')?.value\n  \n  // If not in cookies, try authorization header\n  const authHeader = request.headers.get('authorization')\n  const headerToken = authHeader?.split(' ')[1]\n  \n  const token = tokenCookie || headerToken\n  \n  if (!token) {\n    return { success: false }\n  }\n  \n  try {\n    const decoded = verifyToken(token)\n    if (!decoded || !decoded.userId) {\n      return { success: false }\n    }\n    \n    return { success: true, userId: decoded.userId }\n  } catch (error) {\n    return { success: false }\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1350, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/LENOVO/Desktop/nsc-test/vercel-download/src/types/index.ts"],"sourcesContent":["// Enums for database schema\nexport enum PackageType {\n  NEO = 'NEO',\n  NEURAL = 'NEURAL',\n  ORACLE = 'ORACLE',\n}\n\nexport enum Network {\n  BEP20 = 'BEP20',\n  TRC20 = 'TRC20',\n}\n\nexport enum PackageStatus {\n  PENDING = 'PENDING',\n  ACTIVE = 'ACTIVE',\n  EXPIRED = 'EXPIRED',\n  WITHDRAWN = 'WITHDRAWN',\n}\n\nexport enum BotStatus {\n  ACTIVE = 'ACTIVE',\n  EXPIRED = 'EXPIRED',\n  INACTIVE = 'INACTIVE',\n  SUSPENDED = 'SUSPENDED',\n}\n\nexport enum EarningType {\n  DIRECT_REFERRAL = 'DIRECT_REFERRAL',\n  LEVEL_INCOME = 'LEVEL_INCOME',\n}\n\nexport enum TransactionType {\n  DEPOSIT = 'DEPOSIT',\n  WITHDRAWAL = 'WITHDRAWAL',\n  BOT_FEE = 'BOT_FEE',\n  ROI_PAYMENT = 'ROI_PAYMENT',\n  REFERRAL_BONUS = 'REFERRAL_BONUS',\n  LEVEL_INCOME = 'LEVEL_INCOME',\n}\n\nexport enum TransactionStatus {\n  PENDING = 'PENDING',\n  CONFIRMING = 'CONFIRMING',\n  COMPLETED = 'COMPLETED',\n  FAILED = 'FAILED',\n  REJECTED = 'REJECTED',\n}\n\nexport enum WithdrawalType {\n  ROI_ONLY = 'ROI_ONLY',\n  CAPITAL = 'CAPITAL',\n  FULL_AMOUNT = 'FULL_AMOUNT',\n}\n\nexport enum WithdrawalStatus {\n  PENDING = 'PENDING',\n  APPROVED = 'APPROVED',\n  PROCESSING = 'PROCESSING',\n  COMPLETED = 'COMPLETED',\n  REJECTED = 'REJECTED',\n}\n\nexport enum KycStatus {\n  PENDING = 'PENDING',\n  APPROVED = 'APPROVED',\n  REJECTED = 'REJECTED',\n}\n\nexport enum PaymentStatus {\n  PENDING = 'PENDING',\n  PROCESSING = 'PROCESSING',\n  COMPLETED = 'COMPLETED',\n  FAILED = 'FAILED',\n}\n\n// API Response types\nexport interface ApiResponse<T = any> {\n  success: boolean\n  message?: string\n  data?: T\n  error?: string\n}\n\nexport interface PaginationMeta {\n  page: number\n  limit: number\n  total: number\n  totalPages: number\n}\n\nexport interface PaginatedResponse<T> extends ApiResponse<T> {\n  pagination: PaginationMeta\n}\n\n// User types\nexport interface UserProfile {\n  id: string\n  username: string\n  email: string\n  fullName: string | null\n  phone: string | null\n  referralCode: string\n  bep20Address: string | null\n  trc20Address: string | null\n  isEmailVerified: boolean\n  twoFactorEnabled: boolean\n  kycStatus: KycStatus\n  createdAt: Date\n}\n\nexport interface UserStats {\n  totalInvested: number\n  totalEarnings: number\n  activePackages: number\n  totalReferrals: number\n  withdrawableBalance: number\n}\n\n// Auth types\nexport interface LoginCredentials {\n  email: string\n  password: string\n  twoFactorCode?: string\n}\n\nexport interface RegisterData {\n  email: string\n  password: string\n  fullName: string\n  referralCode?: string\n}\n\nexport interface AuthTokens {\n  token: string\n  refreshToken: string\n}\n\n// Package types\nexport interface PackageData {\n  id: string\n  amount: number\n  packageType: PackageType\n  roiPercentage: number\n  investmentDate: Date\n  expiryDate: Date\n  nextRoiDate: Date | null\n  status: PackageStatus\n  totalRoiPaid: number\n  roiPaidCount: number\n  network: Network\n}\n\n// Withdrawal types\nexport interface WithdrawalRequest {\n  amount: number\n  type: WithdrawalType\n  walletAddress: string\n  network: Network\n  twoFactorCode?: string\n}\n\nexport interface WithdrawalData {\n  id: string\n  amount: number\n  fee: number\n  netAmount: number\n  withdrawalType: WithdrawalType\n  walletAddress: string\n  network: Network\n  status: WithdrawalStatus\n  txHash: string | null\n  requestDate: Date\n}\n\n// Earnings types\nexport interface EarningData {\n  id: string\n  earningType: EarningType\n  amount: number\n  level: number | null\n  percentage: number | null\n  paidDate: Date\n}\n\nexport interface EarningsSummary {\n  totalEarnings: number\n  roiEarnings: number\n  referralEarnings: number\n  levelEarnings: number\n  withdrawableBalance: number\n}\n\n// Referral types\nexport interface ReferralTreeNode {\n  id: string\n  username: string\n  email: string\n  level: number\n  children: ReferralTreeNode[]\n  packageCount: number\n  totalInvested: number\n}\n"],"names":[],"mappings":"AAAA,4BAA4B;;;;;;;;;;;;;;;;;;;;;;;;;AACrB,IAAA,AAAK,qCAAA;;;;WAAA;;AAML,IAAA,AAAK,iCAAA;;;WAAA;;AAKL,IAAA,AAAK,uCAAA;;;;;WAAA;;AAOL,IAAA,AAAK,mCAAA;;;;;WAAA;;AAOL,IAAA,AAAK,qCAAA;;;WAAA;;AAKL,IAAA,AAAK,yCAAA;;;;;;;WAAA;;AASL,IAAA,AAAK,2CAAA;;;;;;WAAA;;AAQL,IAAA,AAAK,wCAAA;;;;WAAA;;AAML,IAAA,AAAK,0CAAA;;;;;;WAAA;;AAQL,IAAA,AAAK,mCAAA;;;;WAAA;;AAML,IAAA,AAAK,uCAAA;;;;;WAAA"}},
    {"offset": {"line": 1453, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/LENOVO/Desktop/nsc-test/vercel-download/src/utils/calculations.ts"],"sourcesContent":["import { PackageType } from '@/types'\n\n/**\n * Calculate ROI amount based on package\n */\nexport function calculateRoi(amount: number, packageType: PackageType): number {\n  const roiRates: Record<PackageType, number> = {\n    NEO: 0.03,      // 3%\n    NEURAL: 0.04,   // 4%\n    ORACLE: 0.05,   // 5%\n  }\n  \n  return amount * roiRates[packageType]\n}\n\n/**\n * Determine package type based on amount\n */\nexport function getPackageType(amount: number): PackageType {\n  if (amount >= 500 && amount <= 3000) return PackageType.NEO\n  if (amount >= 5000 && amount <= 10000) return PackageType.NEURAL\n  if (amount >= 25000 && amount <= 50000) return PackageType.ORACLE\n  \n  throw new Error('Invalid package amount')\n}\n\n/**\n * Get bot activation fee based on bot type\n */\nexport function getBotFee(botType: PackageType): number {\n  const fees: Record<PackageType, number> = {\n    NEO: 50,\n    NEURAL: 100,\n    ORACLE: 150,\n  }\n  \n  return fees[botType]\n}\n\n/**\n * Calculate level income based on upline distance and amount\n * Example chain: A ‚Üí B ‚Üí C ‚Üí D ‚Üí E ‚Üí F ‚Üí G\n * When G buys:\n * - F gets 2% (direct referrer/level 1)\n * - E gets 0.75% (level 2 - referred F)\n * - D gets 0.50% (level 3 - referred E)\n * - C gets 0.25% (level 4 - referred D)\n * - B gets 0.15% (level 5 - referred C)\n * - A gets 0.10% (level 6 - referred B)\n * \n * NOTE: Users only earn referral/level income if they have an active bot\n */\nexport function calculateLevelIncome(level: number, amount: number, hasBotActive: boolean): number {\n  // If user doesn't have an active bot, they don't earn referral income\n  if (!hasBotActive) {\n    return 0\n  }\n\n  // Level represents how many steps up the referral chain\n  const levelPercentages: Record<number, number> = {\n    1: 0.02,    // 2% - Direct referrer bonus\n    2: 0.0075,  // 0.75% - Referrer's referrer\n    3: 0.005,   // 0.50% - 3rd upline\n    4: 0.0025,  // 0.25% - 4th upline\n    5: 0.0015,  // 0.15% - 5th upline\n    6: 0.001    // 0.10% - 6th upline\n  }\n  \n  if (level < 1 || level > 6) return 0\n  \n  return amount * levelPercentages[level]\n}\n\n/**\n * Calculate withdrawal fee (10%)\n */\nexport function calculateWithdrawalFee(amount: number): number {\n  return amount * 0.10\n}\n\n/**\n * Check if user can withdraw (30 days rule)\n */\nexport function canWithdraw(lastWithdrawalDate: Date | null): boolean {\n  if (!lastWithdrawalDate) return true\n  \n  const thirtyDaysAgo = new Date()\n  thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30)\n  \n  return lastWithdrawalDate <= thirtyDaysAgo\n}\n\n/**\n * Calculate next ROI date (30 days from last payment)\n */\nexport function getNextRoiDate(lastRoiDate: Date | null, investmentDate: Date): Date {\n  const baseDate = lastRoiDate || investmentDate\n  const nextDate = new Date(baseDate)\n  nextDate.setDate(nextDate.getDate() + 30)\n  \n  return nextDate\n}\n\n/**\n * Check if package is expired (12 months)\n */\nexport function isPackageExpired(investmentDate: Date): boolean {\n  const expiryDate = new Date(investmentDate)\n  expiryDate.setMonth(expiryDate.getMonth() + 12)\n  \n  return new Date() >= expiryDate\n}\n\n/**\n * Validate package amount\n */\nexport function isValidPackageAmount(amount: number): boolean {\n  const validAmounts = [500, 1000, 3000, 5000, 10000, 25000, 50000]\n  return validAmounts.includes(amount)\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;;AAKO,SAAS,aAAa,MAAc,EAAE,WAAwB;IACnE,MAAM,WAAwC;QAC5C,KAAK;QACL,QAAQ;QACR,QAAQ;IACV;IAEA,OAAO,SAAS,QAAQ,CAAC,YAAY;AACvC;AAKO,SAAS,eAAe,MAAc;IAC3C,IAAI,UAAU,OAAO,UAAU,MAAM,OAAO,+HAAW,CAAC,GAAG;IAC3D,IAAI,UAAU,QAAQ,UAAU,OAAO,OAAO,+HAAW,CAAC,MAAM;IAChE,IAAI,UAAU,SAAS,UAAU,OAAO,OAAO,+HAAW,CAAC,MAAM;IAEjE,MAAM,IAAI,MAAM;AAClB;AAKO,SAAS,UAAU,OAAoB;IAC5C,MAAM,OAAoC;QACxC,KAAK;QACL,QAAQ;QACR,QAAQ;IACV;IAEA,OAAO,IAAI,CAAC,QAAQ;AACtB;AAeO,SAAS,qBAAqB,KAAa,EAAE,MAAc,EAAE,YAAqB;IACvF,sEAAsE;IACtE,IAAI,CAAC,cAAc;QACjB,OAAO;IACT;IAEA,wDAAwD;IACxD,MAAM,mBAA2C;QAC/C,GAAG;QACH,GAAG;QACH,GAAG;QACH,GAAG;QACH,GAAG;QACH,GAAG,MAAS,qBAAqB;IACnC;IAEA,IAAI,QAAQ,KAAK,QAAQ,GAAG,OAAO;IAEnC,OAAO,SAAS,gBAAgB,CAAC,MAAM;AACzC;AAKO,SAAS,uBAAuB,MAAc;IACnD,OAAO,SAAS;AAClB;AAKO,SAAS,YAAY,kBAA+B;IACzD,IAAI,CAAC,oBAAoB,OAAO;IAEhC,MAAM,gBAAgB,IAAI;IAC1B,cAAc,OAAO,CAAC,cAAc,OAAO,KAAK;IAEhD,OAAO,sBAAsB;AAC/B;AAKO,SAAS,eAAe,WAAwB,EAAE,cAAoB;IAC3E,MAAM,WAAW,eAAe;IAChC,MAAM,WAAW,IAAI,KAAK;IAC1B,SAAS,OAAO,CAAC,SAAS,OAAO,KAAK;IAEtC,OAAO;AACT;AAKO,SAAS,iBAAiB,cAAoB;IACnD,MAAM,aAAa,IAAI,KAAK;IAC5B,WAAW,QAAQ,CAAC,WAAW,QAAQ,KAAK;IAE5C,OAAO,IAAI,UAAU;AACvB;AAKO,SAAS,qBAAqB,MAAc;IACjD,MAAM,eAAe;QAAC;QAAK;QAAM;QAAM;QAAM;QAAO;QAAO;KAAM;IACjE,OAAO,aAAa,QAAQ,CAAC;AAC/B"}},
    {"offset": {"line": 1604, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/LENOVO/Desktop/nsc-test/vercel-download/src/utils/email.ts"],"sourcesContent":["import nodemailer from 'nodemailer'\nimport { PackageType } from '@/types'\n\nconst transporter = nodemailer.createTransport({\n  host: process.env.SMTP_HOST,\n  port: parseInt(process.env.SMTP_PORT || '587'),\n  secure: false,\n  auth: {\n    user: process.env.SMTP_USER,\n    pass: process.env.SMTP_PASS\n  }\n})\n\nexport async function sendRoiNotificationEmail(\n  email: string,\n  amount: number,\n  month: number\n): Promise<void> {\n  await transporter.sendMail({\n    from: process.env.SMTP_FROM,\n    to: email,\n    subject: `ROI Payment - Month ${month}`,\n    html: `\n      <h2>ROI Payment Received</h2>\n      <p>Your monthly ROI payment has been credited to your account.</p>\n      <p><strong>Amount:</strong> ${amount} USDT</p>\n      <p><strong>Month:</strong> ${month}/12</p>\n    `\n  })\n}\n\nexport async function sendPackageActivationEmail(\n  email: string,\n  amount: number,\n  packageType: PackageType\n): Promise<void> {\n  await transporter.sendMail({\n    from: process.env.SMTP_FROM,\n    to: email,\n    subject: 'Package Activated Successfully',\n    html: `\n      <h2>Package Activated</h2>\n      <p>Your investment package has been activated successfully.</p>\n      <p><strong>Amount:</strong> ${amount} USDT</p>\n      <p><strong>Type:</strong> ${packageType}</p>\n      <p><strong>Duration:</strong> 12 months</p>\n    `\n  })\n}\n\nexport async function sendWithdrawalConfirmationEmail(\n  email: string,\n  amount: number,\n  txHash: string\n): Promise<void> {\n  await transporter.sendMail({\n    from: process.env.SMTP_FROM,\n    to: email,\n    subject: 'Withdrawal Processed',\n    html: `\n      <h2>Withdrawal Completed</h2>\n      <p>Your withdrawal has been processed successfully.</p>\n      <p><strong>Amount:</strong> ${amount} USDT</p>\n      <p><strong>Transaction Hash:</strong> ${txHash}</p>\n    `\n  })\n}\n\nexport async function sendEmailVerification(\n  email: string,\n  token: string\n): Promise<void> {\n  const verificationUrl = `${process.env.NEXT_PUBLIC_APP_URL}/auth/verify-email?token=${token}`\n  \n  await transporter.sendMail({\n    from: process.env.SMTP_FROM,\n    to: email,\n    subject: 'Verify Your Email',\n    html: `\n      <h2>Email Verification</h2>\n      <p>Please click the link below to verify your email address:</p>\n      <a href=\"${verificationUrl}\">${verificationUrl}</a>\n      <p>This link will expire in 24 hours.</p>\n    `\n  })\n}\n\nexport async function sendPasswordResetEmail(\n  email: string,\n  token: string\n): Promise<void> {\n  const resetUrl = `${process.env.NEXT_PUBLIC_APP_URL}/auth/reset-password?token=${token}`\n  \n  await transporter.sendMail({\n    from: process.env.SMTP_FROM,\n    to: email,\n    subject: 'Password Reset Request',\n    html: `\n      <h2>Password Reset</h2>\n      <p>Click the link below to reset your password:</p>\n      <a href=\"${resetUrl}\">${resetUrl}</a>\n      <p>This link will expire in 1 hour.</p>\n      <p>If you didn't request this, please ignore this email.</p>\n    `\n  })\n}\n\nexport async function notifyAdminNewWithdrawal(withdrawal: any): Promise<void> {\n  await transporter.sendMail({\n    from: process.env.SMTP_FROM,\n    to: process.env.ADMIN_EMAIL,\n    subject: 'New Withdrawal Request',\n    html: `\n      <h2>New Withdrawal Request</h2>\n      <p><strong>User:</strong> ${withdrawal.userId}</p>\n      <p><strong>Amount:</strong> ${withdrawal.amount} USDT</p>\n      <p><strong>Net Amount:</strong> ${withdrawal.netAmount} USDT</p>\n      <p><strong>Wallet:</strong> ${withdrawal.walletAddress}</p>\n      <p><strong>Network:</strong> ${withdrawal.network}</p>\n    `\n  })\n}\n\nexport async function sendAdminReminderEmail(withdrawal: any): Promise<void> {\n  await transporter.sendMail({\n    from: process.env.SMTP_FROM,\n    to: process.env.ADMIN_EMAIL,\n    subject: 'Pending Withdrawal Reminder',\n    html: `\n      <h2>Pending Withdrawal Reminder</h2>\n      <p>The following withdrawal has been pending for more than 24 hours:</p>\n      <p><strong>ID:</strong> ${withdrawal.id}</p>\n      <p><strong>Amount:</strong> ${withdrawal.netAmount} USDT</p>\n      <p><strong>User:</strong> ${withdrawal.user.email}</p>\n    `\n  })\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAAA;;AAGA,MAAM,cAAc,4JAAU,CAAC,eAAe,CAAC;IAC7C,MAAM,QAAQ,GAAG,CAAC,SAAS;IAC3B,MAAM,SAAS,QAAQ,GAAG,CAAC,SAAS,IAAI;IACxC,QAAQ;IACR,MAAM;QACJ,MAAM,QAAQ,GAAG,CAAC,SAAS;QAC3B,MAAM,QAAQ,GAAG,CAAC,SAAS;IAC7B;AACF;AAEO,eAAe,yBACpB,KAAa,EACb,MAAc,EACd,KAAa;IAEb,MAAM,YAAY,QAAQ,CAAC;QACzB,MAAM,QAAQ,GAAG,CAAC,SAAS;QAC3B,IAAI;QACJ,SAAS,CAAC,oBAAoB,EAAE,OAAO;QACvC,MAAM,CAAC;;;kCAGuB,EAAE,OAAO;iCACV,EAAE,MAAM;IACrC,CAAC;IACH;AACF;AAEO,eAAe,2BACpB,KAAa,EACb,MAAc,EACd,WAAwB;IAExB,MAAM,YAAY,QAAQ,CAAC;QACzB,MAAM,QAAQ,GAAG,CAAC,SAAS;QAC3B,IAAI;QACJ,SAAS;QACT,MAAM,CAAC;;;kCAGuB,EAAE,OAAO;gCACX,EAAE,YAAY;;IAE1C,CAAC;IACH;AACF;AAEO,eAAe,gCACpB,KAAa,EACb,MAAc,EACd,MAAc;IAEd,MAAM,YAAY,QAAQ,CAAC;QACzB,MAAM,QAAQ,GAAG,CAAC,SAAS;QAC3B,IAAI;QACJ,SAAS;QACT,MAAM,CAAC;;;kCAGuB,EAAE,OAAO;4CACC,EAAE,OAAO;IACjD,CAAC;IACH;AACF;AAEO,eAAe,sBACpB,KAAa,EACb,KAAa;IAEb,MAAM,kBAAkB,6DAAmC,yBAAyB,EAAE,OAAO;IAE7F,MAAM,YAAY,QAAQ,CAAC;QACzB,MAAM,QAAQ,GAAG,CAAC,SAAS;QAC3B,IAAI;QACJ,SAAS;QACT,MAAM,CAAC;;;eAGI,EAAE,gBAAgB,EAAE,EAAE,gBAAgB;;IAEjD,CAAC;IACH;AACF;AAEO,eAAe,uBACpB,KAAa,EACb,KAAa;IAEb,MAAM,WAAW,6DAAmC,2BAA2B,EAAE,OAAO;IAExF,MAAM,YAAY,QAAQ,CAAC;QACzB,MAAM,QAAQ,GAAG,CAAC,SAAS;QAC3B,IAAI;QACJ,SAAS;QACT,MAAM,CAAC;;;eAGI,EAAE,SAAS,EAAE,EAAE,SAAS;;;IAGnC,CAAC;IACH;AACF;AAEO,eAAe,yBAAyB,UAAe;IAC5D,MAAM,YAAY,QAAQ,CAAC;QACzB,MAAM,QAAQ,GAAG,CAAC,SAAS;QAC3B,IAAI,QAAQ,GAAG,CAAC,WAAW;QAC3B,SAAS;QACT,MAAM,CAAC;;gCAEqB,EAAE,WAAW,MAAM,CAAC;kCAClB,EAAE,WAAW,MAAM,CAAC;sCAChB,EAAE,WAAW,SAAS,CAAC;kCAC3B,EAAE,WAAW,aAAa,CAAC;mCAC1B,EAAE,WAAW,OAAO,CAAC;IACpD,CAAC;IACH;AACF;AAEO,eAAe,uBAAuB,UAAe;IAC1D,MAAM,YAAY,QAAQ,CAAC;QACzB,MAAM,QAAQ,GAAG,CAAC,SAAS;QAC3B,IAAI,QAAQ,GAAG,CAAC,WAAW;QAC3B,SAAS;QACT,MAAM,CAAC;;;8BAGmB,EAAE,WAAW,EAAE,CAAC;kCACZ,EAAE,WAAW,SAAS,CAAC;gCACzB,EAAE,WAAW,IAAI,CAAC,KAAK,CAAC;IACpD,CAAC;IACH;AACF"}},
    {"offset": {"line": 1735, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/LENOVO/Desktop/nsc-test/vercel-download/src/services/roiService.ts"],"sourcesContent":["import pool, { getClientWithTimeout } from '@/lib/db-connection'\nimport { getNextRoiDate } from '@/utils/calculations'\nimport { sendRoiNotificationEmail } from '@/utils/email'\nimport { v4 as uuidv4 } from 'uuid'\n\n/**\n * Distribute monthly ROI to all active packages\n * This runs as a cron job\n */\nexport async function distributeMonthlyRoi(): Promise<void> {\n  const today = new Date()\n\n  // Get a client for the entire operation to use advisory lock\n  let mainClient: Awaited<ReturnType<typeof getClientWithTimeout>>;\n  try {\n    mainClient = await getClientWithTimeout(15000);\n  } catch (error) {\n    console.error('‚ùå Failed to get database connection for ROI distribution:', error);\n    throw new Error('Database connection timeout during ROI distribution initialization');\n  }\n\n  let duePackages: any[] = [];\n\n  try {\n    await mainClient.query('BEGIN')\n\n    // CRITICAL: Use PostgreSQL advisory lock to prevent concurrent execution\n    // This ensures only one instance of the cron job can run at a time\n    const lockResult = await mainClient.query('SELECT pg_try_advisory_xact_lock(123456789) as acquired')\n\n    if (!lockResult.rows[0].acquired) {\n      console.log('‚ö†Ô∏è Another ROI distribution process is already running. Skipping.')\n      await mainClient.query('ROLLBACK')\n      mainClient.release()\n      return\n    }\n\n    console.log('üîí Advisory lock acquired for ROI distribution')\n\n    // Get all packages due for ROI payment with row-level lock\n    const packagesQuery = `\n      SELECT p.*, u.email as user_email, p.\"roiPercentage\"\n      FROM \"Package\" p\n      JOIN \"User\" u ON p.\"userId\" = u.id\n      WHERE p.status = 'ACTIVE'\n      AND p.\"isExpired\" = false\n      AND p.\"nextRoiDate\" <= $1\n      AND p.\"roiPaidCount\" < 12\n      FOR UPDATE OF p SKIP LOCKED\n    `\n\n    const result = await mainClient.query(packagesQuery, [today])\n    duePackages = result.rows\n\n    console.log(`Processing ROI for ${duePackages.length} packages`)\n\n    // KEEP THE LOCK - Don't commit yet, process all packages within the lock\n    // This prevents race conditions where multiple instances could process same packages\n  } catch (error) {\n    await mainClient.query('ROLLBACK')\n    mainClient.release()\n    throw error\n  }\n\n  let successCount = 0;\n  let errorCount = 0;\n  let emailErrorCount = 0;\n\n  for (const pkg of duePackages) {\n    let packageClient = null;\n    try {\n      // Validate package data\n      if (!pkg.id || !pkg.userId || !pkg.amount || !pkg.roiPercentage) {\n        console.error(`‚ùå Invalid package data for package ${pkg.id}:`, pkg);\n        errorCount++;\n        continue;\n      }\n\n      // FIX #7: Use package's contracted ROI%, not current DB settings\n      const packageAmount = Number(pkg.amount);\n      const roiPercentage = Number(pkg.roiPercentage);\n\n      if (isNaN(packageAmount) || isNaN(roiPercentage) || packageAmount <= 0 || roiPercentage <= 0) {\n        console.error(`‚ùå Invalid numeric values for package ${pkg.id}:`, {\n          amount: packageAmount,\n          roiPercentage: roiPercentage\n        });\n        errorCount++;\n        continue;\n      }\n\n      const roiAmount = Number(((packageAmount * roiPercentage) / 100).toFixed(2));\n      const nextMonth = pkg.roiPaidCount + 1\n\n      if (roiAmount <= 0 || isNaN(roiAmount)) {\n        console.error(`‚ùå Invalid ROI amount calculated for package ${pkg.id}: ${roiAmount}`);\n        errorCount++;\n        continue;\n      }\n\n      // FIX: Use mainClient to stay within advisory lock transaction\n      // This prevents race conditions and ensures consistency\n      packageClient = mainClient\n\n      // Create ROI payment record (within main transaction)\n      const roiPaymentId = uuidv4()\n      await packageClient.query(\n        `INSERT INTO \"RoiPayment\" (\"id\", \"packageId\", \"userId\", \"amount\", \"monthNumber\", \"paymentDate\", \"createdAt\")\n         VALUES ($1, $2, $3, $4, $5, $6, $7)`,\n        [roiPaymentId, pkg.id, pkg.userId, roiAmount, nextMonth, today, today]\n      )\n\n      // Create transaction record\n      const transactionId = uuidv4()\n      await packageClient.query(\n        `INSERT INTO \"Transaction\" (\"id\", \"userId\", \"type\", \"amount\", \"status\", \"description\", \"createdAt\", \"updatedAt\")\n         VALUES ($1, $2, $3, $4, $5, $6, $7, $8)`,\n        [transactionId, pkg.userId, 'ROI_PAYMENT', roiAmount, 'COMPLETED', `ROI payment - Month ${nextMonth}`, today, today]\n      )\n\n      // Update package\n      const nextRoiDate = getNextRoiDate(today, new Date(pkg.investmentDate))\n      const isComplete = nextMonth >= 12\n\n      await packageClient.query(\n        `UPDATE \"Package\"\n         SET \"totalRoiPaid\" = \"totalRoiPaid\" + $1,\n             \"roiPaidCount\" = $2,\n             \"lastRoiDate\" = $3,\n             \"nextRoiDate\" = $4,\n             \"status\" = $5,\n             \"isExpired\" = $6,\n             \"updatedAt\" = $7\n         WHERE \"id\" = $8`,\n        [\n          roiAmount,\n          nextMonth,\n          today,\n          isComplete ? null : nextRoiDate,\n          isComplete ? 'EXPIRED' : 'ACTIVE',\n          isComplete,\n          today,\n          pkg.id\n        ]\n      )\n\n      successCount++;\n      console.log(`‚úÖ Paid ROI: ${roiAmount} USDT to user ${pkg.userId} for package ${pkg.id} (${successCount}/${duePackages.length})`)\n\n      // Send notification email (non-blocking, errors logged but don't stop processing)\n      try {\n        await sendRoiNotificationEmail(pkg.user_email, roiAmount, nextMonth)\n      } catch (emailError) {\n        emailErrorCount++;\n        console.error(`‚ö†Ô∏è  Failed to send email for package ${pkg.id}:`, emailError);\n        // Don't throw - email failure shouldn't stop ROI distribution\n      }\n    } catch (error) {\n      errorCount++;\n      console.error(`‚ùå Error processing ROI for package ${pkg.id}:`, error)\n      // Don't throw - continue processing other packages\n    }\n  }\n\n  // FIX #1: Commit the main transaction and release the advisory lock after all packages processed\n  try {\n    await mainClient.query('COMMIT')\n    console.log(`‚úÖ ROI distribution completed: ${successCount} successful, ${errorCount} failed, ${emailErrorCount} email failures out of ${duePackages.length} total packages`)\n\n    // Alert if there were errors\n    if (errorCount > 0) {\n      console.warn(`‚ö†Ô∏è  WARNING: ${errorCount} packages failed to process. Manual review recommended.`);\n    }\n    if (emailErrorCount > 0) {\n      console.warn(`‚ö†Ô∏è  WARNING: ${emailErrorCount} notification emails failed to send.`);\n    }\n  } catch (error) {\n    await mainClient.query('ROLLBACK')\n    console.error('‚ùå Failed to commit ROI distribution transaction:', error);\n    throw error\n  } finally {\n    mainClient.release()\n  }\n}\n\n/**\n * Calculate user's withdrawable balance\n */\n/**\n * Get user's withdrawable balance using optimized SQL view (FAST VERSION)\n * This replaces 5 separate queries with 1 query to the UserStatisticsEnhanced view\n */\nexport async function getWithdrawableBalanceOptimized(userId: string): Promise<{\n  roiBalance: number\n  referralBalance: number\n  levelBalance: number\n  totalBalance: number\n  lockedCapital: number\n}> {\n  try {\n    // Use the SQL function that queries the optimized view\n    const result = await pool.query('SELECT * FROM get_user_balance($1)', [userId])\n    \n    if (result.rows.length === 0) {\n      // User not found or no data\n      return {\n        roiBalance: 0,\n        referralBalance: 0,\n        levelBalance: 0,\n        totalBalance: 0,\n        lockedCapital: 0\n      }\n    }\n    \n    const row = result.rows[0]\n\n    // Safely parse all values with validation\n    const roiBalance = Number(row.roiBalance ?? 0) || 0;\n    const referralBalance = Number(row.referralBalance ?? 0) || 0;\n    const levelBalance = Number(row.levelBalance ?? 0) || 0;\n    const totalBalance = Number(row.totalBalance ?? 0) || 0;\n    const lockedCapital = Number(row.lockedCapital ?? 0) || 0;\n\n    // Validate all values\n    if (isNaN(roiBalance) || isNaN(referralBalance) || isNaN(levelBalance) ||\n        isNaN(totalBalance) || isNaN(lockedCapital)) {\n      console.error('‚ùå Invalid optimized balance values:', {\n        roiBalance, referralBalance, levelBalance, totalBalance, lockedCapital\n      });\n      throw new Error('Invalid optimized balance calculation: NaN detected');\n    }\n\n    return {\n      roiBalance: Number(roiBalance.toFixed(2)),\n      referralBalance: Number(referralBalance.toFixed(2)),\n      levelBalance: Number(levelBalance.toFixed(2)),\n      totalBalance: Math.max(0, Number(totalBalance.toFixed(2))),\n      lockedCapital: Number(lockedCapital.toFixed(2))\n    }\n  } catch (error) {\n    console.error('‚ùå Error getting optimized balance:', error)\n    // Fallback to the original method\n    console.log('‚ö†Ô∏è  Falling back to original method...')\n    return getWithdrawableBalance(userId)\n  }\n}\n\n/**\n * Get user's withdrawable balance (LEGACY VERSION - 5 queries)\n * @deprecated Use getWithdrawableBalanceOptimized() instead for 80%+ performance improvement\n */\nexport async function getWithdrawableBalance(userId: string): Promise<{\n  roiBalance: number\n  referralBalance: number\n  levelBalance: number\n  totalBalance: number\n  lockedCapital: number\n}> {\n  // Retry logic for database operations\n  const maxRetries = 3;\n  let lastError: any;\n\n  for (let attempt = 1; attempt <= maxRetries; attempt++) {\n    try {\n      if (attempt > 1) {\n        console.log(`‚ö†Ô∏è  Retry attempt ${attempt}/${maxRetries} for balance calculation`);\n        // Wait before retry with exponential backoff\n        await new Promise(resolve => setTimeout(resolve, attempt * 1000));\n      }\n\n      // Prepare all SQL queries\n    const roiQuery = `\n      SELECT COALESCE(SUM(\"amount\")::numeric, 0) as sum_amount \n      FROM \"Transaction\" \n      WHERE \"userId\" = $1 \n      AND \"type\" = 'ROI_PAYMENT' \n      AND \"status\" = 'COMPLETED'\n    `;\n    \n    const referralQuery = `\n      SELECT COALESCE(SUM(\"amount\")::numeric, 0) as sum_amount\n      FROM \"Earning\"\n      WHERE \"userId\" = $1\n      AND \"earningType\" = 'DIRECT_REFERRAL'::\"EarningType\"\n    `;\n\n    const levelQuery = `\n      SELECT COALESCE(SUM(\"amount\")::numeric, 0) as sum_amount\n      FROM \"Earning\"\n      WHERE \"userId\" = $1\n      AND \"earningType\" = 'LEVEL_INCOME'::\"EarningType\"\n    `;\n    \n    const withdrawalQuery = `\n      SELECT COALESCE(SUM(\"amount\")::numeric, 0) as sum_amount \n      FROM \"Withdrawal\" \n      WHERE \"userId\" = $1 \n      AND \"status\" = 'COMPLETED'\n    `;\n    \n    const capitalQuery = `\n      SELECT COALESCE(SUM(\"amount\")::numeric, 0) as sum_amount \n      FROM \"Package\" \n      WHERE \"userId\" = $1 \n      AND \"status\" = 'ACTIVE'\n    `;\n    \n    // Execute all queries in parallel for better performance\n    const [\n      roiResult, \n      referralResult, \n      levelResult, \n      withdrawalResult, \n      capitalResult\n    ] = await Promise.all([\n      pool.query(roiQuery, [userId]),\n      pool.query(referralQuery, [userId]),\n      pool.query(levelQuery, [userId]),\n      pool.query(withdrawalQuery, [userId]),\n      pool.query(capitalQuery, [userId])\n    ]);\n    \n    // Extract and parse the values with safe fallbacks\n    const roiBalance = Number(roiResult.rows[0]?.sum_amount ?? 0) || 0;\n    const referralBalance = Number(referralResult.rows[0]?.sum_amount ?? 0) || 0;\n    const levelBalance = Number(levelResult.rows[0]?.sum_amount ?? 0) || 0;\n    const totalWithdrawn = Number(withdrawalResult.rows[0]?.sum_amount ?? 0) || 0;\n    const lockedCapital = Number(capitalResult.rows[0]?.sum_amount ?? 0) || 0;\n\n    // Validate all values are valid numbers\n    if (isNaN(roiBalance) || isNaN(referralBalance) || isNaN(levelBalance) ||\n        isNaN(totalWithdrawn) || isNaN(lockedCapital)) {\n      console.error('‚ùå Invalid balance values detected:', {\n        roiBalance, referralBalance, levelBalance, totalWithdrawn, lockedCapital\n      });\n      throw new Error('Invalid balance calculation: NaN detected');\n    }\n\n    // Calculate totals with precision handling\n    const totalEarned = Number((roiBalance + referralBalance + levelBalance).toFixed(2));\n    const totalBalance = Number((totalEarned - totalWithdrawn).toFixed(2));\n\n      return {\n        roiBalance: Number(roiBalance.toFixed(2)),\n        referralBalance: Number(referralBalance.toFixed(2)),\n        levelBalance: Number(levelBalance.toFixed(2)),\n        totalBalance: Math.max(0, totalBalance),\n        lockedCapital: Number(lockedCapital.toFixed(2))\n      };\n    } catch (error) {\n      lastError = error;\n      console.error(`‚ùå Error calculating withdrawable balance (attempt ${attempt}/${maxRetries}):`, error);\n\n      // If it's the last attempt, throw the error\n      if (attempt === maxRetries) {\n        throw new Error(`Failed to calculate balance after ${maxRetries} attempts: ${error instanceof Error ? error.message : 'Unknown error'}`);\n      }\n\n      // Continue to next retry attempt\n    }\n  }\n\n  // This should never be reached, but TypeScript needs it\n  throw lastError;\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2071, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/LENOVO/Desktop/nsc-test/vercel-download/src/app/api/earnings/summary/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server'\nimport { authenticateToken } from '@/middleware/auth'\nimport { getWithdrawableBalanceOptimized } from '@/services/roiService'\n\nexport async function GET(request: NextRequest) {\n  // Authenticate user\n  const authResult = await authenticateToken(request)\n  if (authResult instanceof NextResponse) return authResult\n\n  const { user } = authResult\n\n  try {\n    // Get complete earnings summary with fallback\n    let balance\n    try {\n      balance = await getWithdrawableBalanceOptimized(user.userId)\n    } catch (error) {\n      console.error('Optimized balance fetch failed, using fallback:', error)\n      // Fallback is already handled in getWithdrawableBalanceOptimized\n      // But just in case, return zeros\n      balance = {\n        roiBalance: 0,\n        referralBalance: 0,\n        levelBalance: 0,\n        totalBalance: 0,\n        lockedCapital: 0\n      }\n    }\n\n    // Ensure all values are numbers\n    const safeNumber = (val: any) => Number(val) || 0\n\n    const summary = {\n      totalEarnings: safeNumber(balance.roiBalance) + safeNumber(balance.referralBalance) + safeNumber(balance.levelBalance),\n      roiEarnings: safeNumber(balance.roiBalance),\n      referralEarnings: safeNumber(balance.referralBalance),\n      levelEarnings: safeNumber(balance.levelBalance),\n      withdrawableBalance: safeNumber(balance.totalBalance),\n      lockedCapital: safeNumber(balance.lockedCapital)\n    }\n\n    console.log(`üìä Earnings summary for user ${user.userId}:`, summary)\n\n    return NextResponse.json({\n      success: true,\n      summary\n    })\n\n  } catch (error: any) {\n    console.error('Get earnings summary error:', error)\n    return NextResponse.json(\n      {\n        error: 'Failed to fetch earnings summary',\n        message: error.message || 'An unexpected error occurred',\n        // Return zeros as fallback\n        summary: {\n          totalEarnings: 0,\n          roiEarnings: 0,\n          referralEarnings: 0,\n          levelEarnings: 0,\n          withdrawableBalance: 0,\n          lockedCapital: 0\n        }\n      },\n      { status: 500 }\n    )\n  }\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;;;;;;AAEO,eAAe,IAAI,OAAoB;IAC5C,oBAAoB;IACpB,MAAM,aAAa,MAAM,IAAA,yIAAiB,EAAC;IAC3C,IAAI,sBAAsB,gJAAY,EAAE,OAAO;IAE/C,MAAM,EAAE,IAAI,EAAE,GAAG;IAEjB,IAAI;QACF,8CAA8C;QAC9C,IAAI;QACJ,IAAI;YACF,UAAU,MAAM,IAAA,2JAA+B,EAAC,KAAK,MAAM;QAC7D,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,mDAAmD;YACjE,iEAAiE;YACjE,iCAAiC;YACjC,UAAU;gBACR,YAAY;gBACZ,iBAAiB;gBACjB,cAAc;gBACd,cAAc;gBACd,eAAe;YACjB;QACF;QAEA,gCAAgC;QAChC,MAAM,aAAa,CAAC,MAAa,OAAO,QAAQ;QAEhD,MAAM,UAAU;YACd,eAAe,WAAW,QAAQ,UAAU,IAAI,WAAW,QAAQ,eAAe,IAAI,WAAW,QAAQ,YAAY;YACrH,aAAa,WAAW,QAAQ,UAAU;YAC1C,kBAAkB,WAAW,QAAQ,eAAe;YACpD,eAAe,WAAW,QAAQ,YAAY;YAC9C,qBAAqB,WAAW,QAAQ,YAAY;YACpD,eAAe,WAAW,QAAQ,aAAa;QACjD;QAEA,QAAQ,GAAG,CAAC,CAAC,6BAA6B,EAAE,KAAK,MAAM,CAAC,CAAC,CAAC,EAAE;QAE5D,OAAO,gJAAY,CAAC,IAAI,CAAC;YACvB,SAAS;YACT;QACF;IAEF,EAAE,OAAO,OAAY;QACnB,QAAQ,KAAK,CAAC,+BAA+B;QAC7C,OAAO,gJAAY,CAAC,IAAI,CACtB;YACE,OAAO;YACP,SAAS,MAAM,OAAO,IAAI;YAC1B,2BAA2B;YAC3B,SAAS;gBACP,eAAe;gBACf,aAAa;gBACb,kBAAkB;gBAClB,eAAe;gBACf,qBAAqB;gBACrB,eAAe;YACjB;QACF,GACA;YAAE,QAAQ;QAAI;IAElB;AACF"}}]
}