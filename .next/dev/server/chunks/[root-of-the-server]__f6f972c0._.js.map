{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 82, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/LENOVO/Desktop/nsc-test/vercel-download/src/lib/db-connection.ts"],"sourcesContent":["import { Pool } from 'pg'\n\n// Load environment variables only in development\nif (process.env.NODE_ENV !== 'production') {\n  try {\n    const dotenv = require('dotenv')\n    dotenv.config()\n  } catch (error) {\n    // dotenv is optional, might not be installed in production\n    console.log('dotenv not available, using system environment variables')\n  }\n}\n\n// Parse DATABASE_URL to handle Neon and other providers\nconst getDatabaseConfig = () => {\n  const connectionString = process.env.DATABASE_URL\n\n  if (!connectionString) {\n    console.error('‚ùå DATABASE_URL is not defined in environment variables')\n    console.error('Please ensure your .env file contains a valid DATABASE_URL')\n    throw new Error('DATABASE_URL is not defined in environment variables')\n  }\n\n  // For Neon and other cloud providers, always use SSL\n  const isCloudProvider = connectionString.includes('neon.tech') ||\n                         connectionString.includes('supabase.co') ||\n                         connectionString.includes('amazonaws.com') ||\n                         connectionString.includes('azure.com')\n\n  // For Neon, we need specific SSL settings\n  const isNeon = connectionString.includes('neon.tech')\n\n  // SSL configuration based on provider\n  const sslConfig = isNeon\n    ? {\n        rejectUnauthorized: false,\n        ca: null,\n        checkServerIdentity: () => undefined\n      }\n    : { rejectUnauthorized: process.env.DB_SSL_REJECT_UNAUTHORIZED !== 'false' }\n\n  // Optimized configuration for NeonDB\n  return {\n    connectionString,\n    ssl: isCloudProvider ? sslConfig : false,\n    max: 20, // ‚úÖ Increased pool size for better concurrent request handling\n    min: 5, // ‚úÖ Keep more connections warm to avoid timeouts\n    idleTimeoutMillis: 60000, // 60 seconds idle timeout (increased)\n    connectionTimeoutMillis: 20000, // 20 seconds connection timeout (increased)\n    allowExitOnIdle: false, // ‚úÖ Don't exit on idle to maintain connections\n    statement_timeout: 60000, // 60 seconds (increased)\n    query_timeout: 60000, // 60 seconds (increased)\n    keepAlive: true, // ‚úÖ Keep connections alive\n    keepAliveInitialDelayMillis: 5000, // 5 seconds\n    // Additional Neon-specific optimizations\n    application_name: 'nsc-bot-platform',\n    idle_in_transaction_session_timeout: 120000 // 2 minutes (increased)\n  }\n}\n\n// Single pool instance - NO resets, NO lazy initialization\nlet pool: Pool | null = null;\nlet isInitializing = false;\n\nconst getPool = () => {\n  // Create pool only once\n  if (!pool && !isInitializing) {\n    isInitializing = true;\n    try {\n      pool = new Pool(getDatabaseConfig());\n\n      // Add error handling for the pool - DO NOT reset pool or exit process\n      pool.on('error', (err) => {\n        console.error('‚ùå Unexpected error on idle client:', err);\n        console.error('Connection will be removed from pool and recreated automatically');\n        // ‚úÖ Let pg handle reconnection automatically - don't reset pool\n      });\n\n      // Only log connection events when VERBOSE_DB_LOGS is set (not during build)\n      const isBuilding = process.env.NEXT_PHASE === 'phase-production-build';\n      const shouldLog = !isBuilding && (process.env.NODE_ENV !== 'production' || process.env.VERBOSE_DB_LOGS === 'true');\n\n      if (shouldLog) {\n        pool.on('connect', (client) => {\n          console.log('‚úÖ New client connected to NeonDB');\n        });\n\n        pool.on('remove', (client) => {\n          console.log('üîå Client removed from pool');\n        });\n      }\n\n      if (!isBuilding) {\n        console.log('üöÄ Database pool initialized for NeonDB');\n      }\n    } catch (error) {\n      isInitializing = false;\n      console.error('‚ùå Failed to initialize database pool:', error);\n      throw error;\n    } finally {\n      isInitializing = false;\n    }\n  }\n\n  // Wait for initialization if it's in progress\n  while (isInitializing && !pool) {\n    // Busy wait - this is acceptable because initialization is fast\n  }\n\n  return pool!;\n};\n\n// Test database connection\nexport async function testConnection() {\n  let client\n  try {\n    const poolInstance = getPool();\n    client = await poolInstance.connect()\n    const result = await client.query('SELECT NOW()')\n    console.log('Database connection successful:', result.rows[0])\n    return true\n  } catch (err) {\n    console.error('Database connection error:', err)\n    return false\n  } finally {\n    if (client) client.release()\n  }\n}\n\n// Warmup database connection - call this on server start (NOT during build)\nexport async function warmupConnection() {\n  // Skip warmup during build phase\n  const isBuilding = process.env.NEXT_PHASE === 'phase-production-build';\n  if (isBuilding) {\n    return;\n  }\n\n  console.log('üî• Warming up database connection...')\n\n  try {\n    // Try to establish a connection and run a simple query\n    const success = await testConnection()\n\n    if (success) {\n      console.log('‚úÖ Database connection warmed up successfully')\n\n      // Pre-establish a connection in the pool\n      const poolInstance = getPool();\n      const client = await poolInstance.connect()\n\n      // Keep the connection alive briefly then release\n      setTimeout(() => {\n        client.release()\n        console.log('üîå Warmup connection released')\n      }, 1000)\n\n    } else {\n      console.warn('‚ö†Ô∏è Database warmup failed, but continuing...')\n    }\n  } catch (error: any) {\n    console.warn('‚ö†Ô∏è Database warmup error:', error?.message || 'Unknown error')\n  }\n}\n\n// Export a proxy that lazily initializes the pool\nconst poolProxy = new Proxy({} as Pool, {\n  get(target, prop) {\n    const poolInstance = getPool();\n    return poolInstance[prop as keyof Pool];\n  }\n});\n\n/**\n * Get a database client with timeout protection\n * @param timeoutMs Timeout in milliseconds (default: 20000ms)\n * @returns Database client\n * @throws Error if connection times out or fails\n */\nexport async function getClientWithTimeout(timeoutMs: number = 20000) {\n  const poolInstance = getPool();\n  \n  return Promise.race([\n    poolInstance.connect(),\n    new Promise<never>((_, reject) => \n      setTimeout(() => reject(new Error(`Database connection timeout after ${timeoutMs}ms`)), timeoutMs)\n    )\n  ]);\n}\n\n/**\n * Execute a query with timeout protection\n * @param query SQL query string\n * @param params Query parameters\n * @param timeoutMs Query timeout in milliseconds (default: 20000ms)\n * @returns Query result\n */\nexport async function queryWithTimeout(query: string, params: any[] = [], timeoutMs: number = 20000) {\n  let client;\n  try {\n    client = await getClientWithTimeout(timeoutMs);\n    \n    const queryPromise = client.query(query, params);\n    const timeoutPromise = new Promise<never>((_, reject) => \n      setTimeout(() => reject(new Error(`Query timeout after ${timeoutMs}ms`)), timeoutMs)\n    );\n    \n    return await Promise.race([queryPromise, timeoutPromise]);\n  } finally {\n    if (client) {\n      client.release();\n    }\n  }\n}\n\n// Export the pool for use in other modules\nexport default poolProxy\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 271, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/LENOVO/Desktop/nsc-test/vercel-download/src/lib/db.ts"],"sourcesContent":["/**\n * Pure PostgreSQL Database Layer\n * NO PRISMA. NO ORM. Just direct SQL via pg driver.\n * Neon DB (Serverless PostgreSQL)\n */\n\nimport pool from './db-connection'\n\n// Helper to convert snake_case to camelCase\nfunction toCamelCase(obj: any): any {\n  if (Array.isArray(obj)) {\n    return obj.map(toCamelCase)\n  }\n  if (obj !== null && typeof obj === 'object') {\n    return Object.keys(obj).reduce((acc, key) => {\n      const camelKey = key.replace(/_([a-z])/g, (g) => g[1].toUpperCase())\n      acc[camelKey] = toCamelCase(obj[key])\n      return acc\n    }, {} as any)\n  }\n  return obj\n}\n\n// Helper to convert camelCase to snake_case\nfunction toSnakeCase(obj: any): any {\n  if (obj instanceof Date) return obj.toISOString()\n  if (Array.isArray(obj)) return obj.map(toSnakeCase)\n  if (obj !== null && typeof obj === 'object') {\n    const result: any = {}\n    for (const key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        result[key] = toSnakeCase(obj[key])\n      }\n    }\n    return result\n  }\n  return obj\n}\n\n/**\n * Execute any PostgreSQL query and return rows\n * @example\n * const users = await query<User>('SELECT * FROM \"User\" WHERE \"isActive\" = $1', [true])\n */\nexport async function query<T = any>(sql: string, params: any[] = []): Promise<T[]> {\n  // Validate that sql is actually a string\n  if (typeof sql !== 'string' || sql.trim().length === 0) {\n    const error = new Error('A query must have either text or a name. Supplying neither is unsupported.')\n    console.error('PostgreSQL Error:', {\n      message: error.message,\n      sql: sql,\n      code: undefined,\n    })\n    throw error\n  }\n\n  try {\n    const result = await pool.query(sql, params)\n    return result.rows as T[]\n  } catch (error: any) {\n    console.error('PostgreSQL Error:', {\n      message: error.message,\n      sql: typeof sql === 'string' ? sql.substring(0, 200) : sql,\n      code: error.code,\n    })\n    throw error\n  }\n}\n\n/**\n * Get a single row from query (or null)\n * @example\n * const user = await queryOne<User>('SELECT * FROM \"User\" WHERE \"id\" = $1', [userId])\n */\nexport async function queryOne<T = any>(sql: string, params: any[] = []): Promise<T | null> {\n  const rows = await query<T>(sql, params)\n  return rows.length > 0 ? rows[0] : null\n}\n\n/**\n * Get a single scalar value (for COUNT, SUM, MAX, AVG, etc.)\n * @example\n * const count = await queryScalar<number>('SELECT COUNT(*) as count FROM \"User\"')\n */\nexport async function queryScalar<T = any>(sql: string, params: any[] = []): Promise<T | null> {\n  const rows = await query<any>(sql, params)\n  if (rows.length === 0) return null\n  const firstValue = Object.values(rows[0])[0]\n  return firstValue as T\n}\n\n/**\n * Execute INSERT/UPDATE/DELETE query\n * Returns number of affected rows\n * @example\n * const count = await execute('UPDATE \"User\" SET \"isActive\" = $1 WHERE \"id\" = $2', [true, userId])\n */\nexport async function execute(sql: string, params: any[] = []): Promise<number> {\n  // Validate that sql is actually a string\n  if (typeof sql !== 'string' || sql.trim().length === 0) {\n    const error = new Error('A query must have either text or a name. Supplying neither is unsupported.')\n    console.error('PostgreSQL Error:', {\n      message: error.message,\n      sql: sql,\n      code: undefined,\n    })\n    throw error\n  }\n\n  try {\n    const result = await pool.query(sql, params)\n    return result.rowCount || 0\n  } catch (error: any) {\n    console.error('PostgreSQL Error:', {\n      message: error.message,\n      sql: typeof sql === 'string' ? sql.substring(0, 200) : sql,\n      code: error.code,\n    })\n    throw error\n  }\n}\n\n/**\n * Run multiple queries atomically in a transaction\n * Automatically COMMIT on success or ROLLBACK on error\n * @example\n * await transaction(async (client) => {\n *   await client.query('INSERT INTO \"User\" VALUES (...)')\n *   await client.query('UPDATE \"Package\" SET ...')\n * })\n */\nexport async function transaction<T>(\n  callback: (client: any) => Promise<T>\n): Promise<T> {\n  const client = await pool.connect()\n  try {\n    await client.query('BEGIN')\n    const result = await callback(client)\n    await client.query('COMMIT')\n    return result\n  } catch (error) {\n    await client.query('ROLLBACK')\n    throw error\n  } finally {\n    client.release()\n  }\n}\n\n/**\n * Disconnect from database (graceful shutdown)\n */\nexport async function disconnect(): Promise<void> {\n  await pool.end()\n}\n\n// Re-export pool for advanced use cases\nexport { pool }\n\n// Export helpers for use in refactored code\nexport { toCamelCase, toSnakeCase }\n\n/**\n * SQL translator - Converts SQL-style calls to pure queries\n * Translates ALL SQL calls to direct database queries underneath\n * This allows 60+ existing files to work while transitioning to pure SQL\n */\nexport const prisma: any = new Proxy({}, {\n  get: (target, table: string | symbol) => {\n    if (typeof table !== 'string') return undefined\n    \n    return {\n      async findUnique({ where, select }: any) {\n        const [key, value] = Object.entries(where)[0] as [string, any]\n        const fields = select ? Object.keys(select).map(k => `\"${k}\"`).join(', ') : '*'\n        const row = await queryOne(\n          `SELECT ${fields} FROM \"${table}\" WHERE \"${key}\" = $1 LIMIT 1`,\n          [value]\n        )\n        return row ? toCamelCase(row) : null\n      },\n      \n      async findMany({ where, select, orderBy, take, skip }: any = {}) {\n        const params: any[] = []\n        const fields = select ? Object.keys(select).map(k => `\"${k}\"`).join(', ') : '*'\n        let sql = `SELECT ${fields} FROM \"${table}\"`\n\n        if (where) {\n          const conditions: string[] = []\n          for (const [key, value] of Object.entries(where)) {\n            if (value === null) {\n              conditions.push(`\"${key}\" IS NULL`)\n            } else if (typeof value === 'object' && value !== null) {\n              // Handle various operators\n              if ('in' in value) {\n                const placeholders = (value as any).in.map((_: any, i: number) => `$${params.length + i + 1}`).join(', ')\n                params.push(...(value as any).in)\n                conditions.push(`\"${key}\" IN (${placeholders})`)\n              } else if ('notIn' in value) {\n                const placeholders = (value as any).notIn.map((_: any, i: number) => `$${params.length + i + 1}`).join(', ')\n                params.push(...(value as any).notIn)\n                conditions.push(`\"${key}\" NOT IN (${placeholders})`)\n              } else if ('lt' in value) {\n                params.push((value as any).lt)\n                conditions.push(`\"${key}\" < $${params.length}`)\n              } else if ('lte' in value) {\n                params.push((value as any).lte)\n                conditions.push(`\"${key}\" <= $${params.length}`)\n              } else if ('gt' in value) {\n                params.push((value as any).gt)\n                conditions.push(`\"${key}\" > $${params.length}`)\n              } else if ('gte' in value) {\n                params.push((value as any).gte)\n                conditions.push(`\"${key}\" >= $${params.length}`)\n              } else if ('contains' in value) {\n                params.push(`%${(value as any).contains}%`)\n                conditions.push(`\"${key}\" ILIKE $${params.length}`)\n              } else if ('startsWith' in value) {\n                params.push(`${(value as any).startsWith}%`)\n                conditions.push(`\"${key}\" ILIKE $${params.length}`)\n              } else if ('endsWith' in value) {\n                params.push(`%${(value as any).endsWith}`)\n                conditions.push(`\"${key}\" ILIKE $${params.length}`)\n              } else if ('not' in value) {\n                params.push((value as any).not)\n                conditions.push(`\"${key}\" != $${params.length}`)\n              } else {\n                // Fallback: treat as direct value\n                params.push(value)\n                conditions.push(`\"${key}\" = $${params.length}`)\n              }\n            } else {\n              params.push(value)\n              conditions.push(`\"${key}\" = $${params.length}`)\n            }\n          }\n          if (conditions.length) sql += ` WHERE ${conditions.join(' AND ')}`\n        }\n\n        if (orderBy) {\n          const orderClauses: string[] = []\n          for (const [field, dir] of Object.entries(orderBy)) {\n            orderClauses.push(`\"${field}\" ${(dir as string).toUpperCase()}`)\n          }\n          sql += ` ORDER BY ${orderClauses.join(', ')}`\n        }\n\n        if (take) sql += ` LIMIT ${take}`\n        if (skip) sql += ` OFFSET ${skip}`\n\n        const rows = await query(sql, params)\n        return rows.map(r => toCamelCase(r))\n      },\n      \n      async findFirst({ where, select, orderBy }: any) {\n        // Use findMany with take: 1 to reuse the logic\n        const result = await this.findMany({ where, select, orderBy, take: 1 })\n        return result.length > 0 ? result[0] : null\n      },\n      \n      async count({ where }: any = {}) {\n        const params: any[] = []\n        let sql = `SELECT COUNT(*) as cnt FROM \"${table}\"`\n\n        if (where) {\n          const conditions: string[] = []\n          for (const [key, value] of Object.entries(where)) {\n            if (value === null) {\n              conditions.push(`\"${key}\" IS NULL`)\n            } else if (typeof value === 'object' && value !== null) {\n              // Handle operators for count\n              if ('in' in value) {\n                const placeholders = (value as any).in.map((_: any, i: number) => `$${params.length + i + 1}`).join(', ')\n                params.push(...(value as any).in)\n                conditions.push(`\"${key}\" IN (${placeholders})`)\n              } else if ('not' in value) {\n                params.push((value as any).not)\n                conditions.push(`\"${key}\" != $${params.length}`)\n              } else {\n                params.push(value)\n                conditions.push(`\"${key}\" = $${params.length}`)\n              }\n            } else {\n              params.push(value)\n              conditions.push(`\"${key}\" = $${params.length}`)\n            }\n          }\n          if (conditions.length) sql += ` WHERE ${conditions.join(' AND ')}`\n        }\n\n        const row = await queryOne<any>(sql, params)\n        return row ? parseInt(row.cnt) : 0\n      },\n      \n      async create({ data, select }: any) {\n        const keys = Object.keys(data)\n        const values = Object.values(data)\n        const placeholders = keys.map((_, i) => `$${i + 1}`).join(', ')\n        const keyString = keys.map(k => `\"${k}\"`).join(', ')\n        const fields = select ? Object.keys(select).map(k => `\"${k}\"`).join(', ') : '*'\n        \n        const row = await queryOne(\n          `INSERT INTO \"${table}\" (${keyString}) VALUES (${placeholders}) RETURNING ${fields}`,\n          values\n        )\n        return row ? toCamelCase(row) : null\n      },\n      \n      async update({ where, data, select }: any) {\n        const params: any[] = []\n        const sets: string[] = []\n\n        // Build SET clause\n        for (const [key, value] of Object.entries(data)) {\n          if (value !== undefined) {\n            if (typeof value === 'object' && value !== null) {\n              // Handle increment/decrement operations\n              if ('increment' in value) {\n                params.push((value as any).increment)\n                sets.push(`\"${key}\" = COALESCE(\"${key}\", 0) + $${params.length}`)\n              } else if ('decrement' in value) {\n                params.push((value as any).decrement)\n                sets.push(`\"${key}\" = COALESCE(\"${key}\", 0) - $${params.length}`)\n              } else {\n                // Regular object value\n                params.push(JSON.stringify(value))\n                sets.push(`\"${key}\" = $${params.length}`)\n              }\n            } else {\n              params.push(value)\n              sets.push(`\"${key}\" = $${params.length}`)\n            }\n          }\n        }\n\n        // Build WHERE clause\n        const whereConditions: string[] = []\n        for (const [key, value] of Object.entries(where)) {\n          params.push(value)\n          whereConditions.push(`\"${key}\" = $${params.length}`)\n        }\n\n        const fields = select ? Object.keys(select).map(k => `\"${k}\"`).join(', ') : '*'\n        const row = await queryOne(\n          `UPDATE \"${table}\" SET ${sets.join(', ')} WHERE ${whereConditions.join(' AND ')} RETURNING ${fields}`,\n          params\n        )\n        return row ? toCamelCase(row) : null\n      },\n      \n      async delete({ where }: any) {\n        const [key, value] = Object.entries(where)[0] as [string, any]\n        await execute(`DELETE FROM \"${table}\" WHERE \"${key}\" = $1`, [value])\n        return {}\n      },\n      \n      async deleteMany({ where }: any = {}) {\n        const params: any[] = []\n        let sql = `DELETE FROM \"${table}\"`\n        \n        if (where) {\n          const conditions: string[] = []\n          for (const [key, value] of Object.entries(where)) {\n            params.push(value)\n            conditions.push(`\"${key}\" = $${params.length}`)\n          }\n          if (conditions.length) sql += ` WHERE ${conditions.join(' AND ')}`\n        }\n        \n        const count = await execute(sql, params)\n        return { count }\n      },\n      \n      async aggregate({ where, _sum, _count }: any) {\n        const params: any[] = []\n        const aggs: string[] = []\n        \n        if (_sum) {\n          Object.keys(_sum).forEach(field => {\n            aggs.push(`SUM(\"${field}\") as sum_${field}`)\n          })\n        }\n        if (_count) aggs.push('COUNT(*) as cnt')\n        \n        let sql = `SELECT ${aggs.join(', ')} FROM \"${table}\"`\n        \n        if (where) {\n          const conditions: string[] = []\n          for (const [key, value] of Object.entries(where)) {\n            params.push(value)\n            conditions.push(`\"${key}\" = $${params.length}`)\n          }\n          if (conditions.length) sql += ` WHERE ${conditions.join(' AND ')}`\n        }\n        \n        const row = await queryOne<any>(sql, params)\n        const result: any = {}\n        if (_sum && row) {\n          result._sum = {}\n          Object.keys(_sum).forEach(field => {\n            result._sum[field] = row[`sum_${field}`] ? parseFloat(row[`sum_${field}`]) : 0\n          })\n        }\n        if (_count && row) result._count = row.cnt ? parseInt(row.cnt) : 0\n        return result\n      },\n      \n      async groupBy({ by, _count, _sum, where }: any) {\n        const params: any[] = []\n        const fields = (Array.isArray(by) ? by : [by]).map(f => `\"${f}\"`)\n        const aggs: string[] = []\n        \n        if (_count) aggs.push('COUNT(*) as cnt')\n        if (_sum) {\n          Object.keys(_sum).forEach(field => {\n            aggs.push(`SUM(\"${field}\") as sum_${field}`)\n          })\n        }\n        \n        let sql = `SELECT ${fields.join(', ')}${aggs.length ? ', ' + aggs.join(', ') : ''} FROM \"${table}\"`\n        \n        if (where) {\n          const conditions: string[] = []\n          for (const [key, value] of Object.entries(where)) {\n            params.push(value)\n            conditions.push(`\"${key}\" = $${params.length}`)\n          }\n          if (conditions.length) sql += ` WHERE ${conditions.join(' AND ')}`\n        }\n        \n        sql += ` GROUP BY ${fields.join(', ')}`\n        const rows = await query(sql, params)\n        \n        return rows.map((row: any) => {\n          const transformed: any = {}\n          (Array.isArray(by) ? by : [by]).forEach(field => {\n            transformed[field] = row[field]\n          })\n          if (_count) transformed._count = row.cnt ? parseInt(row.cnt) : 0\n          if (_sum) {\n            transformed._sum = {}\n            Object.keys(_sum).forEach(field => {\n              transformed._sum[field] = row[`sum_${field}`] ? parseFloat(row[`sum_${field}`]) : 0\n            })\n          }\n          return transformed\n        })\n      },\n      \n      async upsert({ where, create, update }: any) {\n        const existing = await this.findUnique({ where })\n        return existing ? this.update({ where, data: update }) : this.create({ data: create })\n      }\n    }\n  }\n})\n\n// Support for await transaction\nexport const $transaction = transaction\n\nexport default {\n  query,\n  queryOne,\n  queryScalar,\n  execute,\n  transaction,\n  disconnect,\n  pool,\n  toCamelCase,\n  toSnakeCase,\n  prisma,\n  $transaction,\n}"],"names":[],"mappings":"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"}},
    {"offset": {"line": 723, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/LENOVO/Desktop/nsc-test/vercel-download/src/utils/server-helpers.ts"],"sourcesContent":["/**\n * Server-only helper functions\n * These use Node.js modules and should only be imported in API routes\n */\n\nimport bcrypt from 'bcrypt'\nimport jwt, { SignOptions, Secret } from 'jsonwebtoken'\nimport crypto from 'crypto'\nimport { JwtPayload } from '@/types/api'\nimport { queryOne, execute, transaction } from '@/lib/db'\n\n/**\n * Hash password\n */\nexport async function hashPassword(password: string): Promise<string> {\n  return await bcrypt.hash(password, 10)\n}\n\n/**\n * Compare password\n */\nexport async function comparePassword(\n  password: string,\n  hash: string\n): Promise<boolean> {\n  return await bcrypt.compare(password, hash)\n}\n\n/**\n * Generate JWT token\n */\nexport function generateToken(payload: Partial<JwtPayload>, expiresIn: string = '24h'): string {\n  if (!process.env.JWT_SECRET) {\n    throw new Error('JWT_SECRET is not defined in environment variables')\n  }\n  // Cast secret to Secret to satisfy TypeScript overloads\n  const secret: Secret = process.env.JWT_SECRET as Secret || 'fallback-secret'\n  // jwt.sign typings are picky about the secret type and options; cast to any\n  return jwt.sign(payload as any, secret as any, { expiresIn } as any);\n}\n\n/**\n * Generate refresh token\n */\nexport function generateRefreshToken(payload: Partial<JwtPayload>): string {\n  if (!process.env.JWT_REFRESH_SECRET) {\n    throw new Error('JWT_REFRESH_SECRET is not defined in environment variables')\n  }\n  const tokenPayload = {\n    ...payload,\n    type: 'refresh'\n  }\n  const refreshSecret: Secret = process.env.JWT_REFRESH_SECRET as Secret || 'fallback-refresh-secret'\n  return jwt.sign(tokenPayload as any, refreshSecret, { expiresIn: '7d' });\n}\n\n/**\n * Verify JWT token\n */\nexport function verifyToken(token: string): JwtPayload | null {\n  try {\n    if (!process.env.JWT_SECRET) {\n      throw new Error('JWT_SECRET is not defined in environment variables')\n    }\n    const decoded = jwt.verify(token, process.env.JWT_SECRET);\n    if (typeof decoded === 'string') {\n      return null;\n    }\n    return decoded as JwtPayload;\n  } catch (error) {\n    return null\n  }\n}\n\n/**\n * Verify refresh token\n */\nexport function verifyRefreshToken(token: string): JwtPayload | null {\n  try {\n    if (!process.env.JWT_REFRESH_SECRET) {\n      throw new Error('JWT_REFRESH_SECRET is not defined in environment variables')\n    }\n    const decoded = jwt.verify(token, process.env.JWT_REFRESH_SECRET);\n    if (typeof decoded === 'string') {\n      return null;\n    }\n    return decoded as JwtPayload;\n  } catch (error) {\n    return null\n  }\n}\n\n/**\n * Generate random token\n */\nexport function generateRandomToken(): string {\n  return crypto.randomBytes(32).toString('hex')\n}\n\n/**\n * Generate unique referral code (DEPRECATED - use getNextReferralCode instead)\n * Kept for backward compatibility\n */\nexport function generateReferralCode(username: string): string {\n  const random = crypto.randomBytes(3).toString('hex').toUpperCase()\n  const userPrefix = username.substring(0, 3).toUpperCase()\n  return `${userPrefix}${random}`\n}\n\n/**\n * Get next sequential referral code (NSCREF1001, NSCREF1002, etc.)\n * This is the code users share with others\n * Uses a transaction to prevent race conditions\n */\nexport async function getNextReferralCode(): Promise<string> {\n  // Use a transaction to ensure atomicity and prevent race conditions\n  const result = await transaction(async (client: any) => {\n    // First, try to find the existing counter\n    let counter = await queryOne<any>(\n      `SELECT * FROM \"ReferralCounter\" WHERE \"counterType\" = 'NSCREF'`,\n      []\n    );\n\n    // If counter doesn't exist, create it with initial value\n    if (!counter) {\n      counter = await queryOne<any>(\n        `INSERT INTO \"ReferralCounter\" (\"counterType\", \"currentValue\") \n         VALUES ('NSCREF', 1001) RETURNING *`,\n        []\n      );\n    } else {\n      // Increment the counter\n      counter = await queryOne<any>(\n        `UPDATE \"ReferralCounter\" SET \"currentValue\" = \"currentValue\" + 1 \n         WHERE \"counterType\" = 'NSCREF' RETURNING *`,\n        []\n      );\n    }\n\n    return counter;\n  });\n  \n  // The result is the counter object\n  const counter = result;\n  \n  // Double-check that the code is unique\n  const codeToUse = `NSCREF${counter.currentValue}`;\n  const existingUser = await queryOne<any>(\n    `SELECT * FROM \"User\" WHERE \"referralCode\" = $1`,\n    [codeToUse]\n  );\n  \n  // In the extremely unlikely case of a collision, add a random suffix\n  if (existingUser) {\n    const randomSuffix = Math.floor(Math.random() * 1000).toString().padStart(3, '0');\n    return `NSCREF${counter.currentValue}_${randomSuffix}`;\n  }\n  \n  return codeToUse;\n}\n\n// NEWNCS function has been completely removed as it's no longer needed\n// All users must now register with a valid referral code\n"],"names":[],"mappings":"AAAA;;;CAGC;;;;;;;;;;;;;;;;;;;;AAED;AACA;AACA;AAEA;;;;;;;;;AAKO,eAAe,aAAa,QAAgB;IACjD,OAAO,MAAM,gHAAM,CAAC,IAAI,CAAC,UAAU;AACrC;AAKO,eAAe,gBACpB,QAAgB,EAChB,IAAY;IAEZ,OAAO,MAAM,gHAAM,CAAC,OAAO,CAAC,UAAU;AACxC;AAKO,SAAS,cAAc,OAA4B,EAAE,YAAoB,KAAK;IACnF,IAAI,CAAC,QAAQ,GAAG,CAAC,UAAU,EAAE;QAC3B,MAAM,IAAI,MAAM;IAClB;IACA,wDAAwD;IACxD,MAAM,SAAiB,QAAQ,GAAG,CAAC,UAAU,IAAc;IAC3D,4EAA4E;IAC5E,OAAO,kJAAG,CAAC,IAAI,CAAC,SAAgB,QAAe;QAAE;IAAU;AAC7D;AAKO,SAAS,qBAAqB,OAA4B;IAC/D,IAAI,CAAC,QAAQ,GAAG,CAAC,kBAAkB,EAAE;QACnC,MAAM,IAAI,MAAM;IAClB;IACA,MAAM,eAAe;QACnB,GAAG,OAAO;QACV,MAAM;IACR;IACA,MAAM,gBAAwB,QAAQ,GAAG,CAAC,kBAAkB,IAAc;IAC1E,OAAO,kJAAG,CAAC,IAAI,CAAC,cAAqB,eAAe;QAAE,WAAW;IAAK;AACxE;AAKO,SAAS,YAAY,KAAa;IACvC,IAAI;QACF,IAAI,CAAC,QAAQ,GAAG,CAAC,UAAU,EAAE;YAC3B,MAAM,IAAI,MAAM;QAClB;QACA,MAAM,UAAU,kJAAG,CAAC,MAAM,CAAC,OAAO,QAAQ,GAAG,CAAC,UAAU;QACxD,IAAI,OAAO,YAAY,UAAU;YAC/B,OAAO;QACT;QACA,OAAO;IACT,EAAE,OAAO,OAAO;QACd,OAAO;IACT;AACF;AAKO,SAAS,mBAAmB,KAAa;IAC9C,IAAI;QACF,IAAI,CAAC,QAAQ,GAAG,CAAC,kBAAkB,EAAE;YACnC,MAAM,IAAI,MAAM;QAClB;QACA,MAAM,UAAU,kJAAG,CAAC,MAAM,CAAC,OAAO,QAAQ,GAAG,CAAC,kBAAkB;QAChE,IAAI,OAAO,YAAY,UAAU;YAC/B,OAAO;QACT;QACA,OAAO;IACT,EAAE,OAAO,OAAO;QACd,OAAO;IACT;AACF;AAKO,SAAS;IACd,OAAO,gHAAM,CAAC,WAAW,CAAC,IAAI,QAAQ,CAAC;AACzC;AAMO,SAAS,qBAAqB,QAAgB;IACnD,MAAM,SAAS,gHAAM,CAAC,WAAW,CAAC,GAAG,QAAQ,CAAC,OAAO,WAAW;IAChE,MAAM,aAAa,SAAS,SAAS,CAAC,GAAG,GAAG,WAAW;IACvD,OAAO,GAAG,aAAa,QAAQ;AACjC;AAOO,eAAe;IACpB,oEAAoE;IACpE,MAAM,SAAS,MAAM,IAAA,0IAAW,EAAC,OAAO;QACtC,0CAA0C;QAC1C,IAAI,UAAU,MAAM,IAAA,uIAAQ,EAC1B,CAAC,8DAA8D,CAAC,EAChE,EAAE;QAGJ,yDAAyD;QACzD,IAAI,CAAC,SAAS;YACZ,UAAU,MAAM,IAAA,uIAAQ,EACtB,CAAC;4CACmC,CAAC,EACrC,EAAE;QAEN,OAAO;YACL,wBAAwB;YACxB,UAAU,MAAM,IAAA,uIAAQ,EACtB,CAAC;mDAC0C,CAAC,EAC5C,EAAE;QAEN;QAEA,OAAO;IACT;IAEA,mCAAmC;IACnC,MAAM,UAAU;IAEhB,uCAAuC;IACvC,MAAM,YAAY,CAAC,MAAM,EAAE,QAAQ,YAAY,EAAE;IACjD,MAAM,eAAe,MAAM,IAAA,uIAAQ,EACjC,CAAC,8CAA8C,CAAC,EAChD;QAAC;KAAU;IAGb,qEAAqE;IACrE,IAAI,cAAc;QAChB,MAAM,eAAe,KAAK,KAAK,CAAC,KAAK,MAAM,KAAK,MAAM,QAAQ,GAAG,QAAQ,CAAC,GAAG;QAC7E,OAAO,CAAC,MAAM,EAAE,QAAQ,YAAY,CAAC,CAAC,EAAE,cAAc;IACxD;IAEA,OAAO;AACT,EAEA,uEAAuE;CACvE,yDAAyD"}},
    {"offset": {"line": 860, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/LENOVO/Desktop/nsc-test/vercel-download/src/lib/neon-serverless.ts"],"sourcesContent":["import { neon } from '@neondatabase/serverless'\r\n\r\n/**\r\n * Neon Serverless Database Connection\r\n * Optimized for Neon's serverless environment\r\n */\r\n\r\nlet sql: ReturnType<typeof neon> | null = null\r\n\r\nexport function getNeonSQL() {\r\n  if (!sql) {\r\n    const databaseUrl = process.env.DATABASE_URL\r\n    if (!databaseUrl) {\r\n      throw new Error('DATABASE_URL is not defined in environment variables')\r\n    }\r\n    \r\n    console.log('üöÄ Initializing Neon Serverless SQL connection')\r\n    sql = neon(databaseUrl)\r\n  }\r\n  return sql\r\n}\r\n\r\n/**\r\n * Execute a query with Neon Serverless Driver\r\n * This bypasses traditional connection pooling issues\r\n * Uses tagged template literals as required by Neon\r\n */\r\nexport async function neonQuery<T = any>(\r\n  query: string, \r\n  params: any[] = []\r\n): Promise<T[]> {\r\n  const sql = getNeonSQL()\r\n  \r\n  try {\r\n    console.log(`üîç Executing Neon query: ${query.substring(0, 100)}...`)\r\n    \r\n    // For Neon serverless, we need to use sql.query() for parameterized queries\r\n    const result = await sql.query(query, params)\r\n    \r\n    const resultArray = Array.isArray(result) ? result : [result]\r\n    console.log(`‚úÖ Neon query completed, returned ${resultArray.length} rows`)\r\n    return resultArray as T[]\r\n    \r\n  } catch (error) {\r\n    console.error('‚ùå Neon query failed:', error.message)\r\n    console.error('Query:', query)\r\n    console.error('Params:', params)\r\n    throw error\r\n  }\r\n}\r\n\r\n/**\r\n * Execute a prepared statement with Neon Serverless Driver\r\n * For queries that need parameter binding\r\n */\r\nexport async function neonQueryPrepared<T = any>(\r\n  queryTemplate: (sql: ReturnType<typeof neon>) => Promise<T[]>\r\n): Promise<T[]> {\r\n  const sql = getNeonSQL()\r\n  \r\n  try {\r\n    console.log(`üîç Executing Neon prepared query...`)\r\n    \r\n    const result = await queryTemplate(sql)\r\n    \r\n    console.log(`‚úÖ Neon prepared query completed, returned ${result.length} rows`)\r\n    return result\r\n    \r\n  } catch (error) {\r\n    console.error('‚ùå Neon prepared query failed:', error.message)\r\n    throw error\r\n  }\r\n}\r\n\r\nexport default {\r\n  getNeonSQL,\r\n  neonQuery,\r\n  neonQueryPrepared\r\n}"],"names":[],"mappings":";;;;;;;;;;AAAA;;AAEA;;;CAGC,GAED,IAAI,MAAsC;AAEnC,SAAS;IACd,IAAI,CAAC,KAAK;QACR,MAAM,cAAc,QAAQ,GAAG,CAAC,YAAY;QAC5C,IAAI,CAAC,aAAa;YAChB,MAAM,IAAI,MAAM;QAClB;QAEA,QAAQ,GAAG,CAAC;QACZ,MAAM,IAAA,gKAAI,EAAC;IACb;IACA,OAAO;AACT;AAOO,eAAe,UACpB,KAAa,EACb,SAAgB,EAAE;IAElB,MAAM,MAAM;IAEZ,IAAI;QACF,QAAQ,GAAG,CAAC,CAAC,yBAAyB,EAAE,MAAM,SAAS,CAAC,GAAG,KAAK,GAAG,CAAC;QAEpE,4EAA4E;QAC5E,MAAM,SAAS,MAAM,IAAI,KAAK,CAAC,OAAO;QAEtC,MAAM,cAAc,MAAM,OAAO,CAAC,UAAU,SAAS;YAAC;SAAO;QAC7D,QAAQ,GAAG,CAAC,CAAC,iCAAiC,EAAE,YAAY,MAAM,CAAC,KAAK,CAAC;QACzE,OAAO;IAET,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,wBAAwB,MAAM,OAAO;QACnD,QAAQ,KAAK,CAAC,UAAU;QACxB,QAAQ,KAAK,CAAC,WAAW;QACzB,MAAM;IACR;AACF;AAMO,eAAe,kBACpB,aAA6D;IAE7D,MAAM,MAAM;IAEZ,IAAI;QACF,QAAQ,GAAG,CAAC,CAAC,mCAAmC,CAAC;QAEjD,MAAM,SAAS,MAAM,cAAc;QAEnC,QAAQ,GAAG,CAAC,CAAC,0CAA0C,EAAE,OAAO,MAAM,CAAC,KAAK,CAAC;QAC7E,OAAO;IAET,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,iCAAiC,MAAM,OAAO;QAC5D,MAAM;IACR;AACF;uCAEe;IACb;IACA;IACA;AACF"}},
    {"offset": {"line": 928, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/LENOVO/Desktop/nsc-test/vercel-download/src/services/sessionManagementService.ts"],"sourcesContent":["import { queryWithTimeout } from '../lib/db-connection';\r\n\r\ninterface SessionData {\r\n  sessionId: string;\r\n  userId: string;\r\n  ipAddress: string;\r\n  userAgent: string;\r\n  isActive: boolean;\r\n  createdAt: Date;\r\n  lastActiveAt: Date;\r\n  expiresAt: Date;\r\n}\r\n\r\ninterface SessionStats {\r\n  activeSessions: number;\r\n  uniqueUsers: number;\r\n  sessionsLast24h: number;\r\n}\r\n\r\nexport class SessionManagementService {\r\n  /**\r\n   * Create a new session for a user\r\n   */\r\n  static async createSession(\r\n    userId: string,\r\n    tokenHash: string,\r\n    refreshTokenHash: string,\r\n    ipAddress: string,\r\n    userAgent: string,\r\n    expiresAt: Date = new Date(Date.now() + 30 * 24 * 60 * 60 * 1000) // 30 days default\r\n  ): Promise<SessionData | null> {\r\n    try {\r\n      const result = await queryWithTimeout(\r\n        `SELECT create_session($1::TEXT, $2::TEXT, $3::TEXT, $4::TEXT, $5::TEXT, $6::TIMESTAMP) as session_id`,\r\n        [userId, tokenHash, refreshTokenHash, ipAddress, userAgent, expiresAt],\r\n        5000\r\n      );\r\n\r\n      if (result.rows && result.rows.length > 0) {\r\n        const sessionId = result.rows[0].session_id;\r\n        \r\n        // Return a basic session object\r\n        return {\r\n          sessionId: sessionId,\r\n          userId: userId,\r\n          ipAddress: ipAddress,\r\n          userAgent: userAgent,\r\n          isActive: true,\r\n          createdAt: new Date(),\r\n          lastActiveAt: new Date(),\r\n          expiresAt: expiresAt\r\n        };\r\n      }\r\n\r\n      return null;\r\n    } catch (error) {\r\n      console.error('Error creating session:', error);\r\n      \r\n      // For now, don't throw an error to allow login to complete\r\n      // This allows the system to work while we debug the session creation\r\n      console.warn('Session creation failed, but allowing login to continue');\r\n      return {\r\n        sessionId: 'fallback-session-' + Date.now(),\r\n        userId: userId,\r\n        ipAddress: ipAddress,\r\n        userAgent: userAgent,\r\n        isActive: true,\r\n        createdAt: new Date(),\r\n        lastActiveAt: new Date(),\r\n        expiresAt: expiresAt\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Validate and update session activity\r\n   */\r\n  static async validateSession(tokenHash: string): Promise<SessionData | null> {\r\n    try {\r\n      const result = await queryWithTimeout(\r\n        `SELECT * FROM validate_session($1::TEXT)`,\r\n        [tokenHash],\r\n        5000\r\n      );\r\n\r\n      if (result.rows && result.rows.length > 0) {\r\n        const session = result.rows[0];\r\n        \r\n        // Return null if session is not valid\r\n        if (!session.isValid) {\r\n          return null;\r\n        }\r\n\r\n        return {\r\n          sessionId: session.sessionId,\r\n          userId: session.userId,\r\n          ipAddress: session.ipAddress,\r\n          userAgent: session.userAgent,\r\n          isActive: session.isValid,\r\n          createdAt: new Date(session.createdAt),\r\n          lastActiveAt: new Date(session.lastUsedAt),\r\n          expiresAt: new Date(session.expiresAt)\r\n        };\r\n      }\r\n\r\n      return null;\r\n    } catch (error) {\r\n      console.error('Error validating session:', error);\r\n      return null; // Fail gracefully for validation\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Revoke a specific session\r\n   */\r\n  static async revokeSession(sessionId: string): Promise<boolean> {\r\n    try {\r\n      const result = await queryWithTimeout(\r\n        `SELECT revoke_session($1) as revoked`,\r\n        [sessionId],\r\n        5000\r\n      );\r\n\r\n      return result.rows?.[0]?.revoked === true;\r\n    } catch (error) {\r\n      console.error('Error revoking session:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Revoke all sessions for a user\r\n   */\r\n  static async revokeAllUserSessions(userId: string): Promise<number> {\r\n    try {\r\n      const result = await queryWithTimeout(\r\n        `SELECT revoke_all_user_sessions($1) as revoked_count`,\r\n        [userId],\r\n        5000\r\n      );\r\n\r\n      return result.rows?.[0]?.revoked_count || 0;\r\n    } catch (error) {\r\n      console.error('Error revoking all user sessions:', error);\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Revoke all other sessions except the current one\r\n   */\r\n  static async revokeOtherSessions(userId: string, currentSessionId: string): Promise<number> {\r\n    try {\r\n      const result = await queryWithTimeout(\r\n        `SELECT revoke_other_sessions($1, $2) as revoked_count`,\r\n        [userId, currentSessionId],\r\n        5000\r\n      );\r\n\r\n      return result.rows?.[0]?.revoked_count || 0;\r\n    } catch (error) {\r\n      console.error('Error revoking other sessions:', error);\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get all active sessions for a user\r\n   */\r\n  static async getUserSessions(userId: string): Promise<SessionData[]> {\r\n    try {\r\n      const result = await queryWithTimeout(\r\n        `SELECT * FROM get_user_sessions($1::TEXT)`,\r\n        [userId],\r\n        5000\r\n      );\r\n\r\n      if (result.rows && result.rows.length > 0) {\r\n        return result.rows.map(session => ({\r\n          sessionId: session.sessionId,\r\n          userId: userId,\r\n          ipAddress: session.ipAddress,\r\n          userAgent: session.userAgent,\r\n          isActive: session.isActive,\r\n          createdAt: new Date(session.createdAt),\r\n          lastActiveAt: new Date(session.lastUsedAt),\r\n          expiresAt: new Date(session.expiresAt)\r\n        }));\r\n      }\r\n\r\n      return [];\r\n    } catch (error) {\r\n      console.error('Error getting user sessions:', error);\r\n      return [];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clean up expired sessions\r\n   */\r\n  static async cleanupExpiredSessions(): Promise<number> {\r\n    try {\r\n      const result = await queryWithTimeout(\r\n        `SELECT cleanup_expired_sessions() as cleaned_count`,\r\n        [],\r\n        10000 // Longer timeout for cleanup operation\r\n      );\r\n\r\n      return result.rows?.[0]?.cleaned_count || 0;\r\n    } catch (error) {\r\n      console.error('Error cleaning up expired sessions:', error);\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get session statistics\r\n   */\r\n  static async getSessionStats(): Promise<SessionStats> {\r\n    try {\r\n      const result = await queryWithTimeout(\r\n        `SELECT * FROM get_session_stats()`,\r\n        [],\r\n        5000\r\n      );\r\n\r\n      if (result.rows && result.rows.length > 0) {\r\n        const stats = result.rows[0];\r\n        return {\r\n          activeSessions: stats.active_sessions || 0,\r\n          uniqueUsers: stats.unique_users || 0,\r\n          sessionsLast24h: stats.sessions_last_24h || 0\r\n        };\r\n      }\r\n\r\n      return {\r\n        activeSessions: 0,\r\n        uniqueUsers: 0,\r\n        sessionsLast24h: 0\r\n      };\r\n    } catch (error) {\r\n      console.error('Error getting session stats:', error);\r\n      return {\r\n        activeSessions: 0,\r\n        uniqueUsers: 0,\r\n        sessionsLast24h: 0\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Generate a secure session ID\r\n   */\r\n  static generateSessionId(): string {\r\n    const crypto = require('crypto');\r\n    return crypto.randomBytes(32).toString('hex');\r\n  }\r\n\r\n  /**\r\n   * Extract session ID from JWT token or cookie\r\n   */\r\n  static extractSessionId(token?: string): string | null {\r\n    if (!token) return null;\r\n\r\n    try {\r\n      // If it's a JWT token, decode to get session ID\r\n      const jwt = require('jsonwebtoken');\r\n      const decoded = jwt.decode(token) as any;\r\n      return decoded?.sessionId || null;\r\n    } catch (error) {\r\n      // If not JWT, treat as direct session ID\r\n      return token;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Middleware helper to validate session in requests\r\n   */\r\n  static async validateRequestSession(\r\n    authHeader?: string,\r\n    sessionCookie?: string\r\n  ): Promise<{ isValid: boolean; session?: SessionData; userId?: string }> {\r\n    try {\r\n      // Try to extract session ID from Authorization header or cookie\r\n      let sessionId: string | null = null;\r\n\r\n      if (authHeader?.startsWith('Bearer ')) {\r\n        sessionId = this.extractSessionId(authHeader.substring(7));\r\n      } else if (sessionCookie) {\r\n        sessionId = this.extractSessionId(sessionCookie);\r\n      }\r\n\r\n      if (!sessionId) {\r\n        return { isValid: false };\r\n      }\r\n\r\n      const session = await this.validateSession(sessionId);\r\n      \r\n      if (!session) {\r\n        return { isValid: false };\r\n      }\r\n\r\n      return {\r\n        isValid: true,\r\n        session,\r\n        userId: session.userId\r\n      };\r\n    } catch (error) {\r\n      console.error('Error validating request session:', error);\r\n      return { isValid: false };\r\n    }\r\n  }\r\n}\r\n\r\nexport default SessionManagementService;"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1183, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/LENOVO/Desktop/nsc-test/vercel-download/src/middleware/auth.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server'\nimport { verifyToken } from '@/utils/server-helpers'\nimport { neonQuery } from '@/lib/neon-serverless'\nimport { queryOne } from '@/lib/db'\nimport { AuthUser, JwtPayload } from '@/types/api'\nimport SessionManagementService from '@/services/sessionManagementService'\nimport { createHash } from 'crypto'\n\nexport interface AuthRequest extends NextRequest {\n  user?: AuthUser\n}\n\n/**\n * Authenticate JWT token middleware with session validation\n */\nexport async function authenticateToken(\n  request: NextRequest,\n  options: { validateSession?: boolean } = {}\n): Promise<{ user: AuthUser } | NextResponse> {\n  // Try to get token from cookies first (browser requests)\n  const tokenCookie = request.cookies.get('token')?.value\n  \n  // If not in cookies, try authorization header (API requests)\n  const authHeader = request.headers.get('authorization')\n  const headerToken = authHeader?.split(' ')[1]\n  \n  const token = tokenCookie || headerToken\n  \n  if (!token) {\n    return NextResponse.json(\n      { error: 'Access token required' },\n      { status: 401 }\n    )\n  }\n  \n  try {\n    const decoded = verifyToken(token)\n    if (!decoded || !decoded.userId || !decoded.email) {\n      return NextResponse.json(\n        { error: 'Invalid token payload' },\n        { status: 403 }\n      )\n    }\n\n    // Validate session if requested (for critical operations)\n    if (options.validateSession) {\n      const tokenHash = createHash('sha256').update(token).digest('hex')\n      const session = await SessionManagementService.validateSession(tokenHash)\n      \n      if (!session || !session.isActive) {\n        return NextResponse.json(\n          { error: 'Session expired or revoked' },\n          { status: 401 }\n        )\n      }\n\n      // Verify user is still active in database\n      const user = await queryOne(\n        `SELECT id, email, \"isActive\" FROM \"User\" WHERE id = $1`,\n        [decoded.userId]\n      )\n\n      if (!user || !user.isActive) {\n        return NextResponse.json(\n          { error: 'User account is inactive' },\n          { status: 403 }\n        )\n      }\n    }\n    \n    const user: AuthUser = {\n      userId: decoded.userId,\n      email: decoded.email,\n      isAdmin: decoded.isAdmin || false\n    }\n    \n    return { user }\n  } catch (error) {\n    return NextResponse.json(\n      { error: 'Invalid or expired token' },\n      { status: 403 }\n    )\n  }\n}\n\n/**\n * Require admin role middleware\n */\nexport function requireAdmin(user: AuthUser): { isAdmin: boolean } | NextResponse {\n  if (!user || !user.isAdmin) {\n    return NextResponse.json(\n      { error: 'Admin access required' },\n      { status: 403 }\n    )\n  }\n  \n  return { isAdmin: true }\n}\n\n/**\n * Require bot activation middleware\n */\nexport async function requireBotActivation(userId: string, botType: string): Promise<NextResponse | null> {\n  try {\n    // Use Neon Serverless query to check for active bot activation\n    const query = `\n      SELECT * FROM \"BotActivation\"\n      WHERE \"userId\" = $1 AND \"botType\" = $2\n      AND \"status\" = 'ACTIVE' AND \"isExpired\" = false\n      LIMIT 1\n    `;\n\n    const result = await neonQuery(query, [userId, botType]);\n    const botActivation = Array.isArray(result) && result.length > 0 ? result[0] : null;\n\n    if (!botActivation) {\n      return NextResponse.json(\n        { error: 'Bot activation required for this action' },\n        { status: 403 }\n      );\n    }\n\n    return null;\n  } catch (error) {\n    console.error('Error checking bot activation:', error);\n    return NextResponse.json(\n      { error: 'Error checking bot activation' },\n      { status: 500 }\n    );\n  }\n}\n\n/**\n * Verify authentication from token in cookies or headers\n * Returns user ID if authenticated\n */\nexport async function verifyAuth(request: NextRequest): Promise<{ success: boolean; userId?: string }> {\n  // Try to get token from cookies first\n  const tokenCookie = request.cookies.get('token')?.value\n  \n  // If not in cookies, try authorization header\n  const authHeader = request.headers.get('authorization')\n  const headerToken = authHeader?.split(' ')[1]\n  \n  const token = tokenCookie || headerToken\n  \n  if (!token) {\n    return { success: false }\n  }\n  \n  try {\n    const decoded = verifyToken(token)\n    if (!decoded || !decoded.userId) {\n      return { success: false }\n    }\n    \n    return { success: true, userId: decoded.userId }\n  } catch (error) {\n    return { success: false }\n  }\n}\n"],"names":[],"mappings":";;;;;;;;;;AAAA;AACA;AACA;AACA;AAEA;AACA;;;;;;;;;;;;;AASO,eAAe,kBACpB,OAAoB,EACpB,UAAyC,CAAC,CAAC;IAE3C,yDAAyD;IACzD,MAAM,cAAc,QAAQ,OAAO,CAAC,GAAG,CAAC,UAAU;IAElD,6DAA6D;IAC7D,MAAM,aAAa,QAAQ,OAAO,CAAC,GAAG,CAAC;IACvC,MAAM,cAAc,YAAY,MAAM,IAAI,CAAC,EAAE;IAE7C,MAAM,QAAQ,eAAe;IAE7B,IAAI,CAAC,OAAO;QACV,OAAO,gJAAY,CAAC,IAAI,CACtB;YAAE,OAAO;QAAwB,GACjC;YAAE,QAAQ;QAAI;IAElB;IAEA,IAAI;QACF,MAAM,UAAU,IAAA,2IAAW,EAAC;QAC5B,IAAI,CAAC,WAAW,CAAC,QAAQ,MAAM,IAAI,CAAC,QAAQ,KAAK,EAAE;YACjD,OAAO,gJAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAAwB,GACjC;gBAAE,QAAQ;YAAI;QAElB;QAEA,0DAA0D;QAC1D,IAAI,QAAQ,eAAe,EAAE;YAC3B,MAAM,YAAY,IAAA,mHAAU,EAAC,UAAU,MAAM,CAAC,OAAO,MAAM,CAAC;YAC5D,MAAM,UAAU,MAAM,iJAAwB,CAAC,eAAe,CAAC;YAE/D,IAAI,CAAC,WAAW,CAAC,QAAQ,QAAQ,EAAE;gBACjC,OAAO,gJAAY,CAAC,IAAI,CACtB;oBAAE,OAAO;gBAA6B,GACtC;oBAAE,QAAQ;gBAAI;YAElB;YAEA,0CAA0C;YAC1C,MAAM,OAAO,MAAM,IAAA,uIAAQ,EACzB,CAAC,sDAAsD,CAAC,EACxD;gBAAC,QAAQ,MAAM;aAAC;YAGlB,IAAI,CAAC,QAAQ,CAAC,KAAK,QAAQ,EAAE;gBAC3B,OAAO,gJAAY,CAAC,IAAI,CACtB;oBAAE,OAAO;gBAA2B,GACpC;oBAAE,QAAQ;gBAAI;YAElB;QACF;QAEA,MAAM,OAAiB;YACrB,QAAQ,QAAQ,MAAM;YACtB,OAAO,QAAQ,KAAK;YACpB,SAAS,QAAQ,OAAO,IAAI;QAC9B;QAEA,OAAO;YAAE;QAAK;IAChB,EAAE,OAAO,OAAO;QACd,OAAO,gJAAY,CAAC,IAAI,CACtB;YAAE,OAAO;QAA2B,GACpC;YAAE,QAAQ;QAAI;IAElB;AACF;AAKO,SAAS,aAAa,IAAc;IACzC,IAAI,CAAC,QAAQ,CAAC,KAAK,OAAO,EAAE;QAC1B,OAAO,gJAAY,CAAC,IAAI,CACtB;YAAE,OAAO;QAAwB,GACjC;YAAE,QAAQ;QAAI;IAElB;IAEA,OAAO;QAAE,SAAS;IAAK;AACzB;AAKO,eAAe,qBAAqB,MAAc,EAAE,OAAe;IACxE,IAAI;QACF,+DAA+D;QAC/D,MAAM,QAAQ,CAAC;;;;;IAKf,CAAC;QAED,MAAM,SAAS,MAAM,IAAA,wIAAS,EAAC,OAAO;YAAC;YAAQ;SAAQ;QACvD,MAAM,gBAAgB,MAAM,OAAO,CAAC,WAAW,OAAO,MAAM,GAAG,IAAI,MAAM,CAAC,EAAE,GAAG;QAE/E,IAAI,CAAC,eAAe;YAClB,OAAO,gJAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAA0C,GACnD;gBAAE,QAAQ;YAAI;QAElB;QAEA,OAAO;IACT,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,kCAAkC;QAChD,OAAO,gJAAY,CAAC,IAAI,CACtB;YAAE,OAAO;QAAgC,GACzC;YAAE,QAAQ;QAAI;IAElB;AACF;AAMO,eAAe,WAAW,OAAoB;IACnD,sCAAsC;IACtC,MAAM,cAAc,QAAQ,OAAO,CAAC,GAAG,CAAC,UAAU;IAElD,8CAA8C;IAC9C,MAAM,aAAa,QAAQ,OAAO,CAAC,GAAG,CAAC;IACvC,MAAM,cAAc,YAAY,MAAM,IAAI,CAAC,EAAE;IAE7C,MAAM,QAAQ,eAAe;IAE7B,IAAI,CAAC,OAAO;QACV,OAAO;YAAE,SAAS;QAAM;IAC1B;IAEA,IAAI;QACF,MAAM,UAAU,IAAA,2IAAW,EAAC;QAC5B,IAAI,CAAC,WAAW,CAAC,QAAQ,MAAM,EAAE;YAC/B,OAAO;gBAAE,SAAS;YAAM;QAC1B;QAEA,OAAO;YAAE,SAAS;YAAM,QAAQ,QAAQ,MAAM;QAAC;IACjD,EAAE,OAAO,OAAO;QACd,OAAO;YAAE,SAAS;QAAM;IAC1B;AACF"}},
    {"offset": {"line": 1350, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/LENOVO/Desktop/nsc-test/vercel-download/src/lib/query-validator.ts"],"sourcesContent":["/**\r\n * SQL Query Field Whitelisting\r\n * Prevents SQL injection by validating field names against allowed lists\r\n */\r\n\r\n// Allowed fields for user queries\r\nexport const ALLOWED_USER_FIELDS = [\r\n  'id',\r\n  'email',\r\n  'username',\r\n  'firstName',\r\n  'lastName',\r\n  'createdAt',\r\n  'updatedAt',\r\n  'status',\r\n  'role',\r\n  'emailVerified',\r\n  'lastLoginAt',\r\n] as const\r\n\r\n// Allowed fields for payment queries\r\nexport const ALLOWED_PAYMENT_FIELDS = [\r\n  'id',\r\n  'userId',\r\n  'amount',\r\n  'network',\r\n  'status',\r\n  'txHash',\r\n  'fromAddress',\r\n  'toAddress',\r\n  'createdAt',\r\n  'updatedAt',\r\n  'confirmedAt',\r\n] as const\r\n\r\n// Allowed fields for package queries\r\nexport const ALLOWED_PACKAGE_FIELDS = [\r\n  'id',\r\n  'userId',\r\n  'packageId',\r\n  'amount',\r\n  'status',\r\n  'roiPercentage',\r\n  'duration',\r\n  'startDate',\r\n  'endDate',\r\n  'createdAt',\r\n  'updatedAt',\r\n] as const\r\n\r\n// Allowed fields for referral queries\r\nexport const ALLOWED_REFERRAL_FIELDS = [\r\n  'id',\r\n  'referrerId',\r\n  'referredUserId',\r\n  'level',\r\n  'commission',\r\n  'status',\r\n  'createdAt',\r\n  'updatedAt',\r\n] as const\r\n\r\n// Allowed sort orders\r\nexport const ALLOWED_SORT_ORDERS = ['asc', 'desc'] as const\r\n\r\ntype AllowedField = \r\n  | typeof ALLOWED_USER_FIELDS[number]\r\n  | typeof ALLOWED_PAYMENT_FIELDS[number]\r\n  | typeof ALLOWED_PACKAGE_FIELDS[number]\r\n  | typeof ALLOWED_REFERRAL_FIELDS[number]\r\n\r\n/**\r\n * Validate field name against whitelist\r\n */\r\nexport function isValidField(field: string, whitelist: readonly string[]): boolean {\r\n  return whitelist.includes(field)\r\n}\r\n\r\n/**\r\n * Validate sort order\r\n */\r\nexport function isValidSortOrder(order: string): order is 'asc' | 'desc' {\r\n  return ALLOWED_SORT_ORDERS.includes(order as any)\r\n}\r\n/**\r\n * Sanitize and validate orderBy parameter for SQL queries\r\n */\r\nexport function validateOrderBy(\r\n  orderBy: unknown,\r\n  whitelist: readonly string[]\r\n): Record<string, 'asc' | 'desc'> | null {\r\n  if (!orderBy || typeof orderBy !== 'object') {\r\n    return null\r\n  }\r\n\r\n  const entries = Object.entries(orderBy)\r\n  if (entries.length === 0) {\r\n    return null\r\n  }\r\n\r\n  const [field, order] = entries[0]\r\n  \r\n  if (!isValidField(field, whitelist)) {\r\n    throw new Error(`Invalid field name: ${field}`)\r\n  }\r\n\r\n  if (!isValidSortOrder(order as string)) {\r\n    throw new Error(`Invalid sort order: ${order}`)\r\n  }\r\n\r\n  return { [field]: order }\r\n}\r\n\r\n/**\r\n * Validate select fields for SQL queries\r\n */\r\nexport function validateSelect(\r\n  select: unknown,\r\n  whitelist: readonly string[]\r\n): Record<string, boolean> | null {\r\n  if (!select || typeof select !== 'object') {\r\n    return null\r\n  }\r\n\r\n  const validated: Record<string, boolean> = {}\r\n  \r\n  for (const [field, value] of Object.entries(select)) {\r\n    if (!isValidField(field, whitelist)) {\r\n      throw new Error(`Invalid select field: ${field}`)\r\n    }\r\n    \r\n    if (typeof value !== 'boolean') {\r\n      throw new Error(`Select value must be boolean for field: ${field}`)\r\n    }\r\n    \r\n    validated[field] = value\r\n  }\r\n\r\n  return Object.keys(validated).length > 0 ? validated : null\r\n}\r\n\r\n/**\r\n * Validate where clause field names\r\n */\r\nexport function validateWhereFields(\r\n  where: unknown,\r\n  whitelist: readonly string[]\r\n): void {\r\n  if (!where || typeof where !== 'object') {\r\n    return\r\n  }\r\n\r\n  for (const field of Object.keys(where)) {\r\n    // Skip SQL operators (AND, OR, NOT)\r\n    if (['AND', 'OR', 'NOT'].includes(field)) {\r\n      const operatorValue = (where as any)[field]\r\n      if (Array.isArray(operatorValue)) {\r\n        operatorValue.forEach(clause => validateWhereFields(clause, whitelist))\r\n      } else {\r\n        validateWhereFields(operatorValue, whitelist)\r\n      }\r\n      continue\r\n    }\r\n\r\n    if (!isValidField(field, whitelist)) {\r\n      throw new Error(`Invalid where field: ${field}`)\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Sanitize pagination parameters\r\n */\r\nexport function validatePagination(params: {\r\n  skip?: unknown\r\n  take?: unknown\r\n}): { skip?: number; take?: number } {\r\n  const result: { skip?: number; take?: number } = {}\r\n\r\n  if (params.skip !== undefined) {\r\n    const skip = Number(params.skip)\r\n    if (!Number.isInteger(skip) || skip < 0) {\r\n      throw new Error('Invalid skip parameter')\r\n    }\r\n    result.skip = skip\r\n  }\r\n\r\n  if (params.take !== undefined) {\r\n    const take = Number(params.take)\r\n    if (!Number.isInteger(take) || take < 1 || take > 100) {\r\n      throw new Error('Invalid take parameter (must be 1-100)')\r\n    }\r\n    result.take = take\r\n  }\r\n\r\n  return result\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1518, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/LENOVO/Desktop/nsc-test/vercel-download/src/lib/validation-schemas.ts"],"sourcesContent":["import { z } from 'zod'\r\n\r\n/**\r\n * User Profile Validation Schemas\r\n */\r\nexport const updateProfileSchema = z.object({\r\n  fullName: z.string()\r\n    .min(2, 'Full name must be at least 2 characters')\r\n    .max(100, 'Full name must be less than 100 characters')\r\n    .regex(/^[a-zA-Z\\s'-]+$/, 'Full name can only contain letters, spaces, hyphens, and apostrophes')\r\n    .optional()\r\n    .or(z.literal('')),\r\n  phone: z.string()\r\n    .regex(/^\\+?[1-9]\\d{1,14}$/, 'Invalid phone number format. Use international format like +1234567890')\r\n    .optional()\r\n    .or(z.literal('')),\r\n  bep20Address: z.string()\r\n    .regex(/^0x[a-fA-F0-9]{40}$/, 'Invalid BEP20 address format. Must start with 0x followed by 40 hex characters')\r\n    .optional()\r\n    .nullable()\r\n    .or(z.literal('')),\r\n  trc20Address: z.string()\r\n    .regex(/^T[A-Za-z1-9]{33}$/, 'Invalid TRC20 address format. Must start with T followed by 33 characters')\r\n    .optional()\r\n    .nullable()\r\n    .or(z.literal('')),\r\n})\r\n\r\n/**\r\n * Package Creation Validation Schema\r\n */\r\nexport const createPackageSchema = z.object({\r\n  amount: z.number()\r\n    .positive('Amount must be positive')\r\n    .refine(\r\n      (val) => [500, 1000, 3000, 5000, 10000, 25000, 50000].includes(val),\r\n      'Invalid package amount. Valid amounts: 500, 1000, 3000, 5000, 10000, 25000, 50000'\r\n    ),\r\n  network: z.enum(['BEP20', 'TRC20'], {\r\n    errorMap: () => ({ message: 'Network must be either BEP20 or TRC20' }),\r\n  }),\r\n})\r\n\r\n/**\r\n * Bot Activation Validation Schema\r\n */\r\nexport const activateBotSchema = z.object({\r\n  botType: z.enum(['NEO', 'NEURAL', 'ORACLE'], {\r\n    errorMap: () => ({ message: 'Bot type must be NEO, NEURAL, or ORACLE' }),\r\n  }),\r\n  network: z.enum(['BEP20', 'TRC20'], {\r\n    errorMap: () => ({ message: 'Network must be either BEP20 or TRC20' }),\r\n  }),\r\n})\r\n\r\n/**\r\n * Payment Request Validation Schema\r\n */\r\nexport const createPaymentRequestSchema = z.object({\r\n  purpose: z.enum(['PACKAGE_PURCHASE', 'BOT_ACTIVATION', 'MANUAL_DEPOSIT'], {\r\n    errorMap: () => ({ message: 'Invalid payment purpose' }),\r\n  }),\r\n  amount: z.number()\r\n    .positive('Amount must be positive')\r\n    .max(1000000, 'Amount exceeds maximum limit'),\r\n  network: z.enum(['BEP20', 'TRC20'], {\r\n    errorMap: () => ({ message: 'Network must be either BEP20 or TRC20' }),\r\n  }),\r\n  metadata: z.record(z.any()).optional(),\r\n})\r\n\r\n/**\r\n * Withdrawal Validation Schema\r\n */\r\nexport const createWithdrawalSchema = z.object({\r\n  amount: z.number()\r\n    .positive('Amount must be positive')\r\n    .min(10, 'Minimum withdrawal amount is 10 USDT')\r\n    .max(100000, 'Maximum withdrawal amount is 100,000 USDT'),\r\n  network: z.enum(['BEP20', 'TRC20'], {\r\n    errorMap: () => ({ message: 'Network must be either BEP20 or TRC20' }),\r\n  }),\r\n  address: z.string()\r\n    .min(10, 'Wallet address is required')\r\n    .refine(\r\n      (val) => {\r\n        // Validate BEP20 or TRC20 address format\r\n        return /^0x[a-fA-F0-9]{40}$/.test(val) || /^T[A-Za-z1-9]{33}$/.test(val)\r\n      },\r\n      'Invalid wallet address format'\r\n    ),\r\n})\r\n\r\n/**\r\n * Admin Operations Validation Schemas\r\n */\r\nexport const adminApprovePackageSchema = z.object({\r\n  packageId: z.string().uuid('Invalid package ID'),\r\n  status: z.enum(['ACTIVE', 'REJECTED'], {\r\n    errorMap: () => ({ message: 'Status must be ACTIVE or REJECTED' }),\r\n  }),\r\n  note: z.string().max(500, 'Note must be less than 500 characters').optional(),\r\n})\r\n\r\nexport const adminApproveWithdrawalSchema = z.object({\r\n  withdrawalId: z.string().uuid('Invalid withdrawal ID'),\r\n  status: z.enum(['COMPLETED', 'REJECTED'], {\r\n    errorMap: () => ({ message: 'Status must be COMPLETED or REJECTED' }),\r\n  }),\r\n  txHash: z.string()\r\n    .regex(/^(0x)?[a-fA-F0-9]{64}$/, 'Invalid transaction hash format')\r\n    .optional(),\r\n  note: z.string().max(500, 'Note must be less than 500 characters').optional(),\r\n})\r\n\r\nexport const adminUpdateUserSchema = z.object({\r\n  userId: z.string().uuid('Invalid user ID'),\r\n  isActive: z.boolean().optional(),\r\n  kycStatus: z.enum(['PENDING', 'APPROVED', 'REJECTED']).optional(),\r\n  twoFactorEnabled: z.boolean().optional(),\r\n})\r\n\r\n/**\r\n * Auth Validation Schemas\r\n */\r\nexport const loginSchema = z.object({\r\n  email: z.string()\r\n    .email('Invalid email format')\r\n    .toLowerCase(),\r\n  password: z.string()\r\n    .min(8, 'Password must be at least 8 characters')\r\n    .max(128, 'Password must be less than 128 characters'),\r\n  twoFactorCode: z.string()\r\n    .regex(/^\\d{6}$/, 'Two-factor code must be 6 digits')\r\n    .optional(),\r\n})\r\n\r\nexport const registerSchema = z.object({\r\n  email: z.string()\r\n    .email('Invalid email format')\r\n    .toLowerCase(),\r\n  username: z.string()\r\n    .min(3, 'Username must be at least 3 characters')\r\n    .max(30, 'Username must be less than 30 characters')\r\n    .regex(/^[a-zA-Z0-9_-]+$/, 'Username can only contain letters, numbers, underscores, and hyphens'),\r\n  password: z.string()\r\n    .min(8, 'Password must be at least 8 characters')\r\n    .max(128, 'Password must be less than 128 characters')\r\n    .regex(/[A-Z]/, 'Password must contain at least one uppercase letter')\r\n    .regex(/[a-z]/, 'Password must contain at least one lowercase letter')\r\n    .regex(/[0-9]/, 'Password must contain at least one number')\r\n    .regex(/[^A-Za-z0-9]/, 'Password must contain at least one special character'),\r\n  confirmPassword: z.string(),\r\n  referralCode: z.string()\r\n    .length(8, 'Referral code must be exactly 8 characters')\r\n    .optional(),\r\n}).refine((data) => data.password === data.confirmPassword, {\r\n  message: \"Passwords don't match\",\r\n  path: [\"confirmPassword\"],\r\n})\r\n\r\nexport const changePasswordSchema = z.object({\r\n  currentPassword: z.string().min(1, 'Current password is required'),\r\n  newPassword: z.string()\r\n    .min(8, 'Password must be at least 8 characters')\r\n    .max(128, 'Password must be less than 128 characters')\r\n    .regex(/[A-Z]/, 'Password must contain at least one uppercase letter')\r\n    .regex(/[a-z]/, 'Password must contain at least one lowercase letter')\r\n    .regex(/[0-9]/, 'Password must contain at least one number')\r\n    .regex(/[^A-Za-z0-9]/, 'Password must contain at least one special character'),\r\n  confirmPassword: z.string(),\r\n}).refine((data) => data.newPassword === data.confirmPassword, {\r\n  message: \"Passwords don't match\",\r\n  path: [\"confirmPassword\"],\r\n})\r\n\r\n/**\r\n * Helper function to validate and parse request body\r\n */\r\nexport async function validateRequest<T>(\r\n  request: Request,\r\n  schema: z.ZodSchema<T>\r\n): Promise<{ success: true; data: T } | { success: false; error: string }> {\r\n  try {\r\n    const body = await request.json()\r\n    const result = schema.safeParse(body)\r\n    \r\n    if (!result.success) {\r\n      const errors = result.error.errors.map(err => `${err.path.join('.')}: ${err.message}`).join('; ')\r\n      return { success: false, error: errors }\r\n    }\r\n    \r\n    return { success: true, data: result.data }\r\n  } catch (error) {\r\n    return { success: false, error: 'Invalid JSON in request body' }\r\n  }\r\n}\r\n\r\n/**\r\n * Helper function to validate query parameters\r\n */\r\nexport function validateQueryParams<T>(\r\n  searchParams: URLSearchParams,\r\n  schema: z.ZodSchema<T>\r\n): { success: true; data: T } | { success: false; error: string } {\r\n  try {\r\n    const params = Object.fromEntries(searchParams.entries())\r\n    const result = schema.safeParse(params)\r\n    \r\n    if (!result.success) {\r\n      const errors = result.error.errors.map(err => `${err.path.join('.')}: ${err.message}`).join('; ')\r\n      return { success: false, error: errors }\r\n    }\r\n    \r\n    return { success: true, data: result.data }\r\n  } catch (error) {\r\n    return { success: false, error: 'Invalid query parameters' }\r\n  }\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1740, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/LENOVO/Desktop/nsc-test/vercel-download/src/app/api/user/profile/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server'\nimport { query, queryOne, queryScalar, execute, transaction } from \"@/lib/db\"\nimport { authenticateToken } from '@/middleware/auth'\nimport { ALLOWED_USER_FIELDS, validateSelect } from '@/lib/query-validator'\nimport { updateProfileSchema, validateRequest } from '@/lib/validation-schemas'\n\n\nexport async function GET(request: NextRequest) {\n  // Authenticate user\n  const authResult = await authenticateToken(request)\n  if (authResult instanceof NextResponse) return authResult\n  \n  const { user } = authResult\n\n  try {\n    // Validate select fields (if provided in query params)\n    const { searchParams } = new URL(request.url)\n    const selectParam = searchParams.get('select')\n    let selectFields: any = undefined\n    \n    if (selectParam) {\n      try {\n        const parsedSelect = JSON.parse(selectParam)\n        selectFields = validateSelect(parsedSelect, ALLOWED_USER_FIELDS)\n      } catch (error) {\n        return NextResponse.json(\n          { error: 'Invalid select parameter' },\n          { status: 400 }\n        )\n      }\n    }\n\n    // Get user profile with stats\n    const profile = await queryOne(\n      `SELECT id, email, username, \"fullName\", phone, \"referralCode\", \"referredBy\",\n              \"bep20Address\", \"trc20Address\", \"isEmailVerified\", \"twoFactorEnabled\",\n              \"kycStatus\", \"isActive\", \"createdAt\", \"lastLogin\"\n       FROM \"User\" WHERE id = $1`,\n      [user.userId]\n    )\n\n    if (!profile) {\n      return NextResponse.json(\n        { error: 'User not found' },\n        { status: 404 }\n      )\n    }\n\n    // Get user stats\n    const [totalInvestedResult, totalEarningsResult, activePackagesResult, totalReferralsResult] = await Promise.all([\n      // Total invested (only count ACTIVE packages with confirmed payments)\n      queryOne(\n        `SELECT COALESCE(SUM(amount), 0) as total FROM \"Package\" WHERE \"userId\" = $1 AND status = $2`,\n        [user.userId, 'ACTIVE']\n      ),\n      // Total earnings\n      queryOne(\n        `SELECT COALESCE(SUM(amount), 0) as total FROM \"Earning\" WHERE \"userId\" = $1`,\n        [user.userId]\n      ),\n      // Active packages count\n      queryOne(\n        `SELECT COUNT(*)::int as count FROM \"Package\" WHERE \"userId\" = $1 AND status = $2`,\n        [user.userId, 'ACTIVE']\n      ),\n      // Total referrals\n      queryOne(\n        `SELECT COUNT(*)::int as count FROM \"User\" WHERE \"referredBy\" = $1`,\n        [profile.referralCode]\n      )\n    ])\n\n    const stats = {\n      totalInvested: Number(totalInvestedResult.total || 0),\n      totalEarnings: Number(totalEarningsResult.total || 0),\n      activePackages: activePackagesResult.count || 0,\n      totalReferrals: totalReferralsResult.count || 0\n    }\n\n    // Serialize dates properly - handle both Date objects and strings\n    const toISOString = (date: any) => {\n      if (!date) return null\n      if (date instanceof Date) {\n        return isNaN(date.getTime()) ? null : date.toISOString()\n      }\n      if (typeof date === 'string') {\n        const parsed = new Date(date)\n        return isNaN(parsed.getTime()) ? null : parsed.toISOString()\n      }\n      return null\n    }\n\n    const serializedProfile = {\n      ...profile,\n      createdAt: toISOString(profile.createdAt),\n      lastLogin: toISOString(profile.lastLogin)\n    }\n\n    return NextResponse.json({\n      success: true,\n      user: serializedProfile,\n      stats\n    })\n\n  } catch (error) {\n    console.error('Get profile error:', error)\n    return NextResponse.json(\n      { error: 'Failed to fetch profile' },\n      { status: 500 }\n    )\n  }\n}\n\nexport async function PUT(request: NextRequest) {\n  // Authenticate user\n  const authResult = await authenticateToken(request)\n  if (authResult instanceof NextResponse) return authResult\n\n  const { user } = authResult\n\n  try {\n    // Validate request body\n    const validation = await validateRequest(request, updateProfileSchema)\n\n    if (!validation.success) {\n      console.log('Validation error:', validation.error)\n      return NextResponse.json(\n        {\n          error: 'Validation failed',\n          message: validation.error,\n          details: validation.error\n        },\n        { status: 400 }\n      )\n    }\n\n    const { fullName, phone, bep20Address, trc20Address } = validation.data\n\n    // Build dynamic UPDATE query\n    const updates: string[] = []\n    const values: any[] = []\n    let paramIndex = 1\n\n    if (fullName && fullName.trim() !== '') {\n      updates.push(`\"fullName\" = $${paramIndex++}`)\n      values.push(fullName.trim())\n    }\n    if (phone && phone.trim() !== '') {\n      updates.push(`phone = $${paramIndex++}`)\n      values.push(phone.trim())\n    }\n    if (bep20Address !== undefined) {\n      const cleanAddress = bep20Address === '' ? null : bep20Address\n      updates.push(`\"bep20Address\" = $${paramIndex++}`)\n      values.push(cleanAddress)\n    }\n    if (trc20Address !== undefined) {\n      const cleanAddress = trc20Address === '' ? null : trc20Address\n      updates.push(`\"trc20Address\" = $${paramIndex++}`)\n      values.push(cleanAddress)\n    }\n\n    if (updates.length === 0) {\n      return NextResponse.json(\n        {\n          error: 'No valid fields to update',\n          message: 'Please provide at least one field to update'\n        },\n        { status: 400 }\n      )\n    }\n\n    updates.push(`\"updatedAt\" = $${paramIndex++}`)\n    values.push(new Date())\n\n    values.push(user.userId)\n\n    // Update user profile\n    const updatedUser = await queryOne(\n      `UPDATE \"User\"\n       SET ${updates.join(', ')}\n       WHERE id = $${paramIndex}\n       RETURNING id, email, username, \"fullName\", phone, \"bep20Address\", \"trc20Address\"`,\n      values\n    )\n\n    if (!updatedUser) {\n      return NextResponse.json(\n        { error: 'User not found' },\n        { status: 404 }\n      )\n    }\n\n    return NextResponse.json({\n      success: true,\n      message: 'Profile updated successfully',\n      user: updatedUser\n    })\n\n  } catch (error: any) {\n    console.error('Update profile error:', error)\n\n    // Provide more specific error messages\n    let errorMessage = 'Failed to update profile'\n    if (error.message) {\n      if (error.message.includes('violates')) {\n        errorMessage = 'Invalid data format. Please check your input.'\n      } else if (error.message.includes('duplicate')) {\n        errorMessage = 'This information is already in use.'\n      } else if (error.message.includes('timeout')) {\n        errorMessage = 'Request timed out. Please try again.'\n      }\n    }\n\n    return NextResponse.json(\n      {\n        error: errorMessage,\n        message: errorMessage,\n        details: error.message\n      },\n      { status: 500 }\n    )\n  }\n}\n\n"],"names":[],"mappings":"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"}}]
}