(globalThis.TURBOPACK || (globalThis.TURBOPACK = [])).push([typeof document === "object" ? document.currentScript : undefined,
"[project]/node_modules/@tanstack/query-sync-storage-persister/build/lib/index.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "createSyncStoragePersister",
    ()=>createSyncStoragePersister
]);
function createSyncStoragePersister({ storage, key = "REACT_QUERY_OFFLINE_CACHE", throttleTime = 1000, serialize = JSON.stringify, deserialize = JSON.parse, retry }) {
    if (storage) {
        const trySave = (persistedClient)=>{
            try {
                storage.setItem(key, serialize(persistedClient));
                return;
            } catch (error) {
                return error;
            }
        };
        return {
            persistClient: throttle((persistedClient)=>{
                let client = persistedClient;
                let error = trySave(client);
                let errorCount = 0;
                while(error && client){
                    errorCount++;
                    client = retry == null ? void 0 : retry({
                        persistedClient: client,
                        error,
                        errorCount
                    });
                    if (client) {
                        error = trySave(client);
                    }
                }
            }, throttleTime),
            restoreClient: ()=>{
                const cacheString = storage.getItem(key);
                if (!cacheString) {
                    return;
                }
                return deserialize(cacheString);
            },
            removeClient: ()=>{
                storage.removeItem(key);
            }
        };
    }
    return {
        persistClient: noop,
        restoreClient: ()=>undefined,
        removeClient: noop
    };
}
function throttle(func, wait = 100) {
    let timer = null;
    let params;
    return function(...args) {
        params = args;
        if (timer === null) {
            timer = setTimeout(()=>{
                func(...params);
                timer = null;
            }, wait);
        }
    };
} // eslint-disable-next-line @typescript-eslint/no-empty-function
function noop() {}
;
 //# sourceMappingURL=index.mjs.map
}),
"[project]/node_modules/@tanstack/query-persist-client-core/build/lib/persist.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "persistQueryClient",
    ()=>persistQueryClient,
    "persistQueryClientRestore",
    ()=>persistQueryClientRestore,
    "persistQueryClientSave",
    ()=>persistQueryClientSave,
    "persistQueryClientSubscribe",
    ()=>persistQueryClientSubscribe
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$persist$2d$client$2d$core$2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$lib$2f$hydration$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tanstack/query-persist-client-core/node_modules/@tanstack/query-core/build/lib/hydration.mjs [app-client] (ecmascript)");
;
/**
 * Checks if emitted event is about cache change and not about observers.
 * Useful for persist, where we only want to trigger save when cache is changed.
 */ const cacheableEventTypes = [
    'added',
    'removed',
    'updated'
];
function isCacheableEventType(eventType) {
    return cacheableEventTypes.includes(eventType);
}
/**
 * Restores persisted data to the QueryCache
 *  - data obtained from persister.restoreClient
 *  - data is hydrated using hydrateOptions
 * If data is expired, busted, empty, or throws, it runs persister.removeClient
 */ async function persistQueryClientRestore({ queryClient, persister, maxAge = 1000 * 60 * 60 * 24, buster = '', hydrateOptions }) {
    try {
        const persistedClient = await persister.restoreClient();
        if (persistedClient) {
            if (persistedClient.timestamp) {
                const expired = Date.now() - persistedClient.timestamp > maxAge;
                const busted = persistedClient.buster !== buster;
                if (expired || busted) {
                    persister.removeClient();
                } else {
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$persist$2d$client$2d$core$2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$lib$2f$hydration$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hydrate"])(queryClient, persistedClient.clientState, hydrateOptions);
                }
            } else {
                persister.removeClient();
            }
        }
    } catch (err) {
        if ("TURBOPACK compile-time truthy", 1) {
            queryClient.getLogger().error(err);
            queryClient.getLogger().warn('Encountered an error attempting to restore client cache from persisted location. As a precaution, the persisted cache will be discarded.');
        }
        persister.removeClient();
    }
}
/**
 * Persists data from the QueryCache
 *  - data dehydrated using dehydrateOptions
 *  - data is persisted using persister.persistClient
 */ async function persistQueryClientSave({ queryClient, persister, buster = '', dehydrateOptions }) {
    const persistClient = {
        buster,
        timestamp: Date.now(),
        clientState: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$persist$2d$client$2d$core$2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$lib$2f$hydration$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["dehydrate"])(queryClient, dehydrateOptions)
    };
    await persister.persistClient(persistClient);
}
/**
 * Subscribe to QueryCache and MutationCache updates (for persisting)
 * @returns an unsubscribe function (to discontinue monitoring)
 */ function persistQueryClientSubscribe(props) {
    const unsubscribeQueryCache = props.queryClient.getQueryCache().subscribe((event)=>{
        if (isCacheableEventType(event.type)) {
            persistQueryClientSave(props);
        }
    });
    const unusbscribeMutationCache = props.queryClient.getMutationCache().subscribe((event)=>{
        if (isCacheableEventType(event.type)) {
            persistQueryClientSave(props);
        }
    });
    return ()=>{
        unsubscribeQueryCache();
        unusbscribeMutationCache();
    };
}
/**
 * Restores persisted data to QueryCache and persists further changes.
 */ function persistQueryClient(props) {
    let hasUnsubscribed = false;
    let persistQueryClientUnsubscribe;
    const unsubscribe = ()=>{
        hasUnsubscribed = true;
        persistQueryClientUnsubscribe == null ? void 0 : persistQueryClientUnsubscribe();
    }; // Attempt restore
    const restorePromise = persistQueryClientRestore(props).then(()=>{
        if (!hasUnsubscribed) {
            // Subscribe to changes in the query cache to trigger the save
            persistQueryClientUnsubscribe = persistQueryClientSubscribe(props);
        }
    });
    return [
        unsubscribe,
        restorePromise
    ];
}
;
 //# sourceMappingURL=persist.mjs.map
}),
"[project]/node_modules/@wagmi/connectors/dist/chunk-UGBGYVBH.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// src/errors.ts
__turbopack_context__.s([
    "ChainNotConfiguredForConnectorError",
    ()=>ChainNotConfiguredForConnectorError,
    "ConnectorNotFoundError",
    ()=>ConnectorNotFoundError
]);
var ChainNotConfiguredForConnectorError = class extends Error {
    constructor({ chainId, connectorId }){
        super(`Chain "${chainId}" not configured for connector "${connectorId}".`);
        this.name = "ChainNotConfiguredForConnectorError";
    }
};
var ConnectorNotFoundError = class extends Error {
    constructor(){
        super(...arguments);
        this.name = "ConnectorNotFoundError";
        this.message = "Connector not found";
    }
};
;
}),
"[project]/node_modules/@wagmi/connectors/dist/chunk-OQILYQDO.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// src/utils/normalizeChainId.ts
__turbopack_context__.s([
    "normalizeChainId",
    ()=>normalizeChainId
]);
function normalizeChainId(chainId) {
    if (typeof chainId === "string") return Number.parseInt(chainId, chainId.trim().substring(0, 2) === "0x" ? 16 : 10);
    if (typeof chainId === "bigint") return Number(chainId);
    return chainId;
}
;
}),
"[project]/node_modules/@wagmi/connectors/dist/chunk-W65LBPLT.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Connector",
    ()=>Connector,
    "__privateAdd",
    ()=>__privateAdd,
    "__privateGet",
    ()=>__privateGet,
    "__privateMethod",
    ()=>__privateMethod,
    "__privateSet",
    ()=>__privateSet
]);
// src/base.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$eventemitter3$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/eventemitter3/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$chains$2f$definitions$2f$goerli$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/chains/definitions/goerli.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$chains$2f$definitions$2f$mainnet$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/chains/definitions/mainnet.js [app-client] (ecmascript)");
var __accessCheck = (obj, member, msg)=>{
    if (!member.has(obj)) throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter)=>{
    __accessCheck(obj, member, "read from private field");
    return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value)=>{
    if (member.has(obj)) throw TypeError("Cannot add the same private member more than once");
    member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter)=>{
    __accessCheck(obj, member, "write to private field");
    setter ? setter.call(obj, value) : member.set(obj, value);
    return value;
};
var __privateMethod = (obj, member, method)=>{
    __accessCheck(obj, member, "access private method");
    return method;
};
;
;
var Connector = class extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$eventemitter3$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] {
    constructor({ chains = [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$chains$2f$definitions$2f$mainnet$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mainnet"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$chains$2f$definitions$2f$goerli$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["goerli"]
    ], options }){
        super();
        this.chains = chains;
        this.options = options;
    }
    getBlockExplorerUrls(chain) {
        const { default: blockExplorer, ...blockExplorers } = chain.blockExplorers ?? {};
        if (blockExplorer) return [
            blockExplorer.url,
            ...Object.values(blockExplorers).map((x)=>x.url)
        ];
    }
    isChainUnsupported(chainId) {
        return !this.chains.some((x)=>x.id === chainId);
    }
    setStorage(storage) {
        this.storage = storage;
    }
};
;
}),
"[project]/node_modules/@wagmi/connectors/dist/chunk-P4NRLOY7.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "InjectedConnector",
    ()=>InjectedConnector
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$connectors$2f$dist$2f$chunk$2d$UGBGYVBH$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@wagmi/connectors/dist/chunk-UGBGYVBH.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$connectors$2f$dist$2f$chunk$2d$OQILYQDO$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@wagmi/connectors/dist/chunk-OQILYQDO.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$connectors$2f$dist$2f$chunk$2d$W65LBPLT$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@wagmi/connectors/dist/chunk-W65LBPLT.js [app-client] (ecmascript)");
// src/injected.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$rpc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/errors/rpc.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$clients$2f$createWalletClient$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/clients/createWalletClient.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$clients$2f$transports$2f$custom$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/clients/transports/custom.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$address$2f$getAddress$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/address/getAddress.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toHex$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/encoding/toHex.js [app-client] (ecmascript)");
;
;
;
;
// src/utils/getInjectedName.ts
function getInjectedName(ethereum) {
    if (!ethereum) return "Injected";
    const getName = (provider)=>{
        if (provider.isApexWallet) return "Apex Wallet";
        if (provider.isAvalanche) return "Core Wallet";
        if (provider.isBackpack) return "Backpack";
        if (provider.isBifrost) return "Bifrost Wallet";
        if (provider.isBitKeep) return "BitKeep";
        if (provider.isBitski) return "Bitski";
        if (provider.isBlockWallet) return "BlockWallet";
        if (provider.isBraveWallet) return "Brave Wallet";
        if (provider.isCoin98) return "Coin98 Wallet";
        if (provider.isCoinbaseWallet) return "Coinbase Wallet";
        if (provider.isDawn) return "Dawn Wallet";
        if (provider.isDefiant) return "Defiant";
        if (provider.isDesig) return "Desig Wallet";
        if (provider.isEnkrypt) return "Enkrypt";
        if (provider.isExodus) return "Exodus";
        if (provider.isFordefi) return "Fordefi";
        if (provider.isFrame) return "Frame";
        if (provider.isFrontier) return "Frontier Wallet";
        if (provider.isGamestop) return "GameStop Wallet";
        if (provider.isHaqqWallet) return "HAQQ Wallet";
        if (provider.isHyperPay) return "HyperPay Wallet";
        if (provider.isImToken) return "ImToken";
        if (provider.isHaloWallet) return "Halo Wallet";
        if (provider.isKuCoinWallet) return "KuCoin Wallet";
        if (provider.isMathWallet) return "MathWallet";
        if (provider.isNovaWallet) return "Nova Wallet";
        if (provider.isOkxWallet || provider.isOKExWallet) return "OKX Wallet";
        if (provider.isOktoWallet) return "Okto Wallet";
        if (provider.isOneInchIOSWallet || provider.isOneInchAndroidWallet) return "1inch Wallet";
        if (provider.isOneKey) return "OneKey Wallet";
        if (provider.isOpera) return "Opera";
        if (provider.isPhantom) return "Phantom";
        if (provider.isPortal) return "Ripio Portal";
        if (provider.isRabby) return "Rabby Wallet";
        if (provider.isRainbow) return "Rainbow";
        if (provider.isSafePal) return "SafePal Wallet";
        if (provider.isStatus) return "Status";
        if (provider.isSubWallet) return "SubWallet";
        if (provider.isTalisman) return "Talisman";
        if (provider.isTally) return "Taho";
        if (provider.isTokenPocket) return "TokenPocket";
        if (provider.isTokenary) return "Tokenary";
        if (provider.isTrust || provider.isTrustWallet) return "Trust Wallet";
        if (provider.isTTWallet) return "TTWallet";
        if (provider.isXDEFI) return "XDEFI Wallet";
        if (provider.isZeal) return "Zeal";
        if (provider.isZerion) return "Zerion";
        if (provider.isMetaMask) return "MetaMask";
    };
    if (ethereum.providers?.length) {
        const nameSet = /* @__PURE__ */ new Set();
        let unknownCount = 1;
        for (const provider of ethereum.providers){
            let name = getName(provider);
            if (!name) {
                name = `Unknown Wallet #${unknownCount}`;
                unknownCount += 1;
            }
            nameSet.add(name);
        }
        const names = [
            ...nameSet
        ];
        if (names.length) return names;
        return names[0] ?? "Injected";
    }
    return getName(ethereum) ?? "Injected";
}
// src/injected.ts
var _provider;
var InjectedConnector = class extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$connectors$2f$dist$2f$chunk$2d$W65LBPLT$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Connector"] {
    constructor({ chains, options: options_ } = {}){
        const options = {
            shimDisconnect: true,
            getProvider () {
                if (typeof window === "undefined") return;
                const ethereum = window.ethereum;
                if (ethereum?.providers && ethereum.providers.length > 0) return ethereum.providers[0];
                return ethereum;
            },
            ...options_
        };
        super({
            chains,
            options
        });
        this.id = "injected";
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$connectors$2f$dist$2f$chunk$2d$W65LBPLT$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__privateAdd"])(this, _provider, void 0);
        this.shimDisconnectKey = `${this.id}.shimDisconnect`;
        this.onAccountsChanged = (accounts)=>{
            if (accounts.length === 0) this.emit("disconnect");
            else this.emit("change", {
                account: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$address$2f$getAddress$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getAddress"])(accounts[0])
            });
        };
        this.onChainChanged = (chainId)=>{
            const id = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$connectors$2f$dist$2f$chunk$2d$OQILYQDO$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["normalizeChainId"])(chainId);
            const unsupported = this.isChainUnsupported(id);
            this.emit("change", {
                chain: {
                    id,
                    unsupported
                }
            });
        };
        this.onDisconnect = async (error)=>{
            if (error.code === 1013) {
                const provider = await this.getProvider();
                if (provider) {
                    const isAuthorized = await this.getAccount();
                    if (isAuthorized) return;
                }
            }
            this.emit("disconnect");
            if (this.options.shimDisconnect) this.storage?.removeItem(this.shimDisconnectKey);
        };
        const provider = options.getProvider();
        if (typeof options.name === "string") this.name = options.name;
        else if (provider) {
            const detectedName = getInjectedName(provider);
            if (options.name) this.name = options.name(detectedName);
            else {
                if (typeof detectedName === "string") this.name = detectedName;
                else this.name = detectedName[0];
            }
        } else this.name = "Injected";
        this.ready = !!provider;
    }
    async connect({ chainId } = {}) {
        try {
            const provider = await this.getProvider();
            if (!provider) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$connectors$2f$dist$2f$chunk$2d$UGBGYVBH$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ConnectorNotFoundError"]();
            if (provider.on) {
                provider.on("accountsChanged", this.onAccountsChanged);
                provider.on("chainChanged", this.onChainChanged);
                provider.on("disconnect", this.onDisconnect);
            }
            this.emit("message", {
                type: "connecting"
            });
            const accounts = await provider.request({
                method: "eth_requestAccounts"
            });
            const account = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$address$2f$getAddress$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getAddress"])(accounts[0]);
            let id = await this.getChainId();
            let unsupported = this.isChainUnsupported(id);
            if (chainId && id !== chainId) {
                const chain = await this.switchChain(chainId);
                id = chain.id;
                unsupported = this.isChainUnsupported(id);
            }
            if (this.options.shimDisconnect) this.storage?.setItem(this.shimDisconnectKey, true);
            return {
                account,
                chain: {
                    id,
                    unsupported
                }
            };
        } catch (error) {
            if (this.isUserRejectedRequestError(error)) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$rpc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UserRejectedRequestError"](error);
            if (error.code === -32002) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$rpc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ResourceUnavailableRpcError"](error);
            throw error;
        }
    }
    async disconnect() {
        const provider = await this.getProvider();
        if (!provider?.removeListener) return;
        provider.removeListener("accountsChanged", this.onAccountsChanged);
        provider.removeListener("chainChanged", this.onChainChanged);
        provider.removeListener("disconnect", this.onDisconnect);
        if (this.options.shimDisconnect) this.storage?.removeItem(this.shimDisconnectKey);
    }
    async getAccount() {
        const provider = await this.getProvider();
        if (!provider) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$connectors$2f$dist$2f$chunk$2d$UGBGYVBH$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ConnectorNotFoundError"]();
        const accounts = await provider.request({
            method: "eth_accounts"
        });
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$address$2f$getAddress$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getAddress"])(accounts[0]);
    }
    async getChainId() {
        const provider = await this.getProvider();
        if (!provider) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$connectors$2f$dist$2f$chunk$2d$UGBGYVBH$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ConnectorNotFoundError"]();
        return provider.request({
            method: "eth_chainId"
        }).then(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$connectors$2f$dist$2f$chunk$2d$OQILYQDO$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["normalizeChainId"]);
    }
    async getProvider() {
        const provider = this.options.getProvider();
        if (provider) (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$connectors$2f$dist$2f$chunk$2d$W65LBPLT$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__privateSet"])(this, _provider, provider);
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$connectors$2f$dist$2f$chunk$2d$W65LBPLT$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__privateGet"])(this, _provider);
    }
    async getWalletClient({ chainId } = {}) {
        const [provider, account] = await Promise.all([
            this.getProvider(),
            this.getAccount()
        ]);
        const chain = this.chains.find((x)=>x.id === chainId);
        if (!provider) throw new Error("provider is required.");
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$clients$2f$createWalletClient$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createWalletClient"])({
            account,
            chain,
            transport: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$clients$2f$transports$2f$custom$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["custom"])(provider)
        });
    }
    async isAuthorized() {
        try {
            if (this.options.shimDisconnect && !this.storage?.getItem(this.shimDisconnectKey)) return false;
            const provider = await this.getProvider();
            if (!provider) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$connectors$2f$dist$2f$chunk$2d$UGBGYVBH$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ConnectorNotFoundError"]();
            const account = await this.getAccount();
            return !!account;
        } catch  {
            return false;
        }
    }
    async switchChain(chainId) {
        const provider = await this.getProvider();
        if (!provider) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$connectors$2f$dist$2f$chunk$2d$UGBGYVBH$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ConnectorNotFoundError"]();
        const id = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$toHex$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["numberToHex"])(chainId);
        try {
            await Promise.all([
                provider.request({
                    method: "wallet_switchEthereumChain",
                    params: [
                        {
                            chainId: id
                        }
                    ]
                }),
                new Promise((res)=>this.on("change", ({ chain })=>{
                        if (chain?.id === chainId) res();
                    }))
            ]);
            return this.chains.find((x)=>x.id === chainId) ?? {
                id: chainId,
                name: `Chain ${id}`,
                network: `${id}`,
                nativeCurrency: {
                    name: "Ether",
                    decimals: 18,
                    symbol: "ETH"
                },
                rpcUrls: {
                    default: {
                        http: [
                            ""
                        ]
                    },
                    public: {
                        http: [
                            ""
                        ]
                    }
                }
            };
        } catch (error) {
            const chain = this.chains.find((x)=>x.id === chainId);
            if (!chain) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$connectors$2f$dist$2f$chunk$2d$UGBGYVBH$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ChainNotConfiguredForConnectorError"]({
                chainId,
                connectorId: this.id
            });
            if (error.code === 4902 || error?.data?.originalError?.code === 4902) {
                try {
                    await provider.request({
                        method: "wallet_addEthereumChain",
                        params: [
                            {
                                chainId: id,
                                chainName: chain.name,
                                nativeCurrency: chain.nativeCurrency,
                                rpcUrls: [
                                    chain.rpcUrls.public?.http[0] ?? ""
                                ],
                                blockExplorerUrls: this.getBlockExplorerUrls(chain)
                            }
                        ]
                    });
                    const currentChainId = await this.getChainId();
                    if (currentChainId !== chainId) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$rpc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UserRejectedRequestError"](new Error("User rejected switch after adding network."));
                    return chain;
                } catch (error2) {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$rpc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UserRejectedRequestError"](error2);
                }
            }
            if (this.isUserRejectedRequestError(error)) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$rpc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UserRejectedRequestError"](error);
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$rpc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SwitchChainError"](error);
        }
    }
    async watchAsset({ address, decimals = 18, image, symbol }) {
        const provider = await this.getProvider();
        if (!provider) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$connectors$2f$dist$2f$chunk$2d$UGBGYVBH$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ConnectorNotFoundError"]();
        return provider.request({
            method: "wallet_watchAsset",
            params: {
                type: "ERC20",
                options: {
                    address,
                    decimals,
                    image,
                    symbol
                }
            }
        });
    }
    isUserRejectedRequestError(error) {
        return error.code === 4001;
    }
};
_provider = new WeakMap();
;
}),
"[project]/node_modules/eventemitter3/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var has = Object.prototype.hasOwnProperty, prefix = '~';
/**
 * Constructor to create a storage for our `EE` objects.
 * An `Events` instance is a plain object whose properties are event names.
 *
 * @constructor
 * @private
 */ function Events() {}
//
// We try to not inherit from `Object.prototype`. In some engines creating an
// instance in this way is faster than calling `Object.create(null)` directly.
// If `Object.create(null)` is not supported we prefix the event names with a
// character to make sure that the built-in object properties are not
// overridden or used as an attack vector.
//
if (Object.create) {
    Events.prototype = Object.create(null);
    //
    // This hack is needed because the `__proto__` property is still inherited in
    // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
    //
    if (!new Events().__proto__) prefix = false;
}
/**
 * Representation of a single event listener.
 *
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
 * @constructor
 * @private
 */ function EE(fn, context, once) {
    this.fn = fn;
    this.context = context;
    this.once = once || false;
}
/**
 * Add a listener for a given event.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} once Specify if the listener is a one-time listener.
 * @returns {EventEmitter}
 * @private
 */ function addListener(emitter, event, fn, context, once) {
    if (typeof fn !== 'function') {
        throw new TypeError('The listener must be a function');
    }
    var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
    if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
    else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
    else emitter._events[evt] = [
        emitter._events[evt],
        listener
    ];
    return emitter;
}
/**
 * Clear event by name.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} evt The Event name.
 * @private
 */ function clearEvent(emitter, evt) {
    if (--emitter._eventsCount === 0) emitter._events = new Events();
    else delete emitter._events[evt];
}
/**
 * Minimal `EventEmitter` interface that is molded against the Node.js
 * `EventEmitter` interface.
 *
 * @constructor
 * @public
 */ function EventEmitter() {
    this._events = new Events();
    this._eventsCount = 0;
}
/**
 * Return an array listing the events for which the emitter has registered
 * listeners.
 *
 * @returns {Array}
 * @public
 */ EventEmitter.prototype.eventNames = function eventNames() {
    var names = [], events, name;
    if (this._eventsCount === 0) return names;
    for(name in events = this._events){
        if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
    }
    if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
    }
    return names;
};
/**
 * Return the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Array} The registered listeners.
 * @public
 */ EventEmitter.prototype.listeners = function listeners(event) {
    var evt = prefix ? prefix + event : event, handlers = this._events[evt];
    if (!handlers) return [];
    if (handlers.fn) return [
        handlers.fn
    ];
    for(var i = 0, l = handlers.length, ee = new Array(l); i < l; i++){
        ee[i] = handlers[i].fn;
    }
    return ee;
};
/**
 * Return the number of listeners listening to a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Number} The number of listeners.
 * @public
 */ EventEmitter.prototype.listenerCount = function listenerCount(event) {
    var evt = prefix ? prefix + event : event, listeners = this._events[evt];
    if (!listeners) return 0;
    if (listeners.fn) return 1;
    return listeners.length;
};
/**
 * Calls each of the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Boolean} `true` if the event had listeners, else `false`.
 * @public
 */ EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt]) return false;
    var listeners = this._events[evt], len = arguments.length, args, i;
    if (listeners.fn) {
        if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);
        switch(len){
            case 1:
                return listeners.fn.call(listeners.context), true;
            case 2:
                return listeners.fn.call(listeners.context, a1), true;
            case 3:
                return listeners.fn.call(listeners.context, a1, a2), true;
            case 4:
                return listeners.fn.call(listeners.context, a1, a2, a3), true;
            case 5:
                return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
            case 6:
                return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for(i = 1, args = new Array(len - 1); i < len; i++){
            args[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args);
    } else {
        var length = listeners.length, j;
        for(i = 0; i < length; i++){
            if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);
            switch(len){
                case 1:
                    listeners[i].fn.call(listeners[i].context);
                    break;
                case 2:
                    listeners[i].fn.call(listeners[i].context, a1);
                    break;
                case 3:
                    listeners[i].fn.call(listeners[i].context, a1, a2);
                    break;
                case 4:
                    listeners[i].fn.call(listeners[i].context, a1, a2, a3);
                    break;
                default:
                    if (!args) for(j = 1, args = new Array(len - 1); j < len; j++){
                        args[j - 1] = arguments[j];
                    }
                    listeners[i].fn.apply(listeners[i].context, args);
            }
        }
    }
    return true;
};
/**
 * Add a listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */ EventEmitter.prototype.on = function on(event, fn, context) {
    return addListener(this, event, fn, context, false);
};
/**
 * Add a one-time listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */ EventEmitter.prototype.once = function once(event, fn, context) {
    return addListener(this, event, fn, context, true);
};
/**
 * Remove the listeners of a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn Only remove the listeners that match this function.
 * @param {*} context Only remove the listeners that have this context.
 * @param {Boolean} once Only remove one-time listeners.
 * @returns {EventEmitter} `this`.
 * @public
 */ EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt]) return this;
    if (!fn) {
        clearEvent(this, evt);
        return this;
    }
    var listeners = this._events[evt];
    if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
            clearEvent(this, evt);
        }
    } else {
        for(var i = 0, events = [], length = listeners.length; i < length; i++){
            if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
                events.push(listeners[i]);
            }
        }
        //
        // Reset the array, or remove it completely if we have no more listeners.
        //
        if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
        else clearEvent(this, evt);
    }
    return this;
};
/**
 * Remove all listeners, or those of the specified event.
 *
 * @param {(String|Symbol)} [event] The event name.
 * @returns {EventEmitter} `this`.
 * @public
 */ EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
    var evt;
    if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt]) clearEvent(this, evt);
    } else {
        this._events = new Events();
        this._eventsCount = 0;
    }
    return this;
};
//
// Alias methods names because people roll like that.
//
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.addListener = EventEmitter.prototype.on;
//
// Expose the prefix.
//
EventEmitter.prefixed = prefix;
//
// Allow `EventEmitter` to be imported as module namespace.
//
EventEmitter.EventEmitter = EventEmitter;
//
// Expose the module.
//
if ("TURBOPACK compile-time truthy", 1) {
    module.exports = EventEmitter;
}
}),
"[project]/node_modules/viem/node_modules/@noble/hashes/esm/_assert.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "bool",
    ()=>bool,
    "bytes",
    ()=>bytes,
    "default",
    ()=>__TURBOPACK__default__export__,
    "exists",
    ()=>exists,
    "hash",
    ()=>hash,
    "number",
    ()=>number,
    "output",
    ()=>output
]);
function number(n) {
    if (!Number.isSafeInteger(n) || n < 0) throw new Error(`Wrong positive integer: ${n}`);
}
function bool(b) {
    if (typeof b !== 'boolean') throw new Error(`Expected boolean, not ${b}`);
}
function bytes(b, ...lengths) {
    if (!(b instanceof Uint8Array)) throw new Error('Expected Uint8Array');
    if (lengths.length > 0 && !lengths.includes(b.length)) throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
}
function hash(hash) {
    if (typeof hash !== 'function' || typeof hash.create !== 'function') throw new Error('Hash should be wrapped by utils.wrapConstructor');
    number(hash.outputLen);
    number(hash.blockLen);
}
function exists(instance, checkFinished = true) {
    if (instance.destroyed) throw new Error('Hash instance has been destroyed');
    if (checkFinished && instance.finished) throw new Error('Hash#digest() has already been called');
}
function output(out, instance) {
    bytes(out);
    const min = instance.outputLen;
    if (out.length < min) {
        throw new Error(`digestInto() expects output buffer of length at least ${min}`);
    }
}
;
const assert = {
    number,
    bool,
    bytes,
    hash,
    exists,
    output
};
const __TURBOPACK__default__export__ = assert;
 //# sourceMappingURL=_assert.js.map
}),
"[project]/node_modules/viem/node_modules/@noble/hashes/esm/_u64.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "add",
    ()=>add,
    "add3H",
    ()=>add3H,
    "add3L",
    ()=>add3L,
    "add4H",
    ()=>add4H,
    "add4L",
    ()=>add4L,
    "add5H",
    ()=>add5H,
    "add5L",
    ()=>add5L,
    "default",
    ()=>__TURBOPACK__default__export__,
    "fromBig",
    ()=>fromBig,
    "rotlBH",
    ()=>rotlBH,
    "rotlBL",
    ()=>rotlBL,
    "rotlSH",
    ()=>rotlSH,
    "rotlSL",
    ()=>rotlSL,
    "rotr32H",
    ()=>rotr32H,
    "rotr32L",
    ()=>rotr32L,
    "rotrBH",
    ()=>rotrBH,
    "rotrBL",
    ()=>rotrBL,
    "rotrSH",
    ()=>rotrSH,
    "rotrSL",
    ()=>rotrSL,
    "shrSH",
    ()=>shrSH,
    "shrSL",
    ()=>shrSL,
    "split",
    ()=>split,
    "toBig",
    ()=>toBig
]);
const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
const _32n = /* @__PURE__ */ BigInt(32);
// We are not using BigUint64Array, because they are extremely slow as per 2022
function fromBig(n, le = false) {
    if (le) return {
        h: Number(n & U32_MASK64),
        l: Number(n >> _32n & U32_MASK64)
    };
    return {
        h: Number(n >> _32n & U32_MASK64) | 0,
        l: Number(n & U32_MASK64) | 0
    };
}
function split(lst, le = false) {
    let Ah = new Uint32Array(lst.length);
    let Al = new Uint32Array(lst.length);
    for(let i = 0; i < lst.length; i++){
        const { h, l } = fromBig(lst[i], le);
        [Ah[i], Al[i]] = [
            h,
            l
        ];
    }
    return [
        Ah,
        Al
    ];
}
const toBig = (h, l)=>BigInt(h >>> 0) << _32n | BigInt(l >>> 0);
// for Shift in [0, 32)
const shrSH = (h, _l, s)=>h >>> s;
const shrSL = (h, l, s)=>h << 32 - s | l >>> s;
// Right rotate for Shift in [1, 32)
const rotrSH = (h, l, s)=>h >>> s | l << 32 - s;
const rotrSL = (h, l, s)=>h << 32 - s | l >>> s;
// Right rotate for Shift in (32, 64), NOTE: 32 is special case.
const rotrBH = (h, l, s)=>h << 64 - s | l >>> s - 32;
const rotrBL = (h, l, s)=>h >>> s - 32 | l << 64 - s;
// Right rotate for shift===32 (just swaps l&h)
const rotr32H = (_h, l)=>l;
const rotr32L = (h, _l)=>h;
// Left rotate for Shift in [1, 32)
const rotlSH = (h, l, s)=>h << s | l >>> 32 - s;
const rotlSL = (h, l, s)=>l << s | h >>> 32 - s;
// Left rotate for Shift in (32, 64), NOTE: 32 is special case.
const rotlBH = (h, l, s)=>l << s - 32 | h >>> 64 - s;
const rotlBL = (h, l, s)=>h << s - 32 | l >>> 64 - s;
// JS uses 32-bit signed integers for bitwise operations which means we cannot
// simple take carry out of low bit sum by shift, we need to use division.
function add(Ah, Al, Bh, Bl) {
    const l = (Al >>> 0) + (Bl >>> 0);
    return {
        h: Ah + Bh + (l / 2 ** 32 | 0) | 0,
        l: l | 0
    };
}
// Addition with more than 2 elements
const add3L = (Al, Bl, Cl)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
const add3H = (low, Ah, Bh, Ch)=>Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
const add4L = (Al, Bl, Cl, Dl)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
const add4H = (low, Ah, Bh, Ch, Dh)=>Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
const add5L = (Al, Bl, Cl, Dl, El)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
const add5H = (low, Ah, Bh, Ch, Dh, Eh)=>Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
;
// prettier-ignore
const u64 = {
    fromBig,
    split,
    toBig,
    shrSH,
    shrSL,
    rotrSH,
    rotrSL,
    rotrBH,
    rotrBL,
    rotr32H,
    rotr32L,
    rotlSH,
    rotlSL,
    rotlBH,
    rotlBL,
    add,
    add3L,
    add3H,
    add4L,
    add4H,
    add5H,
    add5L
};
const __TURBOPACK__default__export__ = u64;
 //# sourceMappingURL=_u64.js.map
}),
"[project]/node_modules/viem/node_modules/@noble/hashes/esm/crypto.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "crypto",
    ()=>crypto
]);
const crypto = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined; //# sourceMappingURL=crypto.js.map
}),
"[project]/node_modules/viem/node_modules/@noble/hashes/esm/utils.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.
// node.js versions earlier than v19 don't declare it in global scope.
// For node.js, package.json#exports field mapping rewrites import
// from `crypto` to `cryptoNode`, which imports native module.
// Makes the utils un-importable in browsers without a bundler.
// Once node.js 18 is deprecated, we can just drop the import.
__turbopack_context__.s([
    "Hash",
    ()=>Hash,
    "asyncLoop",
    ()=>asyncLoop,
    "bytesToHex",
    ()=>bytesToHex,
    "checkOpts",
    ()=>checkOpts,
    "concatBytes",
    ()=>concatBytes,
    "createView",
    ()=>createView,
    "hexToBytes",
    ()=>hexToBytes,
    "isLE",
    ()=>isLE,
    "nextTick",
    ()=>nextTick,
    "randomBytes",
    ()=>randomBytes,
    "rotr",
    ()=>rotr,
    "toBytes",
    ()=>toBytes,
    "u32",
    ()=>u32,
    "u8",
    ()=>u8,
    "utf8ToBytes",
    ()=>utf8ToBytes,
    "wrapConstructor",
    ()=>wrapConstructor,
    "wrapConstructorWithOpts",
    ()=>wrapConstructorWithOpts,
    "wrapXOFConstructorWithOpts",
    ()=>wrapXOFConstructorWithOpts
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$crypto$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/node_modules/@noble/hashes/esm/crypto.js [app-client] (ecmascript)");
;
const u8a = (a)=>a instanceof Uint8Array;
const u8 = (arr)=>new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
const u32 = (arr)=>new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
const createView = (arr)=>new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
const rotr = (word, shift)=>word << 32 - shift | word >>> shift;
const isLE = new Uint8Array(new Uint32Array([
    0x11223344
]).buffer)[0] === 0x44;
if (!isLE) throw new Error('Non little-endian hardware is not supported');
const hexes = /* @__PURE__ */ Array.from({
    length: 256
}, (_, i)=>i.toString(16).padStart(2, '0'));
function bytesToHex(bytes) {
    if (!u8a(bytes)) throw new Error('Uint8Array expected');
    // pre-caching improves the speed 6x
    let hex = '';
    for(let i = 0; i < bytes.length; i++){
        hex += hexes[bytes[i]];
    }
    return hex;
}
function hexToBytes(hex) {
    if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);
    const len = hex.length;
    if (len % 2) throw new Error('padded hex string expected, got unpadded hex of length ' + len);
    const array = new Uint8Array(len / 2);
    for(let i = 0; i < array.length; i++){
        const j = i * 2;
        const hexByte = hex.slice(j, j + 2);
        const byte = Number.parseInt(hexByte, 16);
        if (Number.isNaN(byte) || byte < 0) throw new Error('Invalid byte sequence');
        array[i] = byte;
    }
    return array;
}
const nextTick = async ()=>{};
async function asyncLoop(iters, tick, cb) {
    let ts = Date.now();
    for(let i = 0; i < iters; i++){
        cb(i);
        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too
        const diff = Date.now() - ts;
        if (diff >= 0 && diff < tick) continue;
        await nextTick();
        ts += diff;
    }
}
function utf8ToBytes(str) {
    if (typeof str !== 'string') throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809
}
function toBytes(data) {
    if (typeof data === 'string') data = utf8ToBytes(data);
    if (!u8a(data)) throw new Error(`expected Uint8Array, got ${typeof data}`);
    return data;
}
function concatBytes(...arrays) {
    const r = new Uint8Array(arrays.reduce((sum, a)=>sum + a.length, 0));
    let pad = 0; // walk through each item, ensure they have proper type
    arrays.forEach((a)=>{
        if (!u8a(a)) throw new Error('Uint8Array expected');
        r.set(a, pad);
        pad += a.length;
    });
    return r;
}
class Hash {
    // Safe version that clones internal state
    clone() {
        return this._cloneInto();
    }
}
const toStr = {}.toString;
function checkOpts(defaults, opts) {
    if (opts !== undefined && toStr.call(opts) !== '[object Object]') throw new Error('Options should be object or undefined');
    const merged = Object.assign(defaults, opts);
    return merged;
}
function wrapConstructor(hashCons) {
    const hashC = (msg)=>hashCons().update(toBytes(msg)).digest();
    const tmp = hashCons();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = ()=>hashCons();
    return hashC;
}
function wrapConstructorWithOpts(hashCons) {
    const hashC = (msg, opts)=>hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts)=>hashCons(opts);
    return hashC;
}
function wrapXOFConstructorWithOpts(hashCons) {
    const hashC = (msg, opts)=>hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts)=>hashCons(opts);
    return hashC;
}
function randomBytes(bytesLength = 32) {
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$crypto$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["crypto"] && typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$crypto$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["crypto"].getRandomValues === 'function') {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$crypto$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["crypto"].getRandomValues(new Uint8Array(bytesLength));
    }
    throw new Error('crypto.getRandomValues must be defined');
} //# sourceMappingURL=utils.js.map
}),
"[project]/node_modules/viem/node_modules/@noble/hashes/esm/sha3.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Keccak",
    ()=>Keccak,
    "keccakP",
    ()=>keccakP,
    "keccak_224",
    ()=>keccak_224,
    "keccak_256",
    ()=>keccak_256,
    "keccak_384",
    ()=>keccak_384,
    "keccak_512",
    ()=>keccak_512,
    "sha3_224",
    ()=>sha3_224,
    "sha3_256",
    ()=>sha3_256,
    "sha3_384",
    ()=>sha3_384,
    "sha3_512",
    ()=>sha3_512,
    "shake128",
    ()=>shake128,
    "shake256",
    ()=>shake256
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_assert$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/node_modules/@noble/hashes/esm/_assert.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_u64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/node_modules/@noble/hashes/esm/_u64.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/node_modules/@noble/hashes/esm/utils.js [app-client] (ecmascript)");
;
;
;
// SHA3 (keccak) is based on a new design: basically, the internal state is bigger than output size.
// It's called a sponge function.
// Various per round constants calculations
const [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [
    [],
    [],
    []
];
const _0n = /* @__PURE__ */ BigInt(0);
const _1n = /* @__PURE__ */ BigInt(1);
const _2n = /* @__PURE__ */ BigInt(2);
const _7n = /* @__PURE__ */ BigInt(7);
const _256n = /* @__PURE__ */ BigInt(256);
const _0x71n = /* @__PURE__ */ BigInt(0x71);
for(let round = 0, R = _1n, x = 1, y = 0; round < 24; round++){
    // Pi
    [x, y] = [
        y,
        (2 * x + 3 * y) % 5
    ];
    SHA3_PI.push(2 * (5 * y + x));
    // Rotational
    SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
    // Iota
    let t = _0n;
    for(let j = 0; j < 7; j++){
        R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;
        if (R & _2n) t ^= _1n << (_1n << /* @__PURE__ */ BigInt(j)) - _1n;
    }
    _SHA3_IOTA.push(t);
}
const [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_u64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["split"])(_SHA3_IOTA, true);
// Left rotation (without 0, 32, 64)
const rotlH = (h, l, s)=>s > 32 ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_u64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rotlBH"])(h, l, s) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_u64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rotlSH"])(h, l, s);
const rotlL = (h, l, s)=>s > 32 ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_u64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rotlBL"])(h, l, s) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_u64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rotlSL"])(h, l, s);
function keccakP(s, rounds = 24) {
    const B = new Uint32Array(5 * 2);
    // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)
    for(let round = 24 - rounds; round < 24; round++){
        // Theta 
        for(let x = 0; x < 10; x++)B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
        for(let x = 0; x < 10; x += 2){
            const idx1 = (x + 8) % 10;
            const idx0 = (x + 2) % 10;
            const B0 = B[idx0];
            const B1 = B[idx0 + 1];
            const Th = rotlH(B0, B1, 1) ^ B[idx1];
            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
            for(let y = 0; y < 50; y += 10){
                s[x + y] ^= Th;
                s[x + y + 1] ^= Tl;
            }
        }
        // Rho () and Pi ()
        let curH = s[2];
        let curL = s[3];
        for(let t = 0; t < 24; t++){
            const shift = SHA3_ROTL[t];
            const Th = rotlH(curH, curL, shift);
            const Tl = rotlL(curH, curL, shift);
            const PI = SHA3_PI[t];
            curH = s[PI];
            curL = s[PI + 1];
            s[PI] = Th;
            s[PI + 1] = Tl;
        }
        // Chi ()
        for(let y = 0; y < 50; y += 10){
            for(let x = 0; x < 10; x++)B[x] = s[y + x];
            for(let x = 0; x < 10; x++)s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
        }
        // Iota ()
        s[0] ^= SHA3_IOTA_H[round];
        s[1] ^= SHA3_IOTA_L[round];
    }
    B.fill(0);
}
class Keccak extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Hash"] {
    // NOTE: we accept arguments in bytes instead of bits here.
    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24){
        super();
        this.blockLen = blockLen;
        this.suffix = suffix;
        this.outputLen = outputLen;
        this.enableXOF = enableXOF;
        this.rounds = rounds;
        this.pos = 0;
        this.posOut = 0;
        this.finished = false;
        this.destroyed = false;
        // Can be passed from user as dkLen
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_assert$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"])(outputLen);
        // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes
        if (0 >= this.blockLen || this.blockLen >= 200) throw new Error('Sha3 supports only keccak-f1600 function');
        this.state = new Uint8Array(200);
        this.state32 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["u32"])(this.state);
    }
    keccak() {
        keccakP(this.state32, this.rounds);
        this.posOut = 0;
        this.pos = 0;
    }
    update(data) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_assert$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["exists"])(this);
        const { blockLen, state } = this;
        data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toBytes"])(data);
        const len = data.length;
        for(let pos = 0; pos < len;){
            const take = Math.min(blockLen - this.pos, len - pos);
            for(let i = 0; i < take; i++)state[this.pos++] ^= data[pos++];
            if (this.pos === blockLen) this.keccak();
        }
        return this;
    }
    finish() {
        if (this.finished) return;
        this.finished = true;
        const { state, suffix, pos, blockLen } = this;
        // Do the padding
        state[pos] ^= suffix;
        if ((suffix & 0x80) !== 0 && pos === blockLen - 1) this.keccak();
        state[blockLen - 1] ^= 0x80;
        this.keccak();
    }
    writeInto(out) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_assert$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["exists"])(this, false);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_assert$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bytes"])(out);
        this.finish();
        const bufferOut = this.state;
        const { blockLen } = this;
        for(let pos = 0, len = out.length; pos < len;){
            if (this.posOut >= blockLen) this.keccak();
            const take = Math.min(blockLen - this.posOut, len - pos);
            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
            this.posOut += take;
            pos += take;
        }
        return out;
    }
    xofInto(out) {
        // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF
        if (!this.enableXOF) throw new Error('XOF is not possible for this instance');
        return this.writeInto(out);
    }
    xof(bytes) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_assert$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["number"])(bytes);
        return this.xofInto(new Uint8Array(bytes));
    }
    digestInto(out) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_assert$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["output"])(out, this);
        if (this.finished) throw new Error('digest() was already called');
        this.writeInto(out);
        this.destroy();
        return out;
    }
    digest() {
        return this.digestInto(new Uint8Array(this.outputLen));
    }
    destroy() {
        this.destroyed = true;
        this.state.fill(0);
    }
    _cloneInto(to) {
        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
        to.state32.set(this.state32);
        to.pos = this.pos;
        to.posOut = this.posOut;
        to.finished = this.finished;
        to.rounds = rounds;
        // Suffix can change in cSHAKE
        to.suffix = suffix;
        to.outputLen = outputLen;
        to.enableXOF = enableXOF;
        to.destroyed = this.destroyed;
        return to;
    }
}
const gen = (suffix, blockLen, outputLen)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["wrapConstructor"])(()=>new Keccak(blockLen, suffix, outputLen));
const sha3_224 = /* @__PURE__ */ gen(0x06, 144, 224 / 8);
const sha3_256 = /* @__PURE__ */ gen(0x06, 136, 256 / 8);
const sha3_384 = /* @__PURE__ */ gen(0x06, 104, 384 / 8);
const sha3_512 = /* @__PURE__ */ gen(0x06, 72, 512 / 8);
const keccak_224 = /* @__PURE__ */ gen(0x01, 144, 224 / 8);
const keccak_256 = /* @__PURE__ */ gen(0x01, 136, 256 / 8);
const keccak_384 = /* @__PURE__ */ gen(0x01, 104, 384 / 8);
const keccak_512 = /* @__PURE__ */ gen(0x01, 72, 512 / 8);
const genShake = (suffix, blockLen, outputLen)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["wrapXOFConstructorWithOpts"])((opts = {})=>new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));
const shake128 = /* @__PURE__ */ genShake(0x1f, 168, 128 / 8);
const shake256 = /* @__PURE__ */ genShake(0x1f, 136, 256 / 8); //# sourceMappingURL=sha3.js.map
}),
"[project]/node_modules/viem/node_modules/abitype/dist/esm/regex.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "bytesRegex",
    ()=>bytesRegex,
    "execTyped",
    ()=>execTyped,
    "integerRegex",
    ()=>integerRegex,
    "isTupleRegex",
    ()=>isTupleRegex
]);
function execTyped(regex, string) {
    const match = regex.exec(string);
    return match?.groups;
}
const bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;
const integerRegex = /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
const isTupleRegex = /^\(.+?\).*?$/; //# sourceMappingURL=regex.js.map
}),
"[project]/node_modules/viem/node_modules/abitype/dist/esm/human-readable/formatAbiParameter.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "formatAbiParameter",
    ()=>formatAbiParameter
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$regex$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/node_modules/abitype/dist/esm/regex.js [app-client] (ecmascript)");
;
const tupleRegex = /^tuple(?<array>(\[(\d*)\])*)$/;
function formatAbiParameter(abiParameter) {
    let type = abiParameter.type;
    if (tupleRegex.test(abiParameter.type) && 'components' in abiParameter) {
        type = '(';
        const length = abiParameter.components.length;
        for(let i = 0; i < length; i++){
            const component = abiParameter.components[i];
            type += formatAbiParameter(component);
            if (i < length - 1) type += ', ';
        }
        const result = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$regex$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["execTyped"])(tupleRegex, abiParameter.type);
        type += `)${result?.array ?? ''}`;
        return formatAbiParameter({
            ...abiParameter,
            type
        });
    }
    if ('indexed' in abiParameter && abiParameter.indexed) type = `${type} indexed`;
    if (abiParameter.name) return `${type} ${abiParameter.name}`;
    return type;
} //# sourceMappingURL=formatAbiParameter.js.map
}),
"[project]/node_modules/viem/node_modules/abitype/dist/esm/human-readable/formatAbiParameters.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "formatAbiParameters",
    ()=>formatAbiParameters
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$formatAbiParameter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/node_modules/abitype/dist/esm/human-readable/formatAbiParameter.js [app-client] (ecmascript)");
;
function formatAbiParameters(abiParameters) {
    let params = '';
    const length = abiParameters.length;
    for(let i = 0; i < length; i++){
        const abiParameter = abiParameters[i];
        params += (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$formatAbiParameter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["formatAbiParameter"])(abiParameter);
        if (i !== length - 1) params += ', ';
    }
    return params;
} //# sourceMappingURL=formatAbiParameters.js.map
}),
"[project]/node_modules/viem/node_modules/abitype/dist/esm/human-readable/formatAbiItem.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "formatAbiItem",
    ()=>formatAbiItem
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$formatAbiParameters$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/node_modules/abitype/dist/esm/human-readable/formatAbiParameters.js [app-client] (ecmascript)");
;
function formatAbiItem(abiItem) {
    if (abiItem.type === 'function') return `function ${abiItem.name}(${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$formatAbiParameters$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["formatAbiParameters"])(abiItem.inputs)})${abiItem.stateMutability && abiItem.stateMutability !== 'nonpayable' ? ` ${abiItem.stateMutability}` : ''}${abiItem.outputs.length ? ` returns (${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$formatAbiParameters$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["formatAbiParameters"])(abiItem.outputs)})` : ''}`;
    else if (abiItem.type === 'event') return `event ${abiItem.name}(${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$formatAbiParameters$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["formatAbiParameters"])(abiItem.inputs)})`;
    else if (abiItem.type === 'error') return `error ${abiItem.name}(${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$formatAbiParameters$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["formatAbiParameters"])(abiItem.inputs)})`;
    else if (abiItem.type === 'constructor') return `constructor(${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$formatAbiParameters$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["formatAbiParameters"])(abiItem.inputs)})${abiItem.stateMutability === 'payable' ? ' payable' : ''}`;
    else if (abiItem.type === 'fallback') return 'fallback()';
    return 'receive() external payable';
} //# sourceMappingURL=formatAbiItem.js.map
}),
"[project]/node_modules/@wagmi/core/dist/chunk-MQXBDTVK.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "__privateAdd",
    ()=>__privateAdd,
    "__privateGet",
    ()=>__privateGet,
    "__privateMethod",
    ()=>__privateMethod,
    "__privateSet",
    ()=>__privateSet
]);
var __accessCheck = (obj, member, msg)=>{
    if (!member.has(obj)) throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter)=>{
    __accessCheck(obj, member, "read from private field");
    return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value)=>{
    if (member.has(obj)) throw TypeError("Cannot add the same private member more than once");
    member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter)=>{
    __accessCheck(obj, member, "write to private field");
    setter ? setter.call(obj, value) : member.set(obj, value);
    return value;
};
var __privateMethod = (obj, member, method)=>{
    __accessCheck(obj, member, "access private method");
    return method;
};
;
}),
"[project]/node_modules/@wagmi/core/dist/chunk-TSH6VVF4.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ChainMismatchError",
    ()=>ChainMismatchError,
    "ChainNotConfiguredError",
    ()=>ChainNotConfiguredError,
    "Config",
    ()=>Config,
    "ConfigChainsNotFound",
    ()=>ConfigChainsNotFound,
    "ConnectorAlreadyConnectedError",
    ()=>ConnectorAlreadyConnectedError,
    "SwitchChainNotSupportedError",
    ()=>SwitchChainNotSupportedError,
    "configureChains",
    ()=>configureChains,
    "connect",
    ()=>connect,
    "createConfig",
    ()=>createConfig,
    "createStorage",
    ()=>createStorage,
    "deepEqual",
    ()=>deepEqual,
    "deserialize",
    ()=>deserialize,
    "disconnect",
    ()=>disconnect,
    "erc20ABI",
    ()=>erc20ABI,
    "erc4626ABI",
    ()=>erc4626ABI,
    "erc721ABI",
    ()=>erc721ABI,
    "fetchBalance",
    ()=>fetchBalance,
    "fetchBlockNumber",
    ()=>fetchBlockNumber,
    "fetchEnsAddress",
    ()=>fetchEnsAddress,
    "fetchEnsAvatar",
    ()=>fetchEnsAvatar,
    "fetchEnsName",
    ()=>fetchEnsName,
    "fetchEnsResolver",
    ()=>fetchEnsResolver,
    "fetchFeeData",
    ()=>fetchFeeData,
    "fetchToken",
    ()=>fetchToken,
    "fetchTransaction",
    ()=>fetchTransaction,
    "getAccount",
    ()=>getAccount,
    "getCallParameters",
    ()=>getCallParameters,
    "getConfig",
    ()=>getConfig,
    "getContract",
    ()=>getContract,
    "getNetwork",
    ()=>getNetwork,
    "getPublicClient",
    ()=>getPublicClient,
    "getSendTransactionParameters",
    ()=>getSendTransactionParameters,
    "getUnit",
    ()=>getUnit,
    "getWalletClient",
    ()=>getWalletClient,
    "getWebSocketPublicClient",
    ()=>getWebSocketPublicClient,
    "multicall",
    ()=>multicall,
    "noopStorage",
    ()=>noopStorage,
    "prepareSendTransaction",
    ()=>prepareSendTransaction,
    "prepareWriteContract",
    ()=>prepareWriteContract,
    "readContract",
    ()=>readContract,
    "readContracts",
    ()=>readContracts,
    "sendTransaction",
    ()=>sendTransaction,
    "serialize",
    ()=>serialize,
    "signMessage",
    ()=>signMessage,
    "signTypedData",
    ()=>signTypedData,
    "switchNetwork",
    ()=>switchNetwork,
    "waitForTransaction",
    ()=>waitForTransaction,
    "watchAccount",
    ()=>watchAccount,
    "watchBlockNumber",
    ()=>watchBlockNumber,
    "watchContractEvent",
    ()=>watchContractEvent,
    "watchMulticall",
    ()=>watchMulticall,
    "watchNetwork",
    ()=>watchNetwork,
    "watchPendingTransactions",
    ()=>watchPendingTransactions,
    "watchPublicClient",
    ()=>watchPublicClient,
    "watchReadContract",
    ()=>watchReadContract,
    "watchReadContracts",
    ()=>watchReadContracts,
    "watchWalletClient",
    ()=>watchWalletClient,
    "watchWebSocketPublicClient",
    ()=>watchWebSocketPublicClient,
    "writeContract",
    ()=>writeContract
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$connectors$2f$dist$2f$chunk$2d$P4NRLOY7$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@wagmi/connectors/dist/chunk-P4NRLOY7.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$core$2f$dist$2f$chunk$2d$MQXBDTVK$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@wagmi/core/dist/chunk-MQXBDTVK.js [app-client] (ecmascript)");
// src/utils/configureChains.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$clients$2f$createPublicClient$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/clients/createPublicClient.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$clients$2f$transports$2f$fallback$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/clients/transports/fallback.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$clients$2f$transports$2f$http$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/clients/transports/http.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$clients$2f$transports$2f$webSocket$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/clients/transports/webSocket.js [app-client] (ecmascript)");
// src/errors.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$connectors$2f$dist$2f$chunk$2d$UGBGYVBH$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@wagmi/connectors/dist/chunk-UGBGYVBH.js [app-client] (ecmascript)");
// src/utils/getUnit.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$constants$2f$unit$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/constants/unit.js [app-client] (ecmascript)");
// src/config.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zustand$2f$esm$2f$middleware$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/zustand/esm/middleware.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zustand$2f$esm$2f$vanilla$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/zustand/esm/vanilla.mjs [app-client] (ecmascript)");
// src/actions/accounts/fetchBalance.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$contract$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/errors/contract.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$unit$2f$formatUnits$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/unit/formatUnits.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$fromHex$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/encoding/fromHex.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$trim$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/data/trim.js [app-client] (ecmascript)");
// src/actions/viem/watchWalletClient.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zustand$2f$esm$2f$shallow$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/zustand/esm/shallow.mjs [app-client] (ecmascript)");
// src/actions/contracts/getContract.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$actions$2f$getContract$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/actions/getContract.js [app-client] (ecmascript)");
// src/actions/ens/fetchEnsAddress.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$address$2f$getAddress$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/address/getAddress.js [app-client] (ecmascript)");
// src/actions/network-status/fetchFeeData.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$unit$2f$parseGwei$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/unit/parseGwei.js [app-client] (ecmascript)");
// src/actions/transactions/prepareSendTransaction.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$address$2f$isAddress$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/address/isAddress.js [app-client] (ecmascript)");
;
;
;
function configureChains(defaultChains, providers, { batch = {
    multicall: {
        wait: 32
    }
}, pollingInterval = 4e3, rank, retryCount, retryDelay, stallTimeout } = {}) {
    if (!defaultChains.length) throw new Error("must have at least one chain");
    let chains = [];
    const httpUrls = {};
    const wsUrls = {};
    for (const chain of defaultChains){
        let configExists = false;
        for (const provider of providers){
            const apiConfig = provider(chain);
            if (!apiConfig) continue;
            configExists = true;
            if (!chains.some(({ id })=>id === chain.id)) {
                chains = [
                    ...chains,
                    apiConfig.chain
                ];
            }
            httpUrls[chain.id] = [
                ...httpUrls[chain.id] || [],
                ...apiConfig.rpcUrls.http
            ];
            if (apiConfig.rpcUrls.webSocket) {
                wsUrls[chain.id] = [
                    ...wsUrls[chain.id] || [],
                    ...apiConfig.rpcUrls.webSocket
                ];
            }
        }
        if (!configExists) {
            throw new Error([
                `Could not find valid provider configuration for chain "${chain.name}".
`,
                "You may need to add `jsonRpcProvider` to `configureChains` with the chain's RPC URLs.",
                "Read more: https://wagmi.sh/core/providers/jsonRpc"
            ].join("\n"));
        }
    }
    return {
        chains,
        publicClient: ({ chainId })=>{
            const activeChain = chains.find((x)=>x.id === chainId) ?? defaultChains[0];
            const chainHttpUrls = httpUrls[activeChain.id];
            if (!chainHttpUrls || !chainHttpUrls[0]) throw new Error(`No providers configured for chain "${activeChain.id}"`);
            const publicClient = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$clients$2f$createPublicClient$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createPublicClient"])({
                batch,
                chain: activeChain,
                transport: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$clients$2f$transports$2f$fallback$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fallback"])(chainHttpUrls.map((url)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$clients$2f$transports$2f$http$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["http"])(url, {
                        timeout: stallTimeout
                    })), {
                    rank,
                    retryCount,
                    retryDelay
                }),
                pollingInterval
            });
            return Object.assign(publicClient, {
                chains
            });
        },
        webSocketPublicClient: ({ chainId })=>{
            const activeChain = chains.find((x)=>x.id === chainId) ?? defaultChains[0];
            const chainWsUrls = wsUrls[activeChain.id];
            if (!chainWsUrls || !chainWsUrls[0]) return void 0;
            const publicClient = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$clients$2f$createPublicClient$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createPublicClient"])({
                batch,
                chain: activeChain,
                transport: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$clients$2f$transports$2f$fallback$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fallback"])(chainWsUrls.map((url)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$clients$2f$transports$2f$webSocket$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["webSocket"])(url, {
                        timeout: stallTimeout
                    })), {
                    rank,
                    retryCount,
                    retryDelay
                }),
                pollingInterval
            });
            return Object.assign(publicClient, {
                chains
            });
        }
    };
}
;
var ChainMismatchError = class extends Error {
    constructor({ activeChain, targetChain }){
        super(`Chain mismatch: Expected "${targetChain}", received "${activeChain}".`);
        this.name = "ChainMismatchError";
    }
};
var ChainNotConfiguredError = class extends Error {
    constructor({ chainId, connectorId }){
        super(`Chain "${chainId}" not configured${connectorId ? ` for connector "${connectorId}"` : ""}.`);
        this.name = "ChainNotConfigured";
    }
};
var ConnectorAlreadyConnectedError = class extends Error {
    constructor(){
        super(...arguments);
        this.name = "ConnectorAlreadyConnectedError";
        this.message = "Connector already connected";
    }
};
var ConfigChainsNotFound = class extends Error {
    constructor(){
        super(...arguments);
        this.name = "ConfigChainsNotFound";
        this.message = "No chains were found on the wagmi config. Some functions that require a chain may not work.";
    }
};
var SwitchChainNotSupportedError = class extends Error {
    constructor({ connector }){
        super(`"${connector.name}" does not support programmatic chain switching.`);
        this.name = "SwitchChainNotSupportedError";
    }
};
// src/utils/deepEqual.ts
function deepEqual(a, b) {
    if (a === b) return true;
    if (a && b && typeof a === "object" && typeof b === "object") {
        if (a.constructor !== b.constructor) return false;
        let length;
        let i;
        if (Array.isArray(a) && Array.isArray(b)) {
            length = a.length;
            if (length != b.length) return false;
            for(i = length; i-- !== 0;)if (!deepEqual(a[i], b[i])) return false;
            return true;
        }
        if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
        if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();
        const keys = Object.keys(a);
        length = keys.length;
        if (length !== Object.keys(b).length) return false;
        for(i = length; i-- !== 0;)if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;
        for(i = length; i-- !== 0;){
            const key = keys[i];
            if (key && !deepEqual(a[key], b[key])) return false;
        }
        return true;
    }
    return a !== a && b !== b;
}
// src/utils/deserialize.ts
var findAndReplace = (cacheRef, { find, replace })=>{
    if (cacheRef && find(cacheRef)) {
        return replace(cacheRef);
    }
    if (typeof cacheRef !== "object") {
        return cacheRef;
    }
    if (Array.isArray(cacheRef)) {
        return cacheRef.map((item)=>findAndReplace(item, {
                find,
                replace
            }));
    }
    if (cacheRef instanceof Object) {
        return Object.entries(cacheRef).reduce((curr, [key, value])=>({
                ...curr,
                [key]: findAndReplace(value, {
                    find,
                    replace
                })
            }), {});
    }
    return cacheRef;
};
function deserialize(cachedString) {
    const cache = JSON.parse(cachedString);
    const deserializedCacheWithBigInts = findAndReplace(cache, {
        find: (data)=>typeof data === "string" && data.startsWith("#bigint."),
        replace: (data)=>BigInt(data.replace("#bigint.", ""))
    });
    return deserializedCacheWithBigInts;
}
// src/utils/getParameters.ts
function getCallParameters(args) {
    return {
        accessList: args.accessList,
        account: args.account,
        blockNumber: args.blockNumber,
        blockTag: args.blockTag,
        data: args.data,
        gas: args.gas,
        gasPrice: args.gasPrice,
        maxFeePerGas: args.maxFeePerGas,
        maxPriorityFeePerGas: args.maxPriorityFeePerGas,
        nonce: args.nonce,
        to: args.to,
        value: args.value
    };
}
function getSendTransactionParameters(args) {
    return {
        accessList: args.accessList,
        account: args.account,
        data: args.data,
        gas: args.gas,
        gasPrice: args.gasPrice,
        maxFeePerGas: args.maxFeePerGas,
        maxPriorityFeePerGas: args.maxPriorityFeePerGas,
        nonce: args.nonce,
        to: args.to,
        value: args.value
    };
}
;
function getUnit(unit) {
    if (typeof unit === "number") return unit;
    if (unit === "wei") return 0;
    return Math.abs(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$constants$2f$unit$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["weiUnits"][unit]);
}
// src/utils/serialize.ts
function getReferenceKey(keys, cutoff) {
    return keys.slice(0, cutoff).join(".") || ".";
}
function getCutoff(array, value) {
    const { length } = array;
    for(let index = 0; index < length; ++index){
        if (array[index] === value) {
            return index + 1;
        }
    }
    return 0;
}
function createReplacer(replacer, circularReplacer) {
    const hasReplacer = typeof replacer === "function";
    const hasCircularReplacer = typeof circularReplacer === "function";
    const cache = [];
    const keys = [];
    return function replace(key, value) {
        if (typeof value === "object") {
            if (cache.length) {
                const thisCutoff = getCutoff(cache, this);
                if (thisCutoff === 0) {
                    cache[cache.length] = this;
                } else {
                    cache.splice(thisCutoff);
                    keys.splice(thisCutoff);
                }
                keys[keys.length] = key;
                const valueCutoff = getCutoff(cache, value);
                if (valueCutoff !== 0) {
                    return hasCircularReplacer ? circularReplacer.call(this, key, value, getReferenceKey(keys, valueCutoff)) : `[ref=${getReferenceKey(keys, valueCutoff)}]`;
                }
            } else {
                cache[0] = value;
                keys[0] = key;
            }
        }
        return hasReplacer ? replacer.call(this, key, value) : value;
    };
}
function serialize(value, replacer, indent, circularReplacer) {
    return JSON.stringify(value, createReplacer((key, value_)=>{
        const value2 = typeof value_ === "bigint" ? `#bigint.${value_.toString()}` : value_;
        return replacer?.(key, value2) || value2;
    }, circularReplacer), indent ?? void 0);
}
;
;
// src/storage.ts
var noopStorage = {
    getItem: (_key)=>"",
    setItem: (_key, _value)=>null,
    removeItem: (_key)=>null
};
function createStorage({ deserialize: deserialize2 = deserialize, key: prefix = "wagmi", serialize: serialize2 = serialize, storage }) {
    return {
        ...storage,
        getItem: (key, defaultState = null)=>{
            const value = storage.getItem(`${prefix}.${key}`);
            try {
                return value ? deserialize2(value) : defaultState;
            } catch (error) {
                console.warn(error);
                return defaultState;
            }
        },
        setItem: (key, value)=>{
            if (value === null) {
                storage.removeItem(`${prefix}.${key}`);
            } else {
                try {
                    storage.setItem(`${prefix}.${key}`, serialize2(value));
                } catch (err) {
                    console.error(err);
                }
            }
        },
        removeItem: (key)=>storage.removeItem(`${prefix}.${key}`)
    };
}
// src/config.ts
var storeKey = "store";
var _isAutoConnecting, _lastUsedConnector, _addEffects, addEffects_fn;
var Config = class {
    constructor({ autoConnect = false, connectors = [
        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$connectors$2f$dist$2f$chunk$2d$P4NRLOY7$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["InjectedConnector"]()
    ], publicClient, storage = createStorage({
        storage: typeof window !== "undefined" ? window.localStorage : noopStorage
    }), logger = {
        warn: console.warn
    }, webSocketPublicClient }){
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$core$2f$dist$2f$chunk$2d$MQXBDTVK$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__privateAdd"])(this, _addEffects);
        this.publicClients = /* @__PURE__ */ new Map();
        this.webSocketPublicClients = /* @__PURE__ */ new Map();
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$core$2f$dist$2f$chunk$2d$MQXBDTVK$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__privateAdd"])(this, _isAutoConnecting, void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$core$2f$dist$2f$chunk$2d$MQXBDTVK$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__privateAdd"])(this, _lastUsedConnector, void 0);
        this.args = {
            autoConnect,
            connectors,
            logger,
            publicClient,
            storage,
            webSocketPublicClient
        };
        let status = "disconnected";
        let chainId;
        if (autoConnect) {
            try {
                const rawState = storage.getItem(storeKey);
                const data = rawState?.state?.data;
                status = data?.account ? "reconnecting" : "connecting";
                chainId = data?.chain?.id;
            } catch (_error) {}
        }
        const connectors_ = typeof connectors === "function" ? connectors() : connectors;
        connectors_.forEach((connector)=>connector.setStorage(storage));
        this.store = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zustand$2f$esm$2f$vanilla$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createStore"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zustand$2f$esm$2f$middleware$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["subscribeWithSelector"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zustand$2f$esm$2f$middleware$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["persist"])(()=>({
                connectors: connectors_,
                publicClient: this.getPublicClient({
                    chainId
                }),
                status,
                webSocketPublicClient: this.getWebSocketPublicClient({
                    chainId
                })
            }), {
            name: storeKey,
            storage,
            partialize: (state)=>({
                    ...autoConnect && {
                        data: {
                            account: state?.data?.account,
                            chain: state?.data?.chain
                        }
                    },
                    chains: state?.chains
                }),
            version: 2
        })));
        this.storage = storage;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$core$2f$dist$2f$chunk$2d$MQXBDTVK$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__privateSet"])(this, _lastUsedConnector, storage?.getItem("wallet"));
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$core$2f$dist$2f$chunk$2d$MQXBDTVK$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__privateMethod"])(this, _addEffects, addEffects_fn).call(this);
        if (autoConnect && typeof window !== "undefined") setTimeout(async ()=>await this.autoConnect(), 0);
    }
    get chains() {
        return this.store.getState().chains;
    }
    get connectors() {
        return this.store.getState().connectors;
    }
    get connector() {
        return this.store.getState().connector;
    }
    get data() {
        return this.store.getState().data;
    }
    get error() {
        return this.store.getState().error;
    }
    get lastUsedChainId() {
        return this.data?.chain?.id;
    }
    get publicClient() {
        return this.store.getState().publicClient;
    }
    get status() {
        return this.store.getState().status;
    }
    get subscribe() {
        return this.store.subscribe;
    }
    get webSocketPublicClient() {
        return this.store.getState().webSocketPublicClient;
    }
    setState(updater) {
        const newState = typeof updater === "function" ? updater(this.store.getState()) : updater;
        this.store.setState(newState, true);
    }
    clearState() {
        this.setState((x)=>({
                ...x,
                chains: void 0,
                connector: void 0,
                data: void 0,
                error: void 0,
                status: "disconnected"
            }));
    }
    async destroy() {
        if (this.connector) await this.connector.disconnect?.();
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$core$2f$dist$2f$chunk$2d$MQXBDTVK$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__privateSet"])(this, _isAutoConnecting, false);
        this.clearState();
        this.store.destroy();
    }
    async autoConnect() {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$core$2f$dist$2f$chunk$2d$MQXBDTVK$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__privateGet"])(this, _isAutoConnecting)) return;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$core$2f$dist$2f$chunk$2d$MQXBDTVK$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__privateSet"])(this, _isAutoConnecting, true);
        this.setState((x)=>({
                ...x,
                status: x.data?.account ? "reconnecting" : "connecting"
            }));
        const sorted = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$core$2f$dist$2f$chunk$2d$MQXBDTVK$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__privateGet"])(this, _lastUsedConnector) ? [
            ...this.connectors
        ].sort((x)=>x.id === (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$core$2f$dist$2f$chunk$2d$MQXBDTVK$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__privateGet"])(this, _lastUsedConnector) ? -1 : 1) : this.connectors;
        let connected = false;
        for (const connector of sorted){
            if (!connector.ready || !connector.isAuthorized) continue;
            const isAuthorized = await connector.isAuthorized();
            if (!isAuthorized) continue;
            const data = await connector.connect();
            this.setState((x)=>({
                    ...x,
                    connector,
                    chains: connector?.chains,
                    data,
                    status: "connected"
                }));
            connected = true;
            break;
        }
        if (!connected) this.setState((x)=>({
                ...x,
                data: void 0,
                status: "disconnected"
            }));
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$core$2f$dist$2f$chunk$2d$MQXBDTVK$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["__privateSet"])(this, _isAutoConnecting, false);
        return this.data;
    }
    setConnectors(connectors) {
        this.args = {
            ...this.args,
            connectors
        };
        const connectors_ = typeof connectors === "function" ? connectors() : connectors;
        connectors_.forEach((connector)=>connector.setStorage(this.args.storage));
        this.setState((x)=>({
                ...x,
                connectors: connectors_
            }));
    }
    getPublicClient({ chainId } = {}) {
        let publicClient_ = this.publicClients.get(-1);
        if (publicClient_ && publicClient_?.chain.id === chainId) return publicClient_;
        publicClient_ = this.publicClients.get(chainId ?? -1);
        if (publicClient_) return publicClient_;
        const { publicClient } = this.args;
        publicClient_ = typeof publicClient === "function" ? publicClient({
            chainId
        }) : publicClient;
        this.publicClients.set(chainId ?? -1, publicClient_);
        return publicClient_;
    }
    setPublicClient(publicClient) {
        const chainId = this.data?.chain?.id;
        this.args = {
            ...this.args,
            publicClient
        };
        this.publicClients.clear();
        this.setState((x)=>({
                ...x,
                publicClient: this.getPublicClient({
                    chainId
                })
            }));
    }
    getWebSocketPublicClient({ chainId } = {}) {
        let webSocketPublicClient_ = this.webSocketPublicClients.get(-1);
        if (webSocketPublicClient_ && webSocketPublicClient_?.chain.id === chainId) return webSocketPublicClient_;
        webSocketPublicClient_ = this.webSocketPublicClients.get(chainId ?? -1);
        if (webSocketPublicClient_) return webSocketPublicClient_;
        const { webSocketPublicClient } = this.args;
        webSocketPublicClient_ = typeof webSocketPublicClient === "function" ? webSocketPublicClient({
            chainId
        }) : webSocketPublicClient;
        if (webSocketPublicClient_) this.webSocketPublicClients.set(chainId ?? -1, webSocketPublicClient_);
        return webSocketPublicClient_;
    }
    setWebSocketPublicClient(webSocketPublicClient) {
        const chainId = this.data?.chain?.id;
        this.args = {
            ...this.args,
            webSocketPublicClient
        };
        this.webSocketPublicClients.clear();
        this.setState((x)=>({
                ...x,
                webSocketPublicClient: this.getWebSocketPublicClient({
                    chainId
                })
            }));
    }
    setLastUsedConnector(lastUsedConnector = null) {
        this.storage?.setItem("wallet", lastUsedConnector);
    }
};
_isAutoConnecting = new WeakMap();
_lastUsedConnector = new WeakMap();
_addEffects = new WeakSet();
addEffects_fn = function() {
    const onChange = (data)=>{
        this.setState((x)=>({
                ...x,
                data: {
                    ...x.data,
                    ...data
                }
            }));
    };
    const onDisconnect = ()=>{
        this.clearState();
    };
    const onError = (error)=>{
        this.setState((x)=>({
                ...x,
                error
            }));
    };
    this.store.subscribe(({ connector })=>connector, (connector, prevConnector)=>{
        prevConnector?.off?.("change", onChange);
        prevConnector?.off?.("disconnect", onDisconnect);
        prevConnector?.off?.("error", onError);
        if (!connector) return;
        connector.on?.("change", onChange);
        connector.on?.("disconnect", onDisconnect);
        connector.on?.("error", onError);
    });
    const { publicClient, webSocketPublicClient } = this.args;
    const subscribePublicClient = typeof publicClient === "function";
    const subscribeWebSocketPublicClient = typeof webSocketPublicClient === "function";
    if (subscribePublicClient || subscribeWebSocketPublicClient) this.store.subscribe(({ data })=>data?.chain?.id, (chainId)=>{
        this.setState((x)=>({
                ...x,
                publicClient: this.getPublicClient({
                    chainId
                }),
                webSocketPublicClient: this.getWebSocketPublicClient({
                    chainId
                })
            }));
    });
};
var config;
function createConfig(args) {
    const config_ = new Config(args);
    config = config_;
    return config_;
}
function getConfig() {
    if (!config) {
        throw new Error("No wagmi config found. Ensure you have set up a config: https://wagmi.sh/react/config");
    }
    return config;
}
// src/actions/accounts/connect.ts
async function connect({ chainId, connector }) {
    const config2 = getConfig();
    const activeConnector = config2.connector;
    if (activeConnector && connector.id === activeConnector.id) throw new ConnectorAlreadyConnectedError();
    try {
        config2.setState((x)=>({
                ...x,
                status: "connecting"
            }));
        const data = await connector.connect({
            chainId
        });
        config2.setLastUsedConnector(connector.id);
        config2.setState((x)=>({
                ...x,
                connector,
                chains: connector?.chains,
                data,
                status: "connected"
            }));
        config2.storage.setItem("connected", true);
        return {
            ...data,
            connector
        };
    } catch (err) {
        config2.setState((x)=>{
            return {
                ...x,
                status: x.connector ? "connected" : "disconnected"
            };
        });
        throw err;
    }
}
// src/actions/accounts/disconnect.ts
async function disconnect() {
    const config2 = getConfig();
    if (config2.connector) await config2.connector.disconnect();
    config2.clearState();
    config2.storage.removeItem("connected");
}
;
// src/constants/abis.ts
var erc20ABI = [
    {
        type: "event",
        name: "Approval",
        inputs: [
            {
                indexed: true,
                name: "owner",
                type: "address"
            },
            {
                indexed: true,
                name: "spender",
                type: "address"
            },
            {
                indexed: false,
                name: "value",
                type: "uint256"
            }
        ]
    },
    {
        type: "event",
        name: "Transfer",
        inputs: [
            {
                indexed: true,
                name: "from",
                type: "address"
            },
            {
                indexed: true,
                name: "to",
                type: "address"
            },
            {
                indexed: false,
                name: "value",
                type: "uint256"
            }
        ]
    },
    {
        type: "function",
        name: "allowance",
        stateMutability: "view",
        inputs: [
            {
                name: "owner",
                type: "address"
            },
            {
                name: "spender",
                type: "address"
            }
        ],
        outputs: [
            {
                name: "",
                type: "uint256"
            }
        ]
    },
    {
        type: "function",
        name: "approve",
        stateMutability: "nonpayable",
        inputs: [
            {
                name: "spender",
                type: "address"
            },
            {
                name: "amount",
                type: "uint256"
            }
        ],
        outputs: [
            {
                name: "",
                type: "bool"
            }
        ]
    },
    {
        type: "function",
        name: "balanceOf",
        stateMutability: "view",
        inputs: [
            {
                name: "account",
                type: "address"
            }
        ],
        outputs: [
            {
                name: "",
                type: "uint256"
            }
        ]
    },
    {
        type: "function",
        name: "decimals",
        stateMutability: "view",
        inputs: [],
        outputs: [
            {
                name: "",
                type: "uint8"
            }
        ]
    },
    {
        type: "function",
        name: "name",
        stateMutability: "view",
        inputs: [],
        outputs: [
            {
                name: "",
                type: "string"
            }
        ]
    },
    {
        type: "function",
        name: "symbol",
        stateMutability: "view",
        inputs: [],
        outputs: [
            {
                name: "",
                type: "string"
            }
        ]
    },
    {
        type: "function",
        name: "totalSupply",
        stateMutability: "view",
        inputs: [],
        outputs: [
            {
                name: "",
                type: "uint256"
            }
        ]
    },
    {
        type: "function",
        name: "transfer",
        stateMutability: "nonpayable",
        inputs: [
            {
                name: "recipient",
                type: "address"
            },
            {
                name: "amount",
                type: "uint256"
            }
        ],
        outputs: [
            {
                name: "",
                type: "bool"
            }
        ]
    },
    {
        type: "function",
        name: "transferFrom",
        stateMutability: "nonpayable",
        inputs: [
            {
                name: "sender",
                type: "address"
            },
            {
                name: "recipient",
                type: "address"
            },
            {
                name: "amount",
                type: "uint256"
            }
        ],
        outputs: [
            {
                name: "",
                type: "bool"
            }
        ]
    }
];
var erc20ABI_bytes32 = [
    {
        type: "event",
        name: "Approval",
        inputs: [
            {
                indexed: true,
                name: "owner",
                type: "address"
            },
            {
                indexed: true,
                name: "spender",
                type: "address"
            },
            {
                indexed: false,
                name: "value",
                type: "uint256"
            }
        ]
    },
    {
        type: "event",
        name: "Transfer",
        inputs: [
            {
                indexed: true,
                name: "from",
                type: "address"
            },
            {
                indexed: true,
                name: "to",
                type: "address"
            },
            {
                indexed: false,
                name: "value",
                type: "uint256"
            }
        ]
    },
    {
        type: "function",
        name: "allowance",
        stateMutability: "view",
        inputs: [
            {
                name: "owner",
                type: "address"
            },
            {
                name: "spender",
                type: "address"
            }
        ],
        outputs: [
            {
                name: "",
                type: "uint256"
            }
        ]
    },
    {
        type: "function",
        name: "approve",
        stateMutability: "nonpayable",
        inputs: [
            {
                name: "spender",
                type: "address"
            },
            {
                name: "amount",
                type: "uint256"
            }
        ],
        outputs: [
            {
                name: "",
                type: "bool"
            }
        ]
    },
    {
        type: "function",
        name: "balanceOf",
        stateMutability: "view",
        inputs: [
            {
                name: "account",
                type: "address"
            }
        ],
        outputs: [
            {
                name: "",
                type: "uint256"
            }
        ]
    },
    {
        type: "function",
        name: "decimals",
        stateMutability: "view",
        inputs: [],
        outputs: [
            {
                name: "",
                type: "uint8"
            }
        ]
    },
    {
        type: "function",
        name: "name",
        stateMutability: "view",
        inputs: [],
        outputs: [
            {
                name: "",
                type: "bytes32"
            }
        ]
    },
    {
        type: "function",
        name: "symbol",
        stateMutability: "view",
        inputs: [],
        outputs: [
            {
                name: "",
                type: "bytes32"
            }
        ]
    },
    {
        type: "function",
        name: "totalSupply",
        stateMutability: "view",
        inputs: [],
        outputs: [
            {
                name: "",
                type: "uint256"
            }
        ]
    },
    {
        type: "function",
        name: "transfer",
        stateMutability: "nonpayable",
        inputs: [
            {
                name: "recipient",
                type: "address"
            },
            {
                name: "amount",
                type: "uint256"
            }
        ],
        outputs: [
            {
                name: "",
                type: "bool"
            }
        ]
    },
    {
        type: "function",
        name: "transferFrom",
        stateMutability: "nonpayable",
        inputs: [
            {
                name: "sender",
                type: "address"
            },
            {
                name: "recipient",
                type: "address"
            },
            {
                name: "amount",
                type: "uint256"
            }
        ],
        outputs: [
            {
                name: "",
                type: "bool"
            }
        ]
    }
];
var erc721ABI = [
    {
        type: "event",
        name: "Approval",
        inputs: [
            {
                indexed: true,
                name: "owner",
                type: "address"
            },
            {
                indexed: true,
                name: "spender",
                type: "address"
            },
            {
                indexed: true,
                name: "tokenId",
                type: "uint256"
            }
        ]
    },
    {
        type: "event",
        name: "ApprovalForAll",
        inputs: [
            {
                indexed: true,
                name: "owner",
                type: "address"
            },
            {
                indexed: true,
                name: "operator",
                type: "address"
            },
            {
                indexed: false,
                name: "approved",
                type: "bool"
            }
        ]
    },
    {
        type: "event",
        name: "Transfer",
        inputs: [
            {
                indexed: true,
                name: "from",
                type: "address"
            },
            {
                indexed: true,
                name: "to",
                type: "address"
            },
            {
                indexed: true,
                name: "tokenId",
                type: "uint256"
            }
        ]
    },
    {
        type: "function",
        name: "approve",
        stateMutability: "payable",
        inputs: [
            {
                name: "spender",
                type: "address"
            },
            {
                name: "tokenId",
                type: "uint256"
            }
        ],
        outputs: []
    },
    {
        type: "function",
        name: "balanceOf",
        stateMutability: "view",
        inputs: [
            {
                name: "account",
                type: "address"
            }
        ],
        outputs: [
            {
                name: "",
                type: "uint256"
            }
        ]
    },
    {
        type: "function",
        name: "getApproved",
        stateMutability: "view",
        inputs: [
            {
                name: "tokenId",
                type: "uint256"
            }
        ],
        outputs: [
            {
                name: "",
                type: "address"
            }
        ]
    },
    {
        type: "function",
        name: "isApprovedForAll",
        stateMutability: "view",
        inputs: [
            {
                name: "owner",
                type: "address"
            },
            {
                name: "operator",
                type: "address"
            }
        ],
        outputs: [
            {
                name: "",
                type: "bool"
            }
        ]
    },
    {
        type: "function",
        name: "name",
        stateMutability: "view",
        inputs: [],
        outputs: [
            {
                name: "",
                type: "string"
            }
        ]
    },
    {
        type: "function",
        name: "ownerOf",
        stateMutability: "view",
        inputs: [
            {
                name: "tokenId",
                type: "uint256"
            }
        ],
        outputs: [
            {
                name: "owner",
                type: "address"
            }
        ]
    },
    {
        type: "function",
        name: "safeTransferFrom",
        stateMutability: "payable",
        inputs: [
            {
                name: "from",
                type: "address"
            },
            {
                name: "to",
                type: "address"
            },
            {
                name: "tokenId",
                type: "uint256"
            }
        ],
        outputs: []
    },
    {
        type: "function",
        name: "safeTransferFrom",
        stateMutability: "nonpayable",
        inputs: [
            {
                name: "from",
                type: "address"
            },
            {
                name: "to",
                type: "address"
            },
            {
                name: "id",
                type: "uint256"
            },
            {
                name: "data",
                type: "bytes"
            }
        ],
        outputs: []
    },
    {
        type: "function",
        name: "setApprovalForAll",
        stateMutability: "nonpayable",
        inputs: [
            {
                name: "operator",
                type: "address"
            },
            {
                name: "approved",
                type: "bool"
            }
        ],
        outputs: []
    },
    {
        type: "function",
        name: "symbol",
        stateMutability: "view",
        inputs: [],
        outputs: [
            {
                name: "",
                type: "string"
            }
        ]
    },
    {
        type: "function",
        name: "tokenByIndex",
        stateMutability: "view",
        inputs: [
            {
                name: "index",
                type: "uint256"
            }
        ],
        outputs: [
            {
                name: "",
                type: "uint256"
            }
        ]
    },
    {
        type: "function",
        name: "tokenByIndex",
        stateMutability: "view",
        inputs: [
            {
                name: "owner",
                type: "address"
            },
            {
                name: "index",
                type: "uint256"
            }
        ],
        outputs: [
            {
                name: "tokenId",
                type: "uint256"
            }
        ]
    },
    {
        type: "function",
        name: "tokenURI",
        stateMutability: "view",
        inputs: [
            {
                name: "tokenId",
                type: "uint256"
            }
        ],
        outputs: [
            {
                name: "",
                type: "string"
            }
        ]
    },
    {
        type: "function",
        name: "totalSupply",
        stateMutability: "view",
        inputs: [],
        outputs: [
            {
                name: "",
                type: "uint256"
            }
        ]
    },
    {
        type: "function",
        name: "transferFrom",
        stateMutability: "payable",
        inputs: [
            {
                name: "sender",
                type: "address"
            },
            {
                name: "recipient",
                type: "address"
            },
            {
                name: "tokeId",
                type: "uint256"
            }
        ],
        outputs: []
    }
];
var erc4626ABI = [
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                name: "owner",
                type: "address"
            },
            {
                indexed: true,
                name: "spender",
                type: "address"
            },
            {
                indexed: false,
                name: "value",
                type: "uint256"
            }
        ],
        name: "Approval",
        type: "event"
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                name: "sender",
                type: "address"
            },
            {
                indexed: true,
                name: "receiver",
                type: "address"
            },
            {
                indexed: false,
                name: "assets",
                type: "uint256"
            },
            {
                indexed: false,
                name: "shares",
                type: "uint256"
            }
        ],
        name: "Deposit",
        type: "event"
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                name: "from",
                type: "address"
            },
            {
                indexed: true,
                name: "to",
                type: "address"
            },
            {
                indexed: false,
                name: "value",
                type: "uint256"
            }
        ],
        name: "Transfer",
        type: "event"
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                name: "sender",
                type: "address"
            },
            {
                indexed: true,
                name: "receiver",
                type: "address"
            },
            {
                indexed: true,
                name: "owner",
                type: "address"
            },
            {
                indexed: false,
                name: "assets",
                type: "uint256"
            },
            {
                indexed: false,
                name: "shares",
                type: "uint256"
            }
        ],
        name: "Withdraw",
        type: "event"
    },
    {
        inputs: [
            {
                name: "owner",
                type: "address"
            },
            {
                name: "spender",
                type: "address"
            }
        ],
        name: "allowance",
        outputs: [
            {
                name: "",
                type: "uint256"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                name: "spender",
                type: "address"
            },
            {
                name: "amount",
                type: "uint256"
            }
        ],
        name: "approve",
        outputs: [
            {
                name: "",
                type: "bool"
            }
        ],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [],
        name: "asset",
        outputs: [
            {
                name: "assetTokenAddress",
                type: "address"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                name: "account",
                type: "address"
            }
        ],
        name: "balanceOf",
        outputs: [
            {
                name: "",
                type: "uint256"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                name: "shares",
                type: "uint256"
            }
        ],
        name: "convertToAssets",
        outputs: [
            {
                name: "assets",
                type: "uint256"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                name: "assets",
                type: "uint256"
            }
        ],
        name: "convertToShares",
        outputs: [
            {
                name: "shares",
                type: "uint256"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                name: "assets",
                type: "uint256"
            },
            {
                name: "receiver",
                type: "address"
            }
        ],
        name: "deposit",
        outputs: [
            {
                name: "shares",
                type: "uint256"
            }
        ],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
            {
                name: "caller",
                type: "address"
            }
        ],
        name: "maxDeposit",
        outputs: [
            {
                name: "maxAssets",
                type: "uint256"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                name: "caller",
                type: "address"
            }
        ],
        name: "maxMint",
        outputs: [
            {
                name: "maxShares",
                type: "uint256"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                name: "owner",
                type: "address"
            }
        ],
        name: "maxRedeem",
        outputs: [
            {
                name: "maxShares",
                type: "uint256"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                name: "owner",
                type: "address"
            }
        ],
        name: "maxWithdraw",
        outputs: [
            {
                name: "maxAssets",
                type: "uint256"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                name: "shares",
                type: "uint256"
            },
            {
                name: "receiver",
                type: "address"
            }
        ],
        name: "mint",
        outputs: [
            {
                name: "assets",
                type: "uint256"
            }
        ],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
            {
                name: "assets",
                type: "uint256"
            }
        ],
        name: "previewDeposit",
        outputs: [
            {
                name: "shares",
                type: "uint256"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                name: "shares",
                type: "uint256"
            }
        ],
        name: "previewMint",
        outputs: [
            {
                name: "assets",
                type: "uint256"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                name: "shares",
                type: "uint256"
            }
        ],
        name: "previewRedeem",
        outputs: [
            {
                name: "assets",
                type: "uint256"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                name: "assets",
                type: "uint256"
            }
        ],
        name: "previewWithdraw",
        outputs: [
            {
                name: "shares",
                type: "uint256"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                name: "shares",
                type: "uint256"
            },
            {
                name: "receiver",
                type: "address"
            },
            {
                name: "owner",
                type: "address"
            }
        ],
        name: "redeem",
        outputs: [
            {
                name: "assets",
                type: "uint256"
            }
        ],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [],
        name: "totalAssets",
        outputs: [
            {
                name: "totalManagedAssets",
                type: "uint256"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [],
        name: "totalSupply",
        outputs: [
            {
                name: "",
                type: "uint256"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                name: "to",
                type: "address"
            },
            {
                name: "amount",
                type: "uint256"
            }
        ],
        name: "transfer",
        outputs: [
            {
                name: "",
                type: "bool"
            }
        ],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
            {
                name: "from",
                type: "address"
            },
            {
                name: "to",
                type: "address"
            },
            {
                name: "amount",
                type: "uint256"
            }
        ],
        name: "transferFrom",
        outputs: [
            {
                name: "",
                type: "bool"
            }
        ],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
            {
                name: "assets",
                type: "uint256"
            },
            {
                name: "receiver",
                type: "address"
            },
            {
                name: "owner",
                type: "address"
            }
        ],
        name: "withdraw",
        outputs: [
            {
                name: "shares",
                type: "uint256"
            }
        ],
        stateMutability: "nonpayable",
        type: "function"
    }
];
;
async function fetchToken({ address, chainId, formatUnits: unit = 18 }) {
    async function fetchToken_({ abi }) {
        const erc20Config = {
            address,
            abi,
            chainId
        };
        const [decimals, name, symbol, totalSupply] = await readContracts({
            allowFailure: false,
            contracts: [
                {
                    ...erc20Config,
                    functionName: "decimals"
                },
                {
                    ...erc20Config,
                    functionName: "name"
                },
                {
                    ...erc20Config,
                    functionName: "symbol"
                },
                {
                    ...erc20Config,
                    functionName: "totalSupply"
                }
            ]
        });
        return {
            address,
            decimals,
            name,
            symbol,
            totalSupply: {
                formatted: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$unit$2f$formatUnits$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["formatUnits"])(totalSupply, getUnit(unit)),
                value: totalSupply
            }
        };
    }
    try {
        return await fetchToken_({
            abi: erc20ABI
        });
    } catch (err) {
        if (err instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$contract$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ContractFunctionExecutionError"]) {
            const { name, symbol, ...rest } = await fetchToken_({
                abi: erc20ABI_bytes32
            });
            return {
                name: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$fromHex$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hexToString"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$trim$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["trim"])(name, {
                    dir: "right"
                })),
                symbol: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$fromHex$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hexToString"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$trim$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["trim"])(symbol, {
                    dir: "right"
                })),
                ...rest
            };
        }
        throw err;
    }
}
// src/actions/viem/getPublicClient.ts
function getPublicClient({ chainId } = {}) {
    const config2 = getConfig();
    if (chainId) return config2.getPublicClient({
        chainId
    }) || config2.publicClient;
    return config2.publicClient;
}
// src/actions/viem/getWalletClient.ts
async function getWalletClient({ chainId } = {}) {
    const config2 = getConfig();
    const walletClient = await config2.connector?.getWalletClient?.({
        chainId
    }) || null;
    return walletClient;
}
// src/actions/viem/getWebSocketPublicClient.ts
function getWebSocketPublicClient({ chainId } = {}) {
    const config2 = getConfig();
    if (chainId) return config2.getWebSocketPublicClient({
        chainId
    }) || config2.webSocketPublicClient;
    return config2.webSocketPublicClient;
}
// src/actions/viem/watchPublicClient.ts
function watchPublicClient(args, callback) {
    const config2 = getConfig();
    const handleChange = async ()=>callback(getPublicClient(args));
    const unsubscribe = config2.subscribe(({ publicClient })=>publicClient, handleChange);
    return unsubscribe;
}
;
function watchWalletClient({ chainId }, callback) {
    const config2 = getConfig();
    const handleChange = async ({ chainId: chainId_ })=>{
        if (chainId && chainId_ && chainId !== chainId_) return;
        const walletClient = await getWalletClient({
            chainId
        });
        if (!getConfig().connector) return callback(null);
        return callback(walletClient);
    };
    const unsubscribe = config2.subscribe(({ data, connector })=>({
            account: data?.account,
            chainId: data?.chain?.id,
            connector
        }), handleChange, {
        equalityFn: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zustand$2f$esm$2f$shallow$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shallow"]
    });
    return unsubscribe;
}
// src/actions/viem/watchWebSocketPublicClient.ts
function watchWebSocketPublicClient(args, callback) {
    const config2 = getConfig();
    const handleChange = async ()=>callback(getWebSocketPublicClient(args));
    const unsubscribe = config2.subscribe(({ webSocketPublicClient })=>webSocketPublicClient, handleChange);
    return unsubscribe;
}
// src/actions/contracts/prepareWriteContract.ts
async function prepareWriteContract({ abi, address, args, chainId, dataSuffix, functionName, walletClient: walletClient_, ...config2 }) {
    const publicClient = getPublicClient({
        chainId
    });
    const walletClient = walletClient_ ?? await getWalletClient({
        chainId
    });
    if (!walletClient) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$connectors$2f$dist$2f$chunk$2d$UGBGYVBH$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ConnectorNotFoundError"]();
    if (chainId) assertActiveChain({
        chainId
    });
    const { account, accessList, blockNumber, blockTag, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, value } = getCallParameters(config2);
    const { result, request } = await publicClient.simulateContract({
        abi,
        address,
        functionName,
        args,
        account: account || walletClient.account,
        accessList,
        blockNumber,
        blockTag,
        dataSuffix,
        gas,
        gasPrice,
        maxFeePerGas,
        maxPriorityFeePerGas,
        nonce,
        value
    });
    const minimizedAbi = abi.filter((abiItem)=>"name" in abiItem && abiItem.name === functionName);
    return {
        mode: "prepared",
        request: {
            ...request,
            abi: minimizedAbi,
            chainId
        },
        result
    };
}
;
function getContract({ address, abi, chainId, walletClient }) {
    const publicClient = getPublicClient({
        chainId
    });
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$actions$2f$getContract$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getContract"])({
        address,
        abi,
        publicClient,
        walletClient
    });
}
// src/actions/contracts/multicall.ts
async function multicall({ chainId, contracts, blockNumber, blockTag, ...args }) {
    const publicClient = getPublicClient({
        chainId
    });
    if (!publicClient.chains) throw new ConfigChainsNotFound();
    if (chainId && publicClient.chain.id !== chainId) throw new ChainNotConfiguredError({
        chainId
    });
    return publicClient.multicall({
        allowFailure: args.allowFailure ?? true,
        blockNumber,
        blockTag,
        contracts
    });
}
// src/actions/contracts/readContract.ts
async function readContract({ address, account, chainId, abi, args, functionName, blockNumber, blockTag }) {
    const publicClient = getPublicClient({
        chainId
    });
    return publicClient.readContract({
        abi,
        address,
        account,
        functionName,
        args,
        blockNumber,
        blockTag
    });
}
;
async function readContracts({ contracts, blockNumber, blockTag, ...args }) {
    const { allowFailure = true } = args;
    try {
        const publicClient = getPublicClient();
        const contractsByChainId = contracts.reduce((contracts2, contract, index)=>{
            const chainId = contract.chainId ?? publicClient.chain.id;
            return {
                ...contracts2,
                [chainId]: [
                    ...contracts2[chainId] || [],
                    {
                        contract,
                        index
                    }
                ]
            };
        }, {});
        const promises = ()=>Object.entries(contractsByChainId).map(([chainId, contracts2])=>multicall({
                    allowFailure,
                    chainId: parseInt(chainId),
                    contracts: contracts2.map(({ contract })=>contract),
                    blockNumber,
                    blockTag
                }));
        const multicallResults = (await Promise.all(promises())).flat();
        const resultIndexes = Object.values(contractsByChainId).flatMap((contracts2)=>contracts2.map(({ index })=>index));
        return multicallResults.reduce((results, result, index)=>{
            if (results) results[resultIndexes[index]] = result;
            return results;
        }, []);
    } catch (err) {
        if (err instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$contract$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ContractFunctionExecutionError"]) throw err;
        const promises = ()=>contracts.map((contract)=>readContract({
                    ...contract,
                    blockNumber,
                    blockTag
                }));
        if (allowFailure) return (await Promise.allSettled(promises())).map((result)=>{
            if (result.status === "fulfilled") return {
                result: result.value,
                status: "success"
            };
            return {
                error: result.reason,
                result: void 0,
                status: "failure"
            };
        });
        return await Promise.all(promises());
    }
}
;
function watchContractEvent({ address, abi, chainId, eventName }, callback) {
    let unwatch;
    const watchEvent = async ()=>{
        if (unwatch) unwatch();
        const publicClient = getWebSocketPublicClient({
            chainId
        }) || getPublicClient({
            chainId
        });
        unwatch = publicClient.watchContractEvent({
            address,
            abi,
            eventName,
            onLogs: callback
        });
    };
    watchEvent();
    const config2 = getConfig();
    const unsubscribe = config2.subscribe(({ publicClient, webSocketPublicClient })=>({
            publicClient,
            webSocketPublicClient
        }), watchEvent, {
        equalityFn: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zustand$2f$esm$2f$shallow$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shallow"]
    });
    return ()=>{
        unwatch?.();
        unsubscribe();
    };
}
;
function watchBlockNumber(args, callback) {
    let unwatch;
    const createListener = (publicClient)=>{
        if (unwatch) unwatch();
        unwatch = publicClient.watchBlockNumber({
            onBlockNumber: callback,
            emitOnBegin: true,
            poll: true
        });
    };
    const publicClient_ = getWebSocketPublicClient({
        chainId: args.chainId
    }) ?? getPublicClient({
        chainId: args.chainId
    });
    if (args.listen) createListener(publicClient_);
    const config2 = getConfig();
    const unsubscribe = config2.subscribe(({ publicClient, webSocketPublicClient })=>({
            publicClient,
            webSocketPublicClient
        }), async ({ publicClient, webSocketPublicClient })=>{
        const publicClient_2 = webSocketPublicClient ?? publicClient;
        if (args.listen && !args.chainId && publicClient_2) {
            createListener(publicClient_2);
        }
    }, {
        equalityFn: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zustand$2f$esm$2f$shallow$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shallow"]
    });
    return ()=>{
        unsubscribe();
        unwatch?.();
    };
}
// src/actions/contracts/watchMulticall.ts
function watchMulticall(args, callback) {
    const config2 = getConfig();
    const handleChange = async ()=>callback(await multicall(args));
    const unwatch = args.listenToBlock ? watchBlockNumber({
        listen: true
    }, handleChange) : void 0;
    const unsubscribe = config2.subscribe(({ publicClient })=>publicClient, handleChange);
    return ()=>{
        unsubscribe();
        unwatch?.();
    };
}
// src/actions/contracts/watchReadContract.ts
function watchReadContract(args, callback) {
    const config2 = getConfig();
    const handleChange = async ()=>callback(await readContract(args));
    const unwatch = args.listenToBlock ? watchBlockNumber({
        listen: true
    }, handleChange) : void 0;
    const unsubscribe = config2.subscribe(({ publicClient })=>publicClient, handleChange);
    return ()=>{
        unsubscribe();
        unwatch?.();
    };
}
// src/actions/contracts/watchReadContracts.ts
function watchReadContracts(args, callback) {
    const config2 = getConfig();
    const handleChange = async ()=>callback(await readContracts(args));
    const unwatch = args.listenToBlock ? watchBlockNumber({
        listen: true
    }, handleChange) : void 0;
    const unsubscribe = config2.subscribe(({ publicClient })=>publicClient, handleChange);
    return ()=>{
        unsubscribe();
        unwatch?.();
    };
}
// src/actions/contracts/writeContract.ts
async function writeContract(config2) {
    const walletClient = await getWalletClient({
        chainId: config2.chainId
    });
    if (!walletClient) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$connectors$2f$dist$2f$chunk$2d$UGBGYVBH$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ConnectorNotFoundError"]();
    if (config2.chainId) assertActiveChain({
        chainId: config2.chainId
    });
    let request;
    if (config2.mode === "prepared") {
        request = config2.request;
    } else {
        const { chainId: _, mode: __, ...args } = config2;
        const res = await prepareWriteContract(args);
        request = res.request;
    }
    const hash = await walletClient.writeContract({
        ...request,
        chain: config2.chainId ? {
            id: config2.chainId
        } : null
    });
    return {
        hash
    };
}
// src/actions/accounts/fetchBalance.ts
async function fetchBalance({ address, chainId, formatUnits: unit, token }) {
    const config2 = getConfig();
    const publicClient = getPublicClient({
        chainId
    });
    if (token) {
        const fetchContractBalance = async ({ abi })=>{
            const erc20Config = {
                abi,
                address: token,
                chainId
            };
            const [value2, decimals, symbol] = await readContracts({
                allowFailure: false,
                contracts: [
                    {
                        ...erc20Config,
                        functionName: "balanceOf",
                        args: [
                            address
                        ]
                    },
                    {
                        ...erc20Config,
                        functionName: "decimals"
                    },
                    {
                        ...erc20Config,
                        functionName: "symbol"
                    }
                ]
            });
            return {
                decimals,
                formatted: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$unit$2f$formatUnits$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["formatUnits"])(value2 ?? "0", getUnit(unit ?? decimals)),
                symbol,
                value: value2
            };
        };
        try {
            return await fetchContractBalance({
                abi: erc20ABI
            });
        } catch (err) {
            if (err instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$contract$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ContractFunctionExecutionError"]) {
                const { symbol, ...rest } = await fetchContractBalance({
                    abi: erc20ABI_bytes32
                });
                return {
                    symbol: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$fromHex$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hexToString"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$trim$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["trim"])(symbol, {
                        dir: "right"
                    })),
                    ...rest
                };
            }
            throw err;
        }
    }
    const chains = [
        ...config2.publicClient.chains || [],
        ...config2.chains ?? []
    ];
    const value = await publicClient.getBalance({
        address
    });
    const chain = chains.find((x)=>x.id === publicClient.chain.id);
    return {
        decimals: chain?.nativeCurrency.decimals ?? 18,
        formatted: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$unit$2f$formatUnits$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["formatUnits"])(value ?? "0", getUnit(unit ?? 18)),
        symbol: chain?.nativeCurrency.symbol ?? "ETH",
        value
    };
}
// src/actions/accounts/getAccount.ts
function getAccount() {
    const { data, connector, status } = getConfig();
    switch(status){
        case "connected":
            return {
                address: data?.account,
                connector,
                isConnected: true,
                isConnecting: false,
                isDisconnected: false,
                isReconnecting: false,
                status
            };
        case "reconnecting":
            return {
                address: data?.account,
                connector,
                isConnected: !!data?.account,
                isConnecting: false,
                isDisconnected: false,
                isReconnecting: true,
                status
            };
        case "connecting":
            return {
                address: data?.account,
                connector,
                isConnected: false,
                isConnecting: true,
                isDisconnected: false,
                isReconnecting: false,
                status
            };
        case "disconnected":
            return {
                address: void 0,
                connector: void 0,
                isConnected: false,
                isConnecting: false,
                isDisconnected: true,
                isReconnecting: false,
                status
            };
    }
}
// src/actions/accounts/getNetwork.ts
function getNetwork() {
    const config2 = getConfig();
    const chainId = config2.data?.chain?.id;
    const activeChains = config2.chains ?? [];
    const activeChain = [
        ...config2.publicClient?.chains || [],
        ...activeChains
    ].find((x)=>x.id === chainId) ?? {
        id: chainId,
        name: `Chain ${chainId}`,
        network: `${chainId}`,
        nativeCurrency: {
            name: "Ether",
            decimals: 18,
            symbol: "ETH"
        },
        rpcUrls: {
            default: {
                http: [
                    ""
                ]
            },
            public: {
                http: [
                    ""
                ]
            }
        }
    };
    return {
        chain: chainId ? {
            ...activeChain,
            ...config2.data?.chain,
            id: chainId
        } : void 0,
        chains: activeChains
    };
}
// src/actions/accounts/signMessage.ts
async function signMessage(args) {
    const walletClient = await getWalletClient();
    if (!walletClient) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$connectors$2f$dist$2f$chunk$2d$UGBGYVBH$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ConnectorNotFoundError"]();
    return await walletClient.signMessage({
        message: args.message
    });
}
// src/actions/accounts/signTypedData.ts
async function signTypedData({ domain, message, primaryType, types }) {
    const walletClient = await getWalletClient();
    if (!walletClient) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$connectors$2f$dist$2f$chunk$2d$UGBGYVBH$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ConnectorNotFoundError"]();
    const { chainId } = domain;
    if (chainId) assertActiveChain({
        chainId
    });
    return walletClient.signTypedData({
        message,
        primaryType,
        types,
        domain
    });
}
// src/actions/accounts/switchNetwork.ts
async function switchNetwork({ chainId }) {
    const { connector } = getConfig();
    if (!connector) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$connectors$2f$dist$2f$chunk$2d$UGBGYVBH$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ConnectorNotFoundError"]();
    if (!connector.switchChain) throw new SwitchChainNotSupportedError({
        connector
    });
    return connector.switchChain(chainId);
}
;
function watchAccount(callback, { selector = (x)=>x } = {}) {
    const config2 = getConfig();
    const handleChange = ()=>callback(getAccount());
    const unsubscribe = config2.subscribe(({ data, connector, status })=>selector({
            address: data?.account,
            connector,
            status
        }), handleChange, {
        equalityFn: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zustand$2f$esm$2f$shallow$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shallow"]
    });
    return unsubscribe;
}
;
function watchNetwork(callback, { selector = (x)=>x } = {}) {
    const config2 = getConfig();
    const handleChange = ()=>callback(getNetwork());
    const unsubscribe = config2.subscribe(({ data, chains })=>selector({
            chainId: data?.chain?.id,
            chains
        }), handleChange, {
        equalityFn: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zustand$2f$esm$2f$shallow$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shallow"]
    });
    return unsubscribe;
}
;
async function fetchEnsAddress({ chainId, name }) {
    const { normalize } = await __turbopack_context__.A("[project]/node_modules/viem/_esm/ens/index.js [app-client] (ecmascript, async loader)");
    const publicClient = getPublicClient({
        chainId
    });
    const address = await publicClient.getEnsAddress({
        name: normalize(name)
    });
    try {
        if (address === "0x0000000000000000000000000000000000000000") return null;
        return address ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$address$2f$getAddress$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getAddress"])(address) : null;
    } catch (_error) {
        return null;
    }
}
// src/actions/ens/fetchEnsAvatar.ts
async function fetchEnsAvatar({ name, chainId }) {
    const { normalize } = await __turbopack_context__.A("[project]/node_modules/viem/_esm/ens/index.js [app-client] (ecmascript, async loader)");
    const publicClient = getPublicClient({
        chainId
    });
    const avatar = await publicClient.getEnsAvatar({
        name: normalize(name)
    });
    return avatar;
}
;
async function fetchEnsName({ address, chainId }) {
    const publicClient = getPublicClient({
        chainId
    });
    return publicClient.getEnsName({
        address: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$address$2f$getAddress$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getAddress"])(address)
    });
}
// src/actions/ens/fetchEnsResolver.ts
async function fetchEnsResolver({ chainId, name }) {
    const { normalize } = await __turbopack_context__.A("[project]/node_modules/viem/_esm/ens/index.js [app-client] (ecmascript, async loader)");
    const publicClient = getPublicClient({
        chainId
    });
    const resolver = await publicClient.getEnsResolver({
        name: normalize(name)
    });
    return resolver;
}
// src/actions/network-status/fetchBlockNumber.ts
async function fetchBlockNumber({ chainId } = {}) {
    const publicClient = getPublicClient({
        chainId
    });
    const blockNumber = await publicClient.getBlockNumber();
    return blockNumber;
}
;
async function fetchFeeData({ chainId, formatUnits: units = "gwei" } = {}) {
    const publicClient = getPublicClient({
        chainId
    });
    const block = await publicClient.getBlock();
    let gasPrice = null;
    try {
        gasPrice = await publicClient.getGasPrice();
    } catch  {}
    let lastBaseFeePerGas = null;
    let maxFeePerGas = null;
    let maxPriorityFeePerGas = null;
    if (block?.baseFeePerGas) {
        lastBaseFeePerGas = block.baseFeePerGas;
        maxPriorityFeePerGas = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$unit$2f$parseGwei$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parseGwei"])("1");
        maxFeePerGas = block.baseFeePerGas * 2n + maxPriorityFeePerGas;
    }
    const unit = getUnit(units);
    const formatted = {
        gasPrice: gasPrice ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$unit$2f$formatUnits$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["formatUnits"])(gasPrice, unit) : null,
        maxFeePerGas: maxFeePerGas ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$unit$2f$formatUnits$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["formatUnits"])(maxFeePerGas, unit) : null,
        maxPriorityFeePerGas: maxPriorityFeePerGas ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$unit$2f$formatUnits$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["formatUnits"])(maxPriorityFeePerGas, unit) : null
    };
    return {
        lastBaseFeePerGas,
        gasPrice,
        maxFeePerGas,
        maxPriorityFeePerGas,
        formatted
    };
}
// src/actions/transactions/fetchTransaction.ts
async function fetchTransaction({ chainId, hash }) {
    const publicClient = getPublicClient({
        chainId
    });
    return publicClient.getTransaction({
        hash
    });
}
;
async function prepareSendTransaction({ accessList, account, chainId, data, gas: gas_, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to: to_, value, walletClient: walletClient_ }) {
    const publicClient = getPublicClient({
        chainId
    });
    const walletClient = walletClient_ ?? await getWalletClient({
        chainId
    });
    if (!walletClient) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$connectors$2f$dist$2f$chunk$2d$UGBGYVBH$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ConnectorNotFoundError"]();
    if (chainId) assertActiveChain({
        chainId
    });
    const to = (to_ && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$address$2f$isAddress$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isAddress"])(to_) ? await fetchEnsAddress({
        name: to_
    }) : to_) || void 0;
    if (to && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$address$2f$isAddress$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isAddress"])(to)) throw new Error("Invalid address");
    const gas = typeof gas_ === "undefined" ? await publicClient.estimateGas({
        accessList,
        account: walletClient.account,
        data,
        gas: gas_ ?? void 0,
        gasPrice,
        maxFeePerGas,
        maxPriorityFeePerGas,
        nonce,
        to,
        value
    }) : gas_ || void 0;
    return {
        accessList,
        account,
        data,
        gas,
        gasPrice,
        maxFeePerGas,
        maxPriorityFeePerGas,
        mode: "prepared",
        nonce,
        to,
        value,
        ...chainId ? {
            chainId
        } : {}
    };
}
// src/actions/transactions/sendTransaction.ts
async function sendTransaction({ accessList, account, chainId, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, mode, nonce, to, value }) {
    const walletClient = await getWalletClient({
        chainId
    });
    if (!walletClient) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$connectors$2f$dist$2f$chunk$2d$UGBGYVBH$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ConnectorNotFoundError"]();
    if (chainId) assertActiveChain({
        chainId
    });
    let args;
    if (mode === "prepared") {
        args = {
            account,
            accessList,
            chain: null,
            data,
            gas,
            gasPrice,
            maxFeePerGas,
            maxPriorityFeePerGas,
            nonce,
            to,
            value
        };
    } else {
        args = await prepareSendTransaction({
            accessList,
            account,
            chainId,
            data,
            gas: gas || null,
            gasPrice,
            maxFeePerGas,
            maxPriorityFeePerGas,
            nonce,
            to,
            value
        });
    }
    const hash = await walletClient.sendTransaction({
        ...args,
        chain: chainId ? {
            id: chainId
        } : null
    });
    return {
        hash
    };
}
;
async function waitForTransaction({ chainId, confirmations = 1, hash, onReplaced, timeout = 0 }) {
    const publicClient = getPublicClient({
        chainId
    });
    const receipt = await publicClient.waitForTransactionReceipt({
        hash,
        confirmations,
        onReplaced,
        timeout
    });
    if (receipt.status === "reverted") {
        const txn = await publicClient.getTransaction({
            hash: receipt.transactionHash
        });
        const code = await publicClient.call({
            ...txn,
            gasPrice: txn.type !== "eip1559" ? txn.gasPrice : void 0,
            maxFeePerGas: txn.type === "eip1559" ? txn.maxFeePerGas : void 0,
            maxPriorityFeePerGas: txn.type === "eip1559" ? txn.maxPriorityFeePerGas : void 0
        });
        const reason = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$encoding$2f$fromHex$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hexToString"])(`0x${code.substring(138)}`);
        throw new Error(reason);
    }
    return receipt;
}
;
function watchPendingTransactions(args, callback) {
    let unwatch;
    const createListener = (publicClient)=>{
        if (unwatch) unwatch();
        unwatch = publicClient.watchPendingTransactions({
            onTransactions: callback,
            poll: true
        });
    };
    const publicClient_ = getWebSocketPublicClient({
        chainId: args.chainId
    }) ?? getPublicClient({
        chainId: args.chainId
    });
    createListener(publicClient_);
    const config2 = getConfig();
    const unsubscribe = config2.subscribe(({ publicClient, webSocketPublicClient })=>({
            publicClient,
            webSocketPublicClient
        }), async ({ publicClient, webSocketPublicClient })=>{
        const publicClient_2 = webSocketPublicClient ?? publicClient;
        if (!args.chainId && publicClient_2) {
            createListener(publicClient_2);
        }
    }, {
        equalityFn: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zustand$2f$esm$2f$shallow$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shallow"]
    });
    return ()=>{
        unsubscribe();
        unwatch?.();
    };
}
// src/utils/assertActiveChain.ts
function assertActiveChain({ chainId }) {
    const { chain: activeChain, chains } = getNetwork();
    const activeChainId = activeChain?.id;
    if (activeChainId && chainId !== activeChainId) {
        throw new ChainMismatchError({
            activeChain: chains.find((x)=>x.id === activeChainId)?.name ?? `Chain ${activeChainId}`,
            targetChain: chains.find((x)=>x.id === chainId)?.name ?? `Chain ${chainId}`
        });
    }
}
;
}),
"[project]/node_modules/viem/node_modules/@noble/curves/esm/abstract/utils.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // 100 lines of code in the file are duplicated from noble-hashes (utils).
// This is OK: `abstract` directory does not use noble-hashes.
// User may opt-in into using different hashing library. This way, noble-hashes
// won't be included into their bundle.
__turbopack_context__.s([
    "bitGet",
    ()=>bitGet,
    "bitLen",
    ()=>bitLen,
    "bitMask",
    ()=>bitMask,
    "bitSet",
    ()=>bitSet,
    "bytesToHex",
    ()=>bytesToHex,
    "bytesToNumberBE",
    ()=>bytesToNumberBE,
    "bytesToNumberLE",
    ()=>bytesToNumberLE,
    "concatBytes",
    ()=>concatBytes,
    "createHmacDrbg",
    ()=>createHmacDrbg,
    "ensureBytes",
    ()=>ensureBytes,
    "equalBytes",
    ()=>equalBytes,
    "hexToBytes",
    ()=>hexToBytes,
    "hexToNumber",
    ()=>hexToNumber,
    "numberToBytesBE",
    ()=>numberToBytesBE,
    "numberToBytesLE",
    ()=>numberToBytesLE,
    "numberToHexUnpadded",
    ()=>numberToHexUnpadded,
    "numberToVarBytesBE",
    ()=>numberToVarBytesBE,
    "utf8ToBytes",
    ()=>utf8ToBytes,
    "validateObject",
    ()=>validateObject
]);
const _0n = BigInt(0);
const _1n = BigInt(1);
const _2n = BigInt(2);
const u8a = (a)=>a instanceof Uint8Array;
const hexes = /* @__PURE__ */ Array.from({
    length: 256
}, (_, i)=>i.toString(16).padStart(2, '0'));
function bytesToHex(bytes) {
    if (!u8a(bytes)) throw new Error('Uint8Array expected');
    // pre-caching improves the speed 6x
    let hex = '';
    for(let i = 0; i < bytes.length; i++){
        hex += hexes[bytes[i]];
    }
    return hex;
}
function numberToHexUnpadded(num) {
    const hex = num.toString(16);
    return hex.length & 1 ? `0${hex}` : hex;
}
function hexToNumber(hex) {
    if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);
    // Big Endian
    return BigInt(hex === '' ? '0' : `0x${hex}`);
}
function hexToBytes(hex) {
    if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);
    const len = hex.length;
    if (len % 2) throw new Error('padded hex string expected, got unpadded hex of length ' + len);
    const array = new Uint8Array(len / 2);
    for(let i = 0; i < array.length; i++){
        const j = i * 2;
        const hexByte = hex.slice(j, j + 2);
        const byte = Number.parseInt(hexByte, 16);
        if (Number.isNaN(byte) || byte < 0) throw new Error('Invalid byte sequence');
        array[i] = byte;
    }
    return array;
}
function bytesToNumberBE(bytes) {
    return hexToNumber(bytesToHex(bytes));
}
function bytesToNumberLE(bytes) {
    if (!u8a(bytes)) throw new Error('Uint8Array expected');
    return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));
}
function numberToBytesBE(n, len) {
    return hexToBytes(n.toString(16).padStart(len * 2, '0'));
}
function numberToBytesLE(n, len) {
    return numberToBytesBE(n, len).reverse();
}
function numberToVarBytesBE(n) {
    return hexToBytes(numberToHexUnpadded(n));
}
function ensureBytes(title, hex, expectedLength) {
    let res;
    if (typeof hex === 'string') {
        try {
            res = hexToBytes(hex);
        } catch (e) {
            throw new Error(`${title} must be valid hex string, got "${hex}". Cause: ${e}`);
        }
    } else if (u8a(hex)) {
        // Uint8Array.from() instead of hash.slice() because node.js Buffer
        // is instance of Uint8Array, and its slice() creates **mutable** copy
        res = Uint8Array.from(hex);
    } else {
        throw new Error(`${title} must be hex string or Uint8Array`);
    }
    const len = res.length;
    if (typeof expectedLength === 'number' && len !== expectedLength) throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);
    return res;
}
function concatBytes(...arrays) {
    const r = new Uint8Array(arrays.reduce((sum, a)=>sum + a.length, 0));
    let pad = 0; // walk through each item, ensure they have proper type
    arrays.forEach((a)=>{
        if (!u8a(a)) throw new Error('Uint8Array expected');
        r.set(a, pad);
        pad += a.length;
    });
    return r;
}
function equalBytes(b1, b2) {
    // We don't care about timing attacks here
    if (b1.length !== b2.length) return false;
    for(let i = 0; i < b1.length; i++)if (b1[i] !== b2[i]) return false;
    return true;
}
function utf8ToBytes(str) {
    if (typeof str !== 'string') throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809
}
function bitLen(n) {
    let len;
    for(len = 0; n > _0n; n >>= _1n, len += 1);
    return len;
}
function bitGet(n, pos) {
    return n >> BigInt(pos) & _1n;
}
const bitSet = (n, pos, value)=>{
    return n | (value ? _1n : _0n) << BigInt(pos);
};
const bitMask = (n)=>(_2n << BigInt(n - 1)) - _1n;
// DRBG
const u8n = (data)=>new Uint8Array(data); // creates Uint8Array
const u8fr = (arr)=>Uint8Array.from(arr); // another shortcut
function createHmacDrbg(hashLen, qByteLen, hmacFn) {
    if (typeof hashLen !== 'number' || hashLen < 2) throw new Error('hashLen must be a number');
    if (typeof qByteLen !== 'number' || qByteLen < 2) throw new Error('qByteLen must be a number');
    if (typeof hmacFn !== 'function') throw new Error('hmacFn must be a function');
    // Step B, Step C: set hashLen to 8*ceil(hlen/8)
    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.
    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same
    let i = 0; // Iterations counter, will throw when over 1000
    const reset = ()=>{
        v.fill(1);
        k.fill(0);
        i = 0;
    };
    const h = (...b)=>hmacFn(k, v, ...b); // hmac(k)(v, ...values)
    const reseed = (seed = u8n())=>{
        // HMAC-DRBG reseed() function. Steps D-G
        k = h(u8fr([
            0x00
        ]), seed); // k = hmac(k || v || 0x00 || seed)
        v = h(); // v = hmac(k || v)
        if (seed.length === 0) return;
        k = h(u8fr([
            0x01
        ]), seed); // k = hmac(k || v || 0x01 || seed)
        v = h(); // v = hmac(k || v)
    };
    const gen = ()=>{
        // HMAC-DRBG generate() function
        if (i++ >= 1000) throw new Error('drbg: tried 1000 values');
        let len = 0;
        const out = [];
        while(len < qByteLen){
            v = h();
            const sl = v.slice();
            out.push(sl);
            len += v.length;
        }
        return concatBytes(...out);
    };
    const genUntil = (seed, pred)=>{
        reset();
        reseed(seed); // Steps D-G
        let res = undefined; // Step H: grind until k is in [1..n-1]
        while(!(res = pred(gen())))reseed();
        reset();
        return res;
    };
    return genUntil;
}
// Validating curves and fields
const validatorFns = {
    bigint: (val)=>typeof val === 'bigint',
    function: (val)=>typeof val === 'function',
    boolean: (val)=>typeof val === 'boolean',
    string: (val)=>typeof val === 'string',
    stringOrUint8Array: (val)=>typeof val === 'string' || val instanceof Uint8Array,
    isSafeInteger: (val)=>Number.isSafeInteger(val),
    array: (val)=>Array.isArray(val),
    field: (val, object)=>object.Fp.isValid(val),
    hash: (val)=>typeof val === 'function' && Number.isSafeInteger(val.outputLen)
};
function validateObject(object, validators, optValidators = {}) {
    const checkField = (fieldName, type, isOptional)=>{
        const checkVal = validatorFns[type];
        if (typeof checkVal !== 'function') throw new Error(`Invalid validator "${type}", expected function`);
        const val = object[fieldName];
        if (isOptional && val === undefined) return;
        if (!checkVal(val, object)) {
            throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);
        }
    };
    for (const [fieldName, type] of Object.entries(validators))checkField(fieldName, type, false);
    for (const [fieldName, type] of Object.entries(optValidators))checkField(fieldName, type, true);
    return object;
} // validate type tests
 // const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };
 // const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!
 // // Should fail type-check
 // const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });
 // const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });
 // const z3 = validateObject(o, { test: 'boolean', z: 'bug' });
 // const z4 = validateObject(o, { a: 'boolean', z: 'bug' });
 //# sourceMappingURL=utils.js.map
}),
"[project]/node_modules/isows/_esm/utils.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getNativeWebSocket",
    ()=>getNativeWebSocket
]);
function getNativeWebSocket() {
    if (typeof WebSocket !== "undefined") return WebSocket;
    if (typeof /*TURBOPACK member replacement*/ __turbopack_context__.g.WebSocket !== "undefined") return /*TURBOPACK member replacement*/ __turbopack_context__.g.WebSocket;
    if (typeof window.WebSocket !== "undefined") return window.WebSocket;
    if (typeof self.WebSocket !== "undefined") return self.WebSocket;
    throw new Error("`WebSocket` is not supported in this environment");
} //# sourceMappingURL=utils.js.map
}),
"[project]/node_modules/isows/_esm/native.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "WebSocket",
    ()=>WebSocket
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$isows$2f$_esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/isows/_esm/utils.js [app-client] (ecmascript)");
;
const WebSocket = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$isows$2f$_esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getNativeWebSocket"])(); //# sourceMappingURL=native.js.map
}),
"[project]/node_modules/zustand/esm/middleware.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "combine",
    ()=>combine,
    "createJSONStorage",
    ()=>createJSONStorage,
    "devtools",
    ()=>devtools,
    "persist",
    ()=>persist,
    "redux",
    ()=>redux,
    "subscribeWithSelector",
    ()=>subscribeWithSelector
]);
const __TURBOPACK__import$2e$meta__ = {
    get url () {
        return `file://${__turbopack_context__.P("node_modules/zustand/esm/middleware.mjs")}`;
    }
};
const reduxImpl = (reducer, initial)=>(set, _get, api)=>{
        api.dispatch = (action)=>{
            set((state)=>reducer(state, action), false, action);
            return action;
        };
        api.dispatchFromDevtools = true;
        return {
            dispatch: (...a)=>api.dispatch(...a),
            ...initial
        };
    };
const redux = reduxImpl;
const trackedConnections = /* @__PURE__ */ new Map();
const getTrackedConnectionState = (name)=>{
    const api = trackedConnections.get(name);
    if (!api) return {};
    return Object.fromEntries(Object.entries(api.stores).map(([key, api2])=>[
            key,
            api2.getState()
        ]));
};
const extractConnectionInformation = (store, extensionConnector, options)=>{
    if (store === void 0) {
        return {
            type: "untracked",
            connection: extensionConnector.connect(options)
        };
    }
    const existingConnection = trackedConnections.get(options.name);
    if (existingConnection) {
        return {
            type: "tracked",
            store,
            ...existingConnection
        };
    }
    const newConnection = {
        connection: extensionConnector.connect(options),
        stores: {}
    };
    trackedConnections.set(options.name, newConnection);
    return {
        type: "tracked",
        store,
        ...newConnection
    };
};
const devtoolsImpl = (fn, devtoolsOptions = {})=>(set, get, api)=>{
        const { enabled, anonymousActionType, store, ...options } = devtoolsOptions;
        let extensionConnector;
        try {
            extensionConnector = (enabled != null ? enabled : (__TURBOPACK__import$2e$meta__.env ? __TURBOPACK__import$2e$meta__.env.MODE : void 0) !== "production") && window.__REDUX_DEVTOOLS_EXTENSION__;
        } catch (_e) {}
        if (!extensionConnector) {
            if ((__TURBOPACK__import$2e$meta__.env ? __TURBOPACK__import$2e$meta__.env.MODE : void 0) !== "production" && enabled) {
                console.warn("[zustand devtools middleware] Please install/enable Redux devtools extension");
            }
            return fn(set, get, api);
        }
        const { connection, ...connectionInformation } = extractConnectionInformation(store, extensionConnector, options);
        let isRecording = true;
        api.setState = (state, replace, nameOrAction)=>{
            const r = set(state, replace);
            if (!isRecording) return r;
            const action = nameOrAction === void 0 ? {
                type: anonymousActionType || "anonymous"
            } : typeof nameOrAction === "string" ? {
                type: nameOrAction
            } : nameOrAction;
            if (store === void 0) {
                connection == null ? void 0 : connection.send(action, get());
                return r;
            }
            connection == null ? void 0 : connection.send({
                ...action,
                type: `${store}/${action.type}`
            }, {
                ...getTrackedConnectionState(options.name),
                [store]: api.getState()
            });
            return r;
        };
        const setStateFromDevtools = (...a)=>{
            const originalIsRecording = isRecording;
            isRecording = false;
            set(...a);
            isRecording = originalIsRecording;
        };
        const initialState = fn(api.setState, get, api);
        if (connectionInformation.type === "untracked") {
            connection == null ? void 0 : connection.init(initialState);
        } else {
            connectionInformation.stores[connectionInformation.store] = api;
            connection == null ? void 0 : connection.init(Object.fromEntries(Object.entries(connectionInformation.stores).map(([key, store2])=>[
                    key,
                    key === connectionInformation.store ? initialState : store2.getState()
                ])));
        }
        if (api.dispatchFromDevtools && typeof api.dispatch === "function") {
            let didWarnAboutReservedActionType = false;
            const originalDispatch = api.dispatch;
            api.dispatch = (...a)=>{
                if ((__TURBOPACK__import$2e$meta__.env ? __TURBOPACK__import$2e$meta__.env.MODE : void 0) !== "production" && a[0].type === "__setState" && !didWarnAboutReservedActionType) {
                    console.warn('[zustand devtools middleware] "__setState" action type is reserved to set state from the devtools. Avoid using it.');
                    didWarnAboutReservedActionType = true;
                }
                originalDispatch(...a);
            };
        }
        connection.subscribe((message)=>{
            var _a;
            switch(message.type){
                case "ACTION":
                    if (typeof message.payload !== "string") {
                        console.error("[zustand devtools middleware] Unsupported action format");
                        return;
                    }
                    return parseJsonThen(message.payload, (action)=>{
                        if (action.type === "__setState") {
                            if (store === void 0) {
                                setStateFromDevtools(action.state);
                                return;
                            }
                            if (Object.keys(action.state).length !== 1) {
                                console.error(`
                    [zustand devtools middleware] Unsupported __setState action format. 
                    When using 'store' option in devtools(), the 'state' should have only one key, which is a value of 'store' that was passed in devtools(),
                    and value of this only key should be a state object. Example: { "type": "__setState", "state": { "abc123Store": { "foo": "bar" } } }
                    `);
                            }
                            const stateFromDevtools = action.state[store];
                            if (stateFromDevtools === void 0 || stateFromDevtools === null) {
                                return;
                            }
                            if (JSON.stringify(api.getState()) !== JSON.stringify(stateFromDevtools)) {
                                setStateFromDevtools(stateFromDevtools);
                            }
                            return;
                        }
                        if (!api.dispatchFromDevtools) return;
                        if (typeof api.dispatch !== "function") return;
                        api.dispatch(action);
                    });
                case "DISPATCH":
                    switch(message.payload.type){
                        case "RESET":
                            setStateFromDevtools(initialState);
                            if (store === void 0) {
                                return connection == null ? void 0 : connection.init(api.getState());
                            }
                            return connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));
                        case "COMMIT":
                            if (store === void 0) {
                                connection == null ? void 0 : connection.init(api.getState());
                                return;
                            }
                            return connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));
                        case "ROLLBACK":
                            return parseJsonThen(message.state, (state)=>{
                                if (store === void 0) {
                                    setStateFromDevtools(state);
                                    connection == null ? void 0 : connection.init(api.getState());
                                    return;
                                }
                                setStateFromDevtools(state[store]);
                                connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));
                            });
                        case "JUMP_TO_STATE":
                        case "JUMP_TO_ACTION":
                            return parseJsonThen(message.state, (state)=>{
                                if (store === void 0) {
                                    setStateFromDevtools(state);
                                    return;
                                }
                                if (JSON.stringify(api.getState()) !== JSON.stringify(state[store])) {
                                    setStateFromDevtools(state[store]);
                                }
                            });
                        case "IMPORT_STATE":
                            {
                                const { nextLiftedState } = message.payload;
                                const lastComputedState = (_a = nextLiftedState.computedStates.slice(-1)[0]) == null ? void 0 : _a.state;
                                if (!lastComputedState) return;
                                if (store === void 0) {
                                    setStateFromDevtools(lastComputedState);
                                } else {
                                    setStateFromDevtools(lastComputedState[store]);
                                }
                                connection == null ? void 0 : connection.send(null, // FIXME no-any
                                nextLiftedState);
                                return;
                            }
                        case "PAUSE_RECORDING":
                            return isRecording = !isRecording;
                    }
                    return;
            }
        });
        return initialState;
    };
const devtools = devtoolsImpl;
const parseJsonThen = (stringified, f)=>{
    let parsed;
    try {
        parsed = JSON.parse(stringified);
    } catch (e) {
        console.error("[zustand devtools middleware] Could not parse the received json", e);
    }
    if (parsed !== void 0) f(parsed);
};
const subscribeWithSelectorImpl = (fn)=>(set, get, api)=>{
        const origSubscribe = api.subscribe;
        api.subscribe = (selector, optListener, options)=>{
            let listener = selector;
            if (optListener) {
                const equalityFn = (options == null ? void 0 : options.equalityFn) || Object.is;
                let currentSlice = selector(api.getState());
                listener = (state)=>{
                    const nextSlice = selector(state);
                    if (!equalityFn(currentSlice, nextSlice)) {
                        const previousSlice = currentSlice;
                        optListener(currentSlice = nextSlice, previousSlice);
                    }
                };
                if (options == null ? void 0 : options.fireImmediately) {
                    optListener(currentSlice, currentSlice);
                }
            }
            return origSubscribe(listener);
        };
        const initialState = fn(set, get, api);
        return initialState;
    };
const subscribeWithSelector = subscribeWithSelectorImpl;
const combine = (initialState, create)=>(...a)=>Object.assign({}, initialState, create(...a));
function createJSONStorage(getStorage, options) {
    let storage;
    try {
        storage = getStorage();
    } catch (_e) {
        return;
    }
    const persistStorage = {
        getItem: (name)=>{
            var _a;
            const parse = (str2)=>{
                if (str2 === null) {
                    return null;
                }
                return JSON.parse(str2, options == null ? void 0 : options.reviver);
            };
            const str = (_a = storage.getItem(name)) != null ? _a : null;
            if (str instanceof Promise) {
                return str.then(parse);
            }
            return parse(str);
        },
        setItem: (name, newValue)=>storage.setItem(name, JSON.stringify(newValue, options == null ? void 0 : options.replacer)),
        removeItem: (name)=>storage.removeItem(name)
    };
    return persistStorage;
}
const toThenable = (fn)=>(input)=>{
        try {
            const result = fn(input);
            if (result instanceof Promise) {
                return result;
            }
            return {
                then (onFulfilled) {
                    return toThenable(onFulfilled)(result);
                },
                catch (_onRejected) {
                    return this;
                }
            };
        } catch (e) {
            return {
                then (_onFulfilled) {
                    return this;
                },
                catch (onRejected) {
                    return toThenable(onRejected)(e);
                }
            };
        }
    };
const oldImpl = (config, baseOptions)=>(set, get, api)=>{
        let options = {
            getStorage: ()=>localStorage,
            serialize: JSON.stringify,
            deserialize: JSON.parse,
            partialize: (state)=>state,
            version: 0,
            merge: (persistedState, currentState)=>({
                    ...currentState,
                    ...persistedState
                }),
            ...baseOptions
        };
        let hasHydrated = false;
        const hydrationListeners = /* @__PURE__ */ new Set();
        const finishHydrationListeners = /* @__PURE__ */ new Set();
        let storage;
        try {
            storage = options.getStorage();
        } catch (_e) {}
        if (!storage) {
            return config((...args)=>{
                console.warn(`[zustand persist middleware] Unable to update item '${options.name}', the given storage is currently unavailable.`);
                set(...args);
            }, get, api);
        }
        const thenableSerialize = toThenable(options.serialize);
        const setItem = ()=>{
            const state = options.partialize({
                ...get()
            });
            let errorInSync;
            const thenable = thenableSerialize({
                state,
                version: options.version
            }).then((serializedValue)=>storage.setItem(options.name, serializedValue)).catch((e)=>{
                errorInSync = e;
            });
            if (errorInSync) {
                throw errorInSync;
            }
            return thenable;
        };
        const savedSetState = api.setState;
        api.setState = (state, replace)=>{
            savedSetState(state, replace);
            void setItem();
        };
        const configResult = config((...args)=>{
            set(...args);
            void setItem();
        }, get, api);
        let stateFromStorage;
        const hydrate = ()=>{
            var _a;
            if (!storage) return;
            hasHydrated = false;
            hydrationListeners.forEach((cb)=>cb(get()));
            const postRehydrationCallback = ((_a = options.onRehydrateStorage) == null ? void 0 : _a.call(options, get())) || void 0;
            return toThenable(storage.getItem.bind(storage))(options.name).then((storageValue)=>{
                if (storageValue) {
                    return options.deserialize(storageValue);
                }
            }).then((deserializedStorageValue)=>{
                if (deserializedStorageValue) {
                    if (typeof deserializedStorageValue.version === "number" && deserializedStorageValue.version !== options.version) {
                        if (options.migrate) {
                            return options.migrate(deserializedStorageValue.state, deserializedStorageValue.version);
                        }
                        console.error(`State loaded from storage couldn't be migrated since no migrate function was provided`);
                    } else {
                        return deserializedStorageValue.state;
                    }
                }
            }).then((migratedState)=>{
                var _a2;
                stateFromStorage = options.merge(migratedState, (_a2 = get()) != null ? _a2 : configResult);
                set(stateFromStorage, true);
                return setItem();
            }).then(()=>{
                postRehydrationCallback == null ? void 0 : postRehydrationCallback(stateFromStorage, void 0);
                hasHydrated = true;
                finishHydrationListeners.forEach((cb)=>cb(stateFromStorage));
            }).catch((e)=>{
                postRehydrationCallback == null ? void 0 : postRehydrationCallback(void 0, e);
            });
        };
        api.persist = {
            setOptions: (newOptions)=>{
                options = {
                    ...options,
                    ...newOptions
                };
                if (newOptions.getStorage) {
                    storage = newOptions.getStorage();
                }
            },
            clearStorage: ()=>{
                storage == null ? void 0 : storage.removeItem(options.name);
            },
            getOptions: ()=>options,
            rehydrate: ()=>hydrate(),
            hasHydrated: ()=>hasHydrated,
            onHydrate: (cb)=>{
                hydrationListeners.add(cb);
                return ()=>{
                    hydrationListeners.delete(cb);
                };
            },
            onFinishHydration: (cb)=>{
                finishHydrationListeners.add(cb);
                return ()=>{
                    finishHydrationListeners.delete(cb);
                };
            }
        };
        hydrate();
        return stateFromStorage || configResult;
    };
const newImpl = (config, baseOptions)=>(set, get, api)=>{
        let options = {
            storage: createJSONStorage(()=>localStorage),
            partialize: (state)=>state,
            version: 0,
            merge: (persistedState, currentState)=>({
                    ...currentState,
                    ...persistedState
                }),
            ...baseOptions
        };
        let hasHydrated = false;
        const hydrationListeners = /* @__PURE__ */ new Set();
        const finishHydrationListeners = /* @__PURE__ */ new Set();
        let storage = options.storage;
        if (!storage) {
            return config((...args)=>{
                console.warn(`[zustand persist middleware] Unable to update item '${options.name}', the given storage is currently unavailable.`);
                set(...args);
            }, get, api);
        }
        const setItem = ()=>{
            const state = options.partialize({
                ...get()
            });
            return storage.setItem(options.name, {
                state,
                version: options.version
            });
        };
        const savedSetState = api.setState;
        api.setState = (state, replace)=>{
            savedSetState(state, replace);
            void setItem();
        };
        const configResult = config((...args)=>{
            set(...args);
            void setItem();
        }, get, api);
        api.getInitialState = ()=>configResult;
        let stateFromStorage;
        const hydrate = ()=>{
            var _a, _b;
            if (!storage) return;
            hasHydrated = false;
            hydrationListeners.forEach((cb)=>{
                var _a2;
                return cb((_a2 = get()) != null ? _a2 : configResult);
            });
            const postRehydrationCallback = ((_b = options.onRehydrateStorage) == null ? void 0 : _b.call(options, (_a = get()) != null ? _a : configResult)) || void 0;
            return toThenable(storage.getItem.bind(storage))(options.name).then((deserializedStorageValue)=>{
                if (deserializedStorageValue) {
                    if (typeof deserializedStorageValue.version === "number" && deserializedStorageValue.version !== options.version) {
                        if (options.migrate) {
                            return [
                                true,
                                options.migrate(deserializedStorageValue.state, deserializedStorageValue.version)
                            ];
                        }
                        console.error(`State loaded from storage couldn't be migrated since no migrate function was provided`);
                    } else {
                        return [
                            false,
                            deserializedStorageValue.state
                        ];
                    }
                }
                return [
                    false,
                    void 0
                ];
            }).then((migrationResult)=>{
                var _a2;
                const [migrated, migratedState] = migrationResult;
                stateFromStorage = options.merge(migratedState, (_a2 = get()) != null ? _a2 : configResult);
                set(stateFromStorage, true);
                if (migrated) {
                    return setItem();
                }
            }).then(()=>{
                postRehydrationCallback == null ? void 0 : postRehydrationCallback(stateFromStorage, void 0);
                stateFromStorage = get();
                hasHydrated = true;
                finishHydrationListeners.forEach((cb)=>cb(stateFromStorage));
            }).catch((e)=>{
                postRehydrationCallback == null ? void 0 : postRehydrationCallback(void 0, e);
            });
        };
        api.persist = {
            setOptions: (newOptions)=>{
                options = {
                    ...options,
                    ...newOptions
                };
                if (newOptions.storage) {
                    storage = newOptions.storage;
                }
            },
            clearStorage: ()=>{
                storage == null ? void 0 : storage.removeItem(options.name);
            },
            getOptions: ()=>options,
            rehydrate: ()=>hydrate(),
            hasHydrated: ()=>hasHydrated,
            onHydrate: (cb)=>{
                hydrationListeners.add(cb);
                return ()=>{
                    hydrationListeners.delete(cb);
                };
            },
            onFinishHydration: (cb)=>{
                finishHydrationListeners.add(cb);
                return ()=>{
                    finishHydrationListeners.delete(cb);
                };
            }
        };
        if (!options.skipHydration) {
            hydrate();
        }
        return stateFromStorage || configResult;
    };
const persistImpl = (config, baseOptions)=>{
    if ("getStorage" in baseOptions || "serialize" in baseOptions || "deserialize" in baseOptions) {
        if ((__TURBOPACK__import$2e$meta__.env ? __TURBOPACK__import$2e$meta__.env.MODE : void 0) !== "production") {
            console.warn("[DEPRECATED] `getStorage`, `serialize` and `deserialize` options are deprecated. Use `storage` option instead.");
        }
        return oldImpl(config, baseOptions);
    }
    return newImpl(config, baseOptions);
};
const persist = persistImpl;
;
}),
"[project]/node_modules/zustand/esm/vanilla.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "createStore",
    ()=>createStore,
    "default",
    ()=>vanilla
]);
const __TURBOPACK__import$2e$meta__ = {
    get url () {
        return `file://${__turbopack_context__.P("node_modules/zustand/esm/vanilla.mjs")}`;
    }
};
const createStoreImpl = (createState)=>{
    let state;
    const listeners = /* @__PURE__ */ new Set();
    const setState = (partial, replace)=>{
        const nextState = typeof partial === "function" ? partial(state) : partial;
        if (!Object.is(nextState, state)) {
            const previousState = state;
            state = (replace != null ? replace : typeof nextState !== "object" || nextState === null) ? nextState : Object.assign({}, state, nextState);
            listeners.forEach((listener)=>listener(state, previousState));
        }
    };
    const getState = ()=>state;
    const getInitialState = ()=>initialState;
    const subscribe = (listener)=>{
        listeners.add(listener);
        return ()=>listeners.delete(listener);
    };
    const destroy = ()=>{
        if ((__TURBOPACK__import$2e$meta__.env ? __TURBOPACK__import$2e$meta__.env.MODE : void 0) !== "production") {
            console.warn("[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected.");
        }
        listeners.clear();
    };
    const api = {
        setState,
        getState,
        getInitialState,
        subscribe,
        destroy
    };
    const initialState = state = createState(setState, getState, api);
    return api;
};
const createStore = (createState)=>createState ? createStoreImpl(createState) : createStoreImpl;
var vanilla = (createState)=>{
    if ((__TURBOPACK__import$2e$meta__.env ? __TURBOPACK__import$2e$meta__.env.MODE : void 0) !== "production") {
        console.warn("[DEPRECATED] Default export is deprecated. Instead use import { createStore } from 'zustand/vanilla'.");
    }
    return createStore(createState);
};
;
}),
"[project]/node_modules/zustand/esm/shallow.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>shallow,
    "shallow",
    ()=>shallow$1
]);
const __TURBOPACK__import$2e$meta__ = {
    get url () {
        return `file://${__turbopack_context__.P("node_modules/zustand/esm/shallow.mjs")}`;
    }
};
function shallow$1(objA, objB) {
    if (Object.is(objA, objB)) {
        return true;
    }
    if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
        return false;
    }
    if (objA instanceof Map && objB instanceof Map) {
        if (objA.size !== objB.size) return false;
        for (const [key, value] of objA){
            if (!Object.is(value, objB.get(key))) {
                return false;
            }
        }
        return true;
    }
    if (objA instanceof Set && objB instanceof Set) {
        if (objA.size !== objB.size) return false;
        for (const value of objA){
            if (!objB.has(value)) {
                return false;
            }
        }
        return true;
    }
    const keysA = Object.keys(objA);
    if (keysA.length !== Object.keys(objB).length) {
        return false;
    }
    for (const keyA of keysA){
        if (!Object.prototype.hasOwnProperty.call(objB, keyA) || !Object.is(objA[keyA], objB[keyA])) {
            return false;
        }
    }
    return true;
}
var shallow = (objA, objB)=>{
    if ((__TURBOPACK__import$2e$meta__.env ? __TURBOPACK__import$2e$meta__.env.MODE : void 0) !== "production") {
        console.warn("[DEPRECATED] Default export is deprecated. Instead use `import { shallow } from 'zustand/shallow'`.");
    }
    return shallow$1(objA, objB);
};
;
}),
"[project]/node_modules/wagmi/node_modules/@tanstack/react-query/build/lib/QueryClientProvider.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "QueryClientProvider",
    ()=>QueryClientProvider,
    "defaultContext",
    ()=>defaultContext,
    "useQueryClient",
    ()=>useQueryClient
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
'use client';
;
const defaultContext = /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createContext"](undefined);
const QueryClientSharingContext = /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createContext"](false); // If we are given a context, we will use it.
// Otherwise, if contextSharing is on, we share the first and at least one
// instance of the context across the window
// to ensure that if React Query is used across
// different bundles or microfrontends they will
// all use the same **instance** of context, regardless
// of module scoping.
function getQueryClientContext(context, contextSharing) {
    if (context) {
        return context;
    }
    if (contextSharing && typeof window !== 'undefined') {
        if (!window.ReactQueryClientContext) {
            window.ReactQueryClientContext = defaultContext;
        }
        return window.ReactQueryClientContext;
    }
    return defaultContext;
}
const useQueryClient = ({ context } = {})=>{
    const queryClient = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useContext"](getQueryClientContext(context, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useContext"](QueryClientSharingContext)));
    if (!queryClient) {
        throw new Error('No QueryClient set, use QueryClientProvider to set one');
    }
    return queryClient;
};
const QueryClientProvider = ({ client, children, context, contextSharing = false })=>{
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"]({
        "QueryClientProvider.useEffect": ()=>{
            client.mount();
            return ({
                "QueryClientProvider.useEffect": ()=>{
                    client.unmount();
                }
            })["QueryClientProvider.useEffect"];
        }
    }["QueryClientProvider.useEffect"], [
        client
    ]);
    if (("TURBOPACK compile-time value", "development") !== 'production' && contextSharing) {
        client.getLogger().error("The contextSharing option has been deprecated and will be removed in the next major version");
    }
    const Context = getQueryClientContext(context, contextSharing);
    return /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"](QueryClientSharingContext.Provider, {
        value: !context && contextSharing
    }, /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"](Context.Provider, {
        value: client
    }, children));
};
;
 //# sourceMappingURL=QueryClientProvider.mjs.map
}),
"[project]/node_modules/wagmi/node_modules/@tanstack/react-query/build/lib/isRestoring.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "IsRestoringProvider",
    ()=>IsRestoringProvider,
    "useIsRestoring",
    ()=>useIsRestoring
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
'use client';
;
const IsRestoringContext = /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createContext"](false);
const useIsRestoring = ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useContext"](IsRestoringContext);
const IsRestoringProvider = IsRestoringContext.Provider;
;
 //# sourceMappingURL=isRestoring.mjs.map
}),
"[project]/node_modules/wagmi/node_modules/@tanstack/react-query/build/lib/QueryErrorResetBoundary.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "QueryErrorResetBoundary",
    ()=>QueryErrorResetBoundary,
    "useQueryErrorResetBoundary",
    ()=>useQueryErrorResetBoundary
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
'use client';
;
function createValue() {
    let isReset = false;
    return {
        clearReset: ()=>{
            isReset = false;
        },
        reset: ()=>{
            isReset = true;
        },
        isReset: ()=>{
            return isReset;
        }
    };
}
const QueryErrorResetBoundaryContext = /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createContext"](createValue()); // HOOK
const useQueryErrorResetBoundary = ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useContext"](QueryErrorResetBoundaryContext); // COMPONENT
const QueryErrorResetBoundary = ({ children })=>{
    const [value] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"]({
        "QueryErrorResetBoundary.useState": ()=>createValue()
    }["QueryErrorResetBoundary.useState"]);
    return /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"](QueryErrorResetBoundaryContext.Provider, {
        value: value
    }, typeof children === 'function' ? children(value) : children);
};
;
 //# sourceMappingURL=QueryErrorResetBoundary.mjs.map
}),
"[project]/node_modules/wagmi/node_modules/@tanstack/react-query/build/lib/useSyncExternalStore.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "useSyncExternalStore",
    ()=>useSyncExternalStore
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$use$2d$sync$2d$external$2d$store$2f$shim$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/use-sync-external-store/shim/index.js [app-client] (ecmascript)");
'use client';
;
const useSyncExternalStore = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$use$2d$sync$2d$external$2d$store$2f$shim$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useSyncExternalStore"];
;
 //# sourceMappingURL=useSyncExternalStore.mjs.map
}),
"[project]/node_modules/wagmi/node_modules/@tanstack/react-query/build/lib/utils.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "shouldThrowError",
    ()=>shouldThrowError
]);
function shouldThrowError(_useErrorBoundary, params) {
    // Allow useErrorBoundary function to override throwing behavior on a per-error basis
    if (typeof _useErrorBoundary === 'function') {
        return _useErrorBoundary(...params);
    }
    return !!_useErrorBoundary;
}
;
 //# sourceMappingURL=utils.mjs.map
}),
"[project]/node_modules/wagmi/node_modules/@tanstack/react-query/build/lib/useMutation.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "useMutation",
    ()=>useMutation
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$wagmi$2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$lib$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/wagmi/node_modules/@tanstack/query-core/build/lib/utils.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$wagmi$2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$lib$2f$mutationObserver$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/wagmi/node_modules/@tanstack/query-core/build/lib/mutationObserver.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$wagmi$2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$lib$2f$notifyManager$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/wagmi/node_modules/@tanstack/query-core/build/lib/notifyManager.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$wagmi$2f$node_modules$2f40$tanstack$2f$react$2d$query$2f$build$2f$lib$2f$useSyncExternalStore$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/wagmi/node_modules/@tanstack/react-query/build/lib/useSyncExternalStore.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$wagmi$2f$node_modules$2f40$tanstack$2f$react$2d$query$2f$build$2f$lib$2f$QueryClientProvider$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/wagmi/node_modules/@tanstack/react-query/build/lib/QueryClientProvider.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$wagmi$2f$node_modules$2f40$tanstack$2f$react$2d$query$2f$build$2f$lib$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/wagmi/node_modules/@tanstack/react-query/build/lib/utils.mjs [app-client] (ecmascript)");
'use client';
;
;
;
;
;
function useMutation(arg1, arg2, arg3) {
    const options = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$wagmi$2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$lib$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parseMutationArgs"])(arg1, arg2, arg3);
    const queryClient = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$wagmi$2f$node_modules$2f40$tanstack$2f$react$2d$query$2f$build$2f$lib$2f$QueryClientProvider$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useQueryClient"])({
        context: options.context
    });
    const [observer] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"]({
        "useMutation.useState": ()=>new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$wagmi$2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$lib$2f$mutationObserver$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MutationObserver"](queryClient, options)
    }["useMutation.useState"]);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"]({
        "useMutation.useEffect": ()=>{
            observer.setOptions(options);
        }
    }["useMutation.useEffect"], [
        observer,
        options
    ]);
    const result = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$wagmi$2f$node_modules$2f40$tanstack$2f$react$2d$query$2f$build$2f$lib$2f$useSyncExternalStore$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useSyncExternalStore"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"]({
        "useMutation.useSyncExternalStore[result]": (onStoreChange)=>observer.subscribe(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$wagmi$2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$lib$2f$notifyManager$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["notifyManager"].batchCalls(onStoreChange))
    }["useMutation.useSyncExternalStore[result]"], [
        observer
    ]), {
        "useMutation.useSyncExternalStore[result]": ()=>observer.getCurrentResult()
    }["useMutation.useSyncExternalStore[result]"], {
        "useMutation.useSyncExternalStore[result]": ()=>observer.getCurrentResult()
    }["useMutation.useSyncExternalStore[result]"]);
    const mutate = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"]({
        "useMutation.useCallback[mutate]": (variables, mutateOptions)=>{
            observer.mutate(variables, mutateOptions).catch(noop);
        }
    }["useMutation.useCallback[mutate]"], [
        observer
    ]);
    if (result.error && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$wagmi$2f$node_modules$2f40$tanstack$2f$react$2d$query$2f$build$2f$lib$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shouldThrowError"])(observer.options.useErrorBoundary, [
        result.error
    ])) {
        throw result.error;
    }
    return {
        ...result,
        mutate,
        mutateAsync: result.mutate
    };
} // eslint-disable-next-line @typescript-eslint/no-empty-function
function noop() {}
;
 //# sourceMappingURL=useMutation.mjs.map
}),
"[project]/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * @license React
 * use-sync-external-store-shim.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
"production" !== ("TURBOPACK compile-time value", "development") && function() {
    function is(x, y) {
        return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
    }
    function useSyncExternalStore$2(subscribe, getSnapshot) {
        didWarnOld18Alpha || void 0 === React.startTransition || (didWarnOld18Alpha = !0, console.error("You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."));
        var value = getSnapshot();
        if (!didWarnUncachedGetSnapshot) {
            var cachedValue = getSnapshot();
            objectIs(value, cachedValue) || (console.error("The result of getSnapshot should be cached to avoid an infinite loop"), didWarnUncachedGetSnapshot = !0);
        }
        cachedValue = useState({
            inst: {
                value: value,
                getSnapshot: getSnapshot
            }
        });
        var inst = cachedValue[0].inst, forceUpdate = cachedValue[1];
        useLayoutEffect({
            "useSyncExternalStore$2.useLayoutEffect": function() {
                inst.value = value;
                inst.getSnapshot = getSnapshot;
                checkIfSnapshotChanged(inst) && forceUpdate({
                    inst: inst
                });
            }
        }["useSyncExternalStore$2.useLayoutEffect"], [
            subscribe,
            value,
            getSnapshot
        ]);
        useEffect({
            "useSyncExternalStore$2.useEffect": function() {
                checkIfSnapshotChanged(inst) && forceUpdate({
                    inst: inst
                });
                return subscribe({
                    "useSyncExternalStore$2.useEffect": function() {
                        checkIfSnapshotChanged(inst) && forceUpdate({
                            inst: inst
                        });
                    }
                }["useSyncExternalStore$2.useEffect"]);
            }
        }["useSyncExternalStore$2.useEffect"], [
            subscribe
        ]);
        useDebugValue(value);
        return value;
    }
    function checkIfSnapshotChanged(inst) {
        var latestGetSnapshot = inst.getSnapshot;
        inst = inst.value;
        try {
            var nextValue = latestGetSnapshot();
            return !objectIs(inst, nextValue);
        } catch (error) {
            return !0;
        }
    }
    function useSyncExternalStore$1(subscribe, getSnapshot) {
        return getSnapshot();
    }
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var React = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)"), objectIs = "function" === typeof Object.is ? Object.is : is, useState = React.useState, useEffect = React.useEffect, useLayoutEffect = React.useLayoutEffect, useDebugValue = React.useDebugValue, didWarnOld18Alpha = !1, didWarnUncachedGetSnapshot = !1, shim = "undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement ? useSyncExternalStore$1 : useSyncExternalStore$2;
    exports.useSyncExternalStore = void 0 !== React.useSyncExternalStore ? React.useSyncExternalStore : shim;
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
}();
}),
"[project]/node_modules/use-sync-external-store/shim/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
'use strict';
if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
;
else {
    module.exports = __turbopack_context__.r("[project]/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js [app-client] (ecmascript)");
}
}),
"[project]/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * @license React
 * use-sync-external-store-shim/with-selector.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
"production" !== ("TURBOPACK compile-time value", "development") && function() {
    function is(x, y) {
        return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
    }
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var React = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)"), shim = __turbopack_context__.r("[project]/node_modules/use-sync-external-store/shim/index.js [app-client] (ecmascript)"), objectIs = "function" === typeof Object.is ? Object.is : is, useSyncExternalStore = shim.useSyncExternalStore, useRef = React.useRef, useEffect = React.useEffect, useMemo = React.useMemo, useDebugValue = React.useDebugValue;
    exports.useSyncExternalStoreWithSelector = function(subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {
        var instRef = useRef(null);
        if (null === instRef.current) {
            var inst = {
                hasValue: !1,
                value: null
            };
            instRef.current = inst;
        } else inst = instRef.current;
        instRef = useMemo(function() {
            function memoizedSelector(nextSnapshot) {
                if (!hasMemo) {
                    hasMemo = !0;
                    memoizedSnapshot = nextSnapshot;
                    nextSnapshot = selector(nextSnapshot);
                    if (void 0 !== isEqual && inst.hasValue) {
                        var currentSelection = inst.value;
                        if (isEqual(currentSelection, nextSnapshot)) return memoizedSelection = currentSelection;
                    }
                    return memoizedSelection = nextSnapshot;
                }
                currentSelection = memoizedSelection;
                if (objectIs(memoizedSnapshot, nextSnapshot)) return currentSelection;
                var nextSelection = selector(nextSnapshot);
                if (void 0 !== isEqual && isEqual(currentSelection, nextSelection)) return memoizedSnapshot = nextSnapshot, currentSelection;
                memoizedSnapshot = nextSnapshot;
                return memoizedSelection = nextSelection;
            }
            var hasMemo = !1, memoizedSnapshot, memoizedSelection, maybeGetServerSnapshot = void 0 === getServerSnapshot ? null : getServerSnapshot;
            return [
                function() {
                    return memoizedSelector(getSnapshot());
                },
                null === maybeGetServerSnapshot ? void 0 : function() {
                    return memoizedSelector(maybeGetServerSnapshot());
                }
            ];
        }, [
            getSnapshot,
            getServerSnapshot,
            selector,
            isEqual
        ]);
        var value = useSyncExternalStore(subscribe, instRef[0], instRef[1]);
        useEffect(function() {
            inst.hasValue = !0;
            inst.value = value;
        }, [
            value
        ]);
        useDebugValue(value);
        return value;
    };
    "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
}();
}),
"[project]/node_modules/use-sync-external-store/shim/with-selector.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
'use strict';
if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
;
else {
    module.exports = __turbopack_context__.r("[project]/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js [app-client] (ecmascript)");
}
}),
]);

//# sourceMappingURL=node_modules_009f366c._.js.map